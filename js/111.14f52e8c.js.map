{"version":3,"file":"js/111.14f52e8c.js","mappings":"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","sources":["webpack://my-project/./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js","webpack://my-project/./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js","webpack://my-project/./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js","webpack://my-project/./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js","webpack://my-project/./node_modules/@chevrotain/utils/lib/src/print.js","webpack://my-project/./node_modules/@chevrotain/utils/lib/src/timer.js","webpack://my-project/./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"],"sourcesContent":["export function cc(char) {\n    return char.charCodeAt(0);\n}\nexport function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n            set.push(subItem);\n        });\n    }\n    else {\n        set.push(item);\n    }\n}\nexport function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n        throw \"duplicate flag \" + flagKey;\n    }\n    const x = flagObj[flagKey];\n    flagObj[flagKey] = true;\n}\nexport function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n        throw Error(\"Internal Error - Should never get here!\");\n    }\n    return true;\n}\n// istanbul ignore next\nexport function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n}\nexport function isCharacter(obj) {\n    return obj[\"type\"] === \"Character\";\n}\n//# sourceMappingURL=utils.js.map","import { cc } from \"./utils.js\";\nexport const digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n}\nexport const wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nexport const whitespaceCodes = [\n    cc(\" \"),\n    cc(\"\\f\"),\n    cc(\"\\n\"),\n    cc(\"\\r\"),\n    cc(\"\\t\"),\n    cc(\"\\v\"),\n    cc(\"\\t\"),\n    cc(\"\\u00a0\"),\n    cc(\"\\u1680\"),\n    cc(\"\\u2000\"),\n    cc(\"\\u2001\"),\n    cc(\"\\u2002\"),\n    cc(\"\\u2003\"),\n    cc(\"\\u2004\"),\n    cc(\"\\u2005\"),\n    cc(\"\\u2006\"),\n    cc(\"\\u2007\"),\n    cc(\"\\u2008\"),\n    cc(\"\\u2009\"),\n    cc(\"\\u200a\"),\n    cc(\"\\u2028\"),\n    cc(\"\\u2029\"),\n    cc(\"\\u202f\"),\n    cc(\"\\u205f\"),\n    cc(\"\\u3000\"),\n    cc(\"\\ufeff\"),\n];\n//# sourceMappingURL=character-classes.js.map","import { addFlag, ASSERT_EXISTS, ASSERT_NEVER_REACH_HERE, cc, insertToSet, isCharacter, } from \"./utils.js\";\nimport { digitsCharCodes, whitespaceCodes, wordCharCodes, } from \"./character-classes.js\";\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nexport class RegExpParser {\n    constructor() {\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n    }\n    saveState() {\n        return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx,\n        };\n    }\n    restoreState(newState) {\n        this.idx = newState.idx;\n        this.input = newState.input;\n        this.groupIdx = newState.groupIdx;\n    }\n    pattern(input) {\n        // parser state\n        this.idx = 0;\n        this.input = input;\n        this.groupIdx = 0;\n        this.consumeChar(\"/\");\n        const value = this.disjunction();\n        this.consumeChar(\"/\");\n        const flags = {\n            type: \"Flags\",\n            loc: { begin: this.idx, end: input.length },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false,\n        };\n        while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n                case \"g\":\n                    addFlag(flags, \"global\");\n                    break;\n                case \"i\":\n                    addFlag(flags, \"ignoreCase\");\n                    break;\n                case \"m\":\n                    addFlag(flags, \"multiLine\");\n                    break;\n                case \"u\":\n                    addFlag(flags, \"unicode\");\n                    break;\n                case \"y\":\n                    addFlag(flags, \"sticky\");\n                    break;\n            }\n        }\n        if (this.idx !== this.input.length) {\n            throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n        }\n        return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0),\n        };\n    }\n    disjunction() {\n        const alts = [];\n        const begin = this.idx;\n        alts.push(this.alternative());\n        while (this.peekChar() === \"|\") {\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n        }\n        return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n    }\n    alternative() {\n        const terms = [];\n        const begin = this.idx;\n        while (this.isTerm()) {\n            terms.push(this.term());\n        }\n        return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n    }\n    term() {\n        if (this.isAssertion()) {\n            return this.assertion();\n        }\n        else {\n            return this.atom();\n        }\n    }\n    assertion() {\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"^\":\n                return {\n                    type: \"StartAnchor\",\n                    loc: this.loc(begin),\n                };\n            case \"$\":\n                return { type: \"EndAnchor\", loc: this.loc(begin) };\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.popChar()) {\n                    case \"b\":\n                        return {\n                            type: \"WordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                    case \"B\":\n                        return {\n                            type: \"NonWordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                }\n                // istanbul ignore next\n                throw Error(\"Invalid Assertion Escape\");\n            // '(?=' or '(?!'\n            case \"(\":\n                this.consumeChar(\"?\");\n                let type;\n                switch (this.popChar()) {\n                    case \"=\":\n                        type = \"Lookahead\";\n                        break;\n                    case \"!\":\n                        type = \"NegativeLookahead\";\n                        break;\n                }\n                ASSERT_EXISTS(type);\n                const disjunction = this.disjunction();\n                this.consumeChar(\")\");\n                return {\n                    type: type,\n                    value: disjunction,\n                    loc: this.loc(begin),\n                };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    quantifier(isBacktracking = false) {\n        let range = undefined;\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"*\":\n                range = {\n                    atLeast: 0,\n                    atMost: Infinity,\n                };\n                break;\n            case \"+\":\n                range = {\n                    atLeast: 1,\n                    atMost: Infinity,\n                };\n                break;\n            case \"?\":\n                range = {\n                    atLeast: 0,\n                    atMost: 1,\n                };\n                break;\n            case \"{\":\n                const atLeast = this.integerIncludingZero();\n                switch (this.popChar()) {\n                    case \"}\":\n                        range = {\n                            atLeast: atLeast,\n                            atMost: atLeast,\n                        };\n                        break;\n                    case \",\":\n                        let atMost;\n                        if (this.isDigit()) {\n                            atMost = this.integerIncludingZero();\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atMost,\n                            };\n                        }\n                        else {\n                            range = {\n                                atLeast: atLeast,\n                                atMost: Infinity,\n                            };\n                        }\n                        this.consumeChar(\"}\");\n                        break;\n                }\n                // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                // causes severe performance degradations\n                if (isBacktracking === true && range === undefined) {\n                    return undefined;\n                }\n                ASSERT_EXISTS(range);\n                break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n            return undefined;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\");\n                range.greedy = false;\n            }\n            else {\n                range.greedy = true;\n            }\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n        }\n    }\n    atom() {\n        let atom;\n        const begin = this.idx;\n        switch (this.peekChar()) {\n            case \".\":\n                atom = this.dotAll();\n                break;\n            case \"\\\\\":\n                atom = this.atomEscape();\n                break;\n            case \"[\":\n                atom = this.characterClass();\n                break;\n            case \"(\":\n                atom = this.group();\n                break;\n        }\n        if (atom === undefined && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier();\n            }\n            return atom;\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    dotAll() {\n        this.consumeChar(\".\");\n        return {\n            type: \"Set\",\n            complement: true,\n            value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\n        };\n    }\n    atomEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    decimalEscapeAtom() {\n        const value = this.positiveInteger();\n        return { type: \"GroupBackReference\", value: value };\n    }\n    characterClassEscape() {\n        let set;\n        let complement = false;\n        switch (this.popChar()) {\n            case \"d\":\n                set = digitsCharCodes;\n                break;\n            case \"D\":\n                set = digitsCharCodes;\n                complement = true;\n                break;\n            case \"s\":\n                set = whitespaceCodes;\n                break;\n            case \"S\":\n                set = whitespaceCodes;\n                complement = true;\n                break;\n            case \"w\":\n                set = wordCharCodes;\n                break;\n            case \"W\":\n                set = wordCharCodes;\n                complement = true;\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(set)) {\n            return { type: \"Set\", value: set, complement: complement };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlEscapeAtom() {\n        let escapeCode;\n        switch (this.popChar()) {\n            case \"f\":\n                escapeCode = cc(\"\\f\");\n                break;\n            case \"n\":\n                escapeCode = cc(\"\\n\");\n                break;\n            case \"r\":\n                escapeCode = cc(\"\\r\");\n                break;\n            case \"t\":\n                escapeCode = cc(\"\\t\");\n                break;\n            case \"v\":\n                escapeCode = cc(\"\\v\");\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(escapeCode)) {\n            return { type: \"Character\", value: escapeCode };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlLetterEscapeAtom() {\n        this.consumeChar(\"c\");\n        const letter = this.popChar();\n        if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error(\"Invalid \");\n        }\n        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n        return { type: \"Character\", value: letterCode };\n    }\n    nulCharacterAtom() {\n        // TODO implement '[lookahead âˆ‰ DecimalDigit]'\n        // TODO: for the deprecated octal escape sequence\n        this.consumeChar(\"0\");\n        return { type: \"Character\", value: cc(\"\\0\") };\n    }\n    hexEscapeSequenceAtom() {\n        this.consumeChar(\"x\");\n        return this.parseHexDigits(2);\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n        this.consumeChar(\"u\");\n        return this.parseHexDigits(4);\n    }\n    identityEscapeAtom() {\n        // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n        const escapedChar = this.popChar();\n        return { type: \"Character\", value: cc(escapedChar) };\n    }\n    classPatternCharacterAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \"]\":\n                throw Error(\"TBD\");\n            default:\n                const nextChar = this.popChar();\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    characterClass() {\n        const set = [];\n        let complement = false;\n        this.consumeChar(\"[\");\n        if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n        }\n        while (this.isClassAtom()) {\n            const from = this.classAtom();\n            const isFromSingleChar = from.type === \"Character\";\n            if (isCharacter(from) && this.isRangeDash()) {\n                this.consumeChar(\"-\");\n                const to = this.classAtom();\n                const isToSingleChar = to.type === \"Character\";\n                // a range can only be used when both sides are single characters\n                if (isCharacter(to)) {\n                    if (to.value < from.value) {\n                        throw Error(\"Range out of order in character class\");\n                    }\n                    set.push({ from: from.value, to: to.value });\n                }\n                else {\n                    // literal dash\n                    insertToSet(from.value, set);\n                    set.push(cc(\"-\"));\n                    insertToSet(to.value, set);\n                }\n            }\n            else {\n                insertToSet(from.value, set);\n            }\n        }\n        this.consumeChar(\"]\");\n        return { type: \"Set\", complement: complement, value: set };\n    }\n    classAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"]\":\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n                throw Error(\"TBD\");\n            case \"\\\\\":\n                return this.classEscape();\n            default:\n                return this.classPatternCharacterAtom();\n        }\n    }\n    classEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            // Matches a backspace.\n            // (Not to be confused with \\b word boundary outside characterClass)\n            case \"b\":\n                this.consumeChar(\"b\");\n                return { type: \"Character\", value: cc(\"\\u0008\") };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    group() {\n        let capturing = true;\n        this.consumeChar(\"(\");\n        switch (this.peekChar(0)) {\n            case \"?\":\n                this.consumeChar(\"?\");\n                this.consumeChar(\":\");\n                capturing = false;\n                break;\n            default:\n                this.groupIdx++;\n                break;\n        }\n        const value = this.disjunction();\n        this.consumeChar(\")\");\n        const groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value,\n        };\n        if (capturing) {\n            groupAst[\"idx\"] = this.groupIdx;\n        }\n        return groupAst;\n    }\n    positiveInteger() {\n        let number = this.popChar();\n        // istanbul ignore next - can't ever get here due to previous lookahead checks\n        // still implementing this error checking in case this ever changes.\n        if (decimalPatternNoZero.test(number) === false) {\n            throw Error(\"Expecting a positive integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    integerIncludingZero() {\n        let number = this.popChar();\n        if (decimalPattern.test(number) === false) {\n            throw Error(\"Expecting an integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    patternCharacter() {\n        const nextChar = this.popChar();\n        switch (nextChar) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"^\":\n            // istanbul ignore next\n            case \"$\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \".\":\n            // istanbul ignore next\n            case \"*\":\n            // istanbul ignore next\n            case \"+\":\n            // istanbul ignore next\n            case \"?\":\n            // istanbul ignore next\n            case \"(\":\n            // istanbul ignore next\n            case \")\":\n            // istanbul ignore next\n            case \"[\":\n            // istanbul ignore next\n            case \"|\":\n                // istanbul ignore next\n                throw Error(\"TBD\");\n            default:\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    isRegExpFlag() {\n        switch (this.peekChar(0)) {\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isRangeDash() {\n        return this.peekChar() === \"-\" && this.isClassAtom(1);\n    }\n    isDigit() {\n        return decimalPattern.test(this.peekChar(0));\n    }\n    isClassAtom(howMuch = 0) {\n        switch (this.peekChar(howMuch)) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    isTerm() {\n        return this.isAtom() || this.isAssertion();\n    }\n    isAtom() {\n        if (this.isPatternCharacter()) {\n            return true;\n        }\n        switch (this.peekChar(0)) {\n            case \".\":\n            case \"\\\\\": // atomEscape\n            case \"[\": // characterClass\n            // TODO: isAtom must be called before isAssertion - disambiguate\n            case \"(\": // group\n                return true;\n            default:\n                return false;\n        }\n    }\n    isAssertion() {\n        switch (this.peekChar(0)) {\n            case \"^\":\n            case \"$\":\n                return true;\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.peekChar(1)) {\n                    case \"b\":\n                    case \"B\":\n                        return true;\n                    default:\n                        return false;\n                }\n            // '(?=' or '(?!'\n            case \"(\":\n                return (this.peekChar(1) === \"?\" &&\n                    (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\"));\n            default:\n                return false;\n        }\n    }\n    isQuantifier() {\n        const prevState = this.saveState();\n        try {\n            return this.quantifier(true) !== undefined;\n        }\n        catch (e) {\n            return false;\n        }\n        finally {\n            this.restoreState(prevState);\n        }\n    }\n    isPatternCharacter() {\n        switch (this.peekChar()) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    parseHexDigits(howMany) {\n        let hexString = \"\";\n        for (let i = 0; i < howMany; i++) {\n            const hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n                throw Error(\"Expecting a HexDecimal digits\");\n            }\n            hexString += hexChar;\n        }\n        const charCode = parseInt(hexString, 16);\n        return { type: \"Character\", value: charCode };\n    }\n    peekChar(howMuch = 0) {\n        return this.input[this.idx + howMuch];\n    }\n    popChar() {\n        const nextChar = this.peekChar(0);\n        this.consumeChar(undefined);\n        return nextChar;\n    }\n    consumeChar(char) {\n        if (char !== undefined && this.input[this.idx] !== char) {\n            throw Error(\"Expected: '\" +\n                char +\n                \"' but found: '\" +\n                this.input[this.idx] +\n                \"' at offset: \" +\n                this.idx);\n        }\n        if (this.idx >= this.input.length) {\n            throw Error(\"Unexpected end of input\");\n        }\n        this.idx++;\n    }\n    loc(begin) {\n        return { begin: begin, end: this.idx };\n    }\n}\n//# sourceMappingURL=regexp-parser.js.map","export class BaseRegExpVisitor {\n    visitChildren(node) {\n        for (const key in node) {\n            const child = node[key];\n            /* istanbul ignore else */\n            if (node.hasOwnProperty(key)) {\n                if (child.type !== undefined) {\n                    this.visit(child);\n                }\n                else if (Array.isArray(child)) {\n                    child.forEach((subChild) => {\n                        this.visit(subChild);\n                    }, this);\n                }\n            }\n        }\n    }\n    visit(node) {\n        switch (node.type) {\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Disjunction\":\n                this.visitDisjunction(node);\n                break;\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"StartAnchor\":\n                this.visitStartAnchor(node);\n                break;\n            case \"EndAnchor\":\n                this.visitEndAnchor(node);\n                break;\n            case \"WordBoundary\":\n                this.visitWordBoundary(node);\n                break;\n            case \"NonWordBoundary\":\n                this.visitNonWordBoundary(node);\n                break;\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                break;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"Set\":\n                this.visitSet(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"GroupBackReference\":\n                this.visitGroupBackReference(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n        }\n        this.visitChildren(node);\n    }\n    visitPattern(node) { }\n    visitFlags(node) { }\n    visitDisjunction(node) { }\n    visitAlternative(node) { }\n    // Assertion\n    visitStartAnchor(node) { }\n    visitEndAnchor(node) { }\n    visitWordBoundary(node) { }\n    visitNonWordBoundary(node) { }\n    visitLookahead(node) { }\n    visitNegativeLookahead(node) { }\n    // atoms\n    visitCharacter(node) { }\n    visitSet(node) { }\n    visitGroup(node) { }\n    visitGroupBackReference(node) { }\n    visitQuantifier(node) { }\n}\n//# sourceMappingURL=base-regexp-visitor.js.map","export function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n        console.error(`Error: ${msg}`);\n    }\n}\nexport function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(`Warning: ${msg}`);\n    }\n}\n//# sourceMappingURL=print.js.map","export function timer(func) {\n    const start = new Date().getTime();\n    const val = func();\n    const end = new Date().getTime();\n    const total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=timer.js.map","// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    const fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    if (1)\n        return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    // - https://esbuild.github.io/content-types/#direct-eval\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    (0, eval)(toBecomeFast);\n}\n//# sourceMappingURL=to-fast-properties.js.map"],"names":["cc","char","charCodeAt","insertToSet","item","set","Array","isArray","forEach","subItem","push","addFlag","flagObj","flagKey","ASSERT_EXISTS","obj","undefined","Error","ASSERT_NEVER_REACH_HERE","isCharacter","digitsCharCodes","i","wordCharCodes","concat","whitespaceCodes","hexDigitPattern","decimalPattern","decimalPatternNoZero","RegExpParser","constructor","this","idx","input","groupIdx","saveState","restoreState","newState","pattern","consumeChar","value","disjunction","flags","type","loc","begin","end","length","global","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","substring","alts","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","quantifier","isBacktracking","range","atLeast","atMost","Infinity","integerIncludingZero","isDigit","greedy","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","escapeCode","letter","test","letterCode","toUpperCase","parseHexDigits","escapedChar","classPatternCharacterAtom","nextChar","isClassAtom","from","classAtom","isRangeDash","to","classEscape","capturing","groupAst","number","parseInt","howMuch","isAtom","prevState","e","howMany","hexString","hexChar","charCode","BaseRegExpVisitor","visitChildren","node","key","child","hasOwnProperty","visit","subChild","visitPattern","visitFlags","visitDisjunction","visitAlternative","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","PRINT_ERROR","msg","console","error","PRINT_WARNING","warn","timer","func","start","Date","getTime","val","total","time","toFastProperties","toBecomeFast","FakeConstructor","prototype","fakeInstance","fakeAccess","bar"],"sourceRoot":""}