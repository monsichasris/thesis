{"version":3,"file":"js/159.fb12a9f4.js","mappings":"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IXra,OAAOC,OAAO,CAGtCqa,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,IACrBC,IAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACnDC,IAAK,CACH,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAEFC,IAAK,CACH,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAEFC,IAAK,CACH,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAGF,QAAS,CAAC,GAAI,GAAI,IAGlBC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,IACzBC,IAAK,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAClDC,IAAK,CACH,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IAEFC,IAAK,CACH,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAEFC,IAAK,CACH,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAEFC,KAAM,CACJ,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,I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","sources":["webpack://my-project/./node_modules/mingo/dist/esm/util.js","webpack://my-project/./node_modules/mingo/dist/esm/core.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/boolean/and.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/boolean/not.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/boolean/or.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js","webpack://my-project/./node_modules/mingo/dist/esm/lazy.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/pipeline/limit.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/pipeline/project.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/pipeline/skip.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/pipeline/sort.js","webpack://my-project/./node_modules/mingo/dist/esm/cursor.js","webpack://my-project/./node_modules/mingo/dist/esm/query.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/_predicates.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/eq.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/gt.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/gte.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/lt.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/lte.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/comparison/ne.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/date/_internal.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/pipeline/densify.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/array/nin.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/window/linearFill.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/array/slice.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/string/substrBytes.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/type/_internal.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/expression/type/toBool.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/projection/elemMatch.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/projection/slice.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/array/all.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/array/elemMatch.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/array/size.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllClear.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllSet.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnySet.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/eq.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/gt.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/gte.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/in.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/lt.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/lte.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/ne.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/comparison/nin.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/element/exists.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/element/type.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/evaluation/expr.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/evaluation/mod.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/evaluation/regex.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/evaluation/where.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/logical/and.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/logical/or.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/logical/nor.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/query/logical/not.js","webpack://my-project/./node_modules/mingo/dist/esm/init/basic.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/_internal.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/addToSet.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/bit.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/currentDate.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/inc.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/max.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/min.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/mul.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/pop.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/pull.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/pullAll.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/push.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/set.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/rename.js","webpack://my-project/./node_modules/mingo/dist/esm/operators/update/unset.js","webpack://my-project/./node_modules/mingo/dist/esm/updater.js"],"sourcesContent":["class MingoError extends Error {\n}\nconst MISSING = Symbol(\"missing\");\nconst CYCLE_FOUND_ERROR = Object.freeze(\n  new Error(\"mingo: cycle detected while processing object/array\")\n);\nconst DEFAULT_HASH_FUNCTION = (value) => {\n  const s = stringify(value);\n  let hash = 0;\n  let i = s.length;\n  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);\n  return hash >>> 0;\n};\nconst isPrimitive = (v) => typeof v !== \"object\" && typeof v !== \"function\" || v === null;\nconst isScalar = (v) => isPrimitive(v) || isDate(v) || isRegExp(v);\nconst SORT_ORDER = {\n  undefined: 1,\n  null: 2,\n  number: 3,\n  string: 4,\n  symbol: 5,\n  object: 6,\n  array: 7,\n  arraybuffer: 8,\n  boolean: 9,\n  date: 10,\n  regexp: 11,\n  function: 12\n};\nconst compare = (a, b) => {\n  if (a === MISSING) a = void 0;\n  if (b === MISSING) b = void 0;\n  const [u, v] = [a, b].map((n) => SORT_ORDER[typeOf(n)] || 0);\n  if (u !== v) return u - v;\n  if (isEqual(a, b)) return 0;\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\nclass ValueMap extends Map {\n  // The hash function\n  #hashFn = DEFAULT_HASH_FUNCTION;\n  // maps the hashcode to key set\n  #keyMap = /* @__PURE__ */ new Map();\n  // returns a tuple of [<masterKey>, <hash>]. Expects an object key.\n  #unpack = (key) => {\n    const hash = this.#hashFn(key);\n    return [(this.#keyMap.get(hash) || []).find((k) => isEqual(k, key)), hash];\n  };\n  constructor() {\n    super();\n  }\n  /**\n   * Returns a new {@link ValueMap} object.\n   * @param fn An optional custom hash function\n   */\n  static init(fn) {\n    const m = new ValueMap();\n    if (fn) m.#hashFn = fn;\n    return m;\n  }\n  clear() {\n    super.clear();\n    this.#keyMap.clear();\n  }\n  /**\n   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    if (isPrimitive(key)) return super.delete(key);\n    const [masterKey, hash] = this.#unpack(key);\n    if (!super.delete(masterKey)) return false;\n    this.#keyMap.set(\n      hash,\n      this.#keyMap.get(hash).filter((k) => !isEqual(k, masterKey))\n    );\n    return true;\n  }\n  /**\n   * Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.\n   * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned.\n   */\n  get(key) {\n    if (isPrimitive(key)) return super.get(key);\n    const [masterKey, _] = this.#unpack(key);\n    return super.get(masterKey);\n  }\n  /**\n   * @returns boolean indicating whether an element with the specified key exists or not.\n   */\n  has(key) {\n    if (isPrimitive(key)) return super.has(key);\n    const [masterKey, _] = this.#unpack(key);\n    return super.has(masterKey);\n  }\n  /**\n   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.\n   */\n  set(key, value) {\n    if (isPrimitive(key)) return super.set(key, value);\n    const [masterKey, hash] = this.#unpack(key);\n    if (super.has(masterKey)) {\n      super.set(masterKey, value);\n    } else {\n      super.set(key, value);\n      const keys = this.#keyMap.get(hash) || [];\n      keys.push(key);\n      this.#keyMap.set(hash, keys);\n    }\n    return this;\n  }\n  /**\n   * @returns the number of elements in the Map.\n   */\n  get size() {\n    return super.size;\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) throw new MingoError(message);\n}\nconst STRING_REP = Object.keys(SORT_ORDER).reduce(\n  (memo, k) => {\n    memo[\"[object \" + k[0].toUpperCase() + k.substring(1) + \"]\"] = k;\n    return memo;\n  },\n  {}\n);\nfunction typeOf(v) {\n  const s = Object.prototype.toString.call(v);\n  return s === \"[object Object]\" ? v?.constructor?.name?.toLowerCase() || \"object\" : STRING_REP[s] || s.substring(8, s.length - 1).toLowerCase();\n}\nconst isBoolean = (v) => typeof v === \"boolean\";\nconst isString = (v) => typeof v === \"string\";\nconst isSymbol = (v) => typeof v === \"symbol\";\nconst isNumber = (v) => !isNaN(v) && typeof v === \"number\";\nconst isNotNaN = (v) => !(isNaN(v) && typeof v === \"number\");\nconst isArray = Array.isArray;\nfunction isObject(v) {\n  if (!v) return false;\n  const p = Object.getPrototypeOf(v);\n  return (p === Object.prototype || p === null) && typeOf(v) === \"object\";\n}\nconst isObjectLike = (v) => !isPrimitive(v);\nconst isDate = (v) => v instanceof Date;\nconst isRegExp = (v) => v instanceof RegExp;\nconst isFunction = (v) => typeof v === \"function\";\nconst isNil = (v) => v === null || v === void 0;\nconst truthy = (arg, strict = true) => !!arg || strict && arg === \"\";\nconst isEmpty = (x) => isNil(x) || isString(x) && !x || isArray(x) && x.length === 0 || isObject(x) && Object.keys(x).length === 0;\nconst ensureArray = (x) => isArray(x) ? x : [x];\nconst has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\nconst isTypedArray = (v) => typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(v);\nconst cloneDeep = (v, refs) => {\n  if (isNil(v) || isBoolean(v) || isNumber(v) || isString(v)) return v;\n  if (isDate(v)) return new Date(v);\n  if (isRegExp(v)) return new RegExp(v);\n  if (isTypedArray(v)) {\n    const ctor = v.constructor;\n    return new ctor(v);\n  }\n  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();\n  if (refs.has(v)) throw CYCLE_FOUND_ERROR;\n  refs.add(v);\n  try {\n    if (isArray(v)) {\n      const arr = new Array(v.length);\n      for (let i = 0; i < v.length; i++) arr[i] = cloneDeep(v[i], refs);\n      return arr;\n    }\n    if (isObject(v)) {\n      const obj = {};\n      for (const k of Object.keys(v)) obj[k] = cloneDeep(v[k], refs);\n      return obj;\n    }\n  } finally {\n    refs.delete(v);\n  }\n  return v;\n};\nconst isMissing = (v) => v === MISSING;\nfunction merge(target, input) {\n  if (isMissing(target) || isNil(target)) return input;\n  if (isMissing(input) || isNil(input)) return target;\n  if (isPrimitive(target) || isPrimitive(input)) return input;\n  if (isArray(target) && isArray(input)) {\n    assert(\n      target.length === input.length,\n      \"arrays must be of equal length to merge.\"\n    );\n  }\n  for (const k of Object.keys(input)) {\n    target[k] = merge(target[k], input[k]);\n  }\n  return target;\n}\nfunction intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const vmaps = [ValueMap.init(hashFunction), ValueMap.init(hashFunction)];\n  if (input.length === 0) return [];\n  if (input.some((arr) => arr.length === 0)) return [];\n  if (input.length === 1) return [...input];\n  input[input.length - 1].forEach((v) => vmaps[0].set(v, true));\n  for (let i = input.length - 2; i > -1; i--) {\n    input[i].forEach((v) => {\n      if (vmaps[0].has(v)) vmaps[1].set(v, true);\n    });\n    if (vmaps[1].size === 0) return [];\n    vmaps.reverse();\n    vmaps[1].clear();\n  }\n  return Array.from(vmaps[0].keys());\n}\nfunction flatten(xs, depth = 1) {\n  const arr = new Array();\n  function flatten2(ys, n) {\n    for (let i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (n > 0 || n < 0)) {\n        flatten2(ys[i], Math.max(-1, n - 1));\n      } else {\n        arr.push(ys[i]);\n      }\n    }\n  }\n  flatten2(xs, depth);\n  return arr;\n}\nfunction getMembersOf(o) {\n  const props = {};\n  while (o) {\n    for (const k of Object.getOwnPropertyNames(o))\n      if (!(k in props)) props[k] = o[k];\n    o = Object.getPrototypeOf(o);\n  }\n  return props;\n}\nfunction hasCustomString(o) {\n  while (o) {\n    if (Object.getOwnPropertyNames(o).includes(\"toString\"))\n      return o[\"toString\"] !== Object.prototype.toString;\n    o = Object.getPrototypeOf(o);\n  }\n  return false;\n}\nfunction isEqual(a, b) {\n  if (a === b || Object.is(a, b)) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== \"object\") return false;\n  if (a.constructor !== b.constructor) return false;\n  if (a instanceof Date) return +a === +b;\n  if (a instanceof RegExp) return a.toString() === b.toString();\n  const ctor = a.constructor;\n  if (ctor === Array || ctor === Object) {\n    const aKeys = Object.keys(a).sort();\n    const bKeys = Object.keys(b).sort();\n    if (aKeys.length !== bKeys.length) return false;\n    for (let i = 0, k = aKeys[i]; i < aKeys.length; k = aKeys[++i]) {\n      if (k !== bKeys[i] || !isEqual(a[k], b[k])) return false;\n    }\n    return true;\n  }\n  return hasCustomString(a) && a.toString() === b.toString();\n}\nfunction unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const m = ValueMap.init(hashFunction);\n  input.forEach((v) => m.set(v, true));\n  return Array.from(m.keys());\n}\nconst stringify = (v, refs) => {\n  if (v === null) return \"null\";\n  if (v === void 0) return \"undefined\";\n  if (isString(v) || isNumber(v) || isBoolean(v)) return JSON.stringify(v);\n  if (isDate(v)) return v.toISOString();\n  if (isRegExp(v) || isSymbol(v) || isFunction(v))\n    return v.toString();\n  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();\n  if (refs.has(v)) throw CYCLE_FOUND_ERROR;\n  try {\n    refs.add(v);\n    if (isArray(v)) return \"[\" + v.map((s2) => stringify(s2, refs)).join(\",\") + \"]\";\n    if (isObject(v)) {\n      const keys = Object.keys(v).sort();\n      return \"{\" + keys.map((k) => `${k}:${stringify(v[k], refs)}`).join() + \"}\";\n    }\n    const s = hasCustomString(v) ? v.toString() : stringify(getMembersOf(v), refs);\n    return typeOf(v) + \"(\" + s + \")\";\n  } finally {\n    refs.delete(v);\n  }\n};\nfunction hashCode(value, hashFunction) {\n  if (isNil(value)) return null;\n  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n  return hashFunction(value);\n}\nfunction groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (collection.length < 1) return /* @__PURE__ */ new Map();\n  const lookup = /* @__PURE__ */ new Map();\n  const result = /* @__PURE__ */ new Map();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    const hash = hashCode(key, hashFunction);\n    if (hash === null) {\n      if (result.has(null)) {\n        result.get(null).push(obj);\n      } else {\n        result.set(null, [obj]);\n      }\n    } else {\n      const existingKey = lookup.has(hash) ? lookup.get(hash).find((k) => isEqual(k, key)) : null;\n      if (isNil(existingKey)) {\n        result.set(key, [obj]);\n        if (lookup.has(hash)) {\n          lookup.get(hash).push(key);\n        } else {\n          lookup.set(hash, [key]);\n        }\n      } else {\n        result.get(existingKey).push(obj);\n      }\n    }\n  }\n  return result;\n}\nconst MAX_ARRAY_PUSH = 5e4;\nfunction into(target, ...rest) {\n  if (isArray(target)) {\n    for (const arr of rest) {\n      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n      let begin = 0;\n      while (i-- > 0) {\n        Array.prototype.push.apply(\n          target,\n          arr.slice(begin, begin + MAX_ARRAY_PUSH)\n        );\n        begin += MAX_ARRAY_PUSH;\n      }\n    }\n    return target;\n  } else {\n    return rest.filter(isObjectLike).reduce((acc, item) => {\n      Object.assign(acc, item);\n      return acc;\n    }, target);\n  }\n}\nfunction getValue(obj, key) {\n  return isObjectLike(obj) ? obj[key] : void 0;\n}\nfunction unwrap(arr, depth) {\n  if (depth < 1) return arr;\n  while (depth-- && arr.length === 1) arr = arr[0];\n  return arr;\n}\nfunction resolve(obj, selector, options) {\n  let depth = 0;\n  function resolve2(o, path) {\n    let value = o;\n    for (let i = 0; i < path.length; i++) {\n      const field = path[i];\n      const isText = /^\\d+$/.exec(field) === null;\n      if (isText && isArray(value)) {\n        if (i === 0 && depth > 0) break;\n        depth += 1;\n        const subpath = path.slice(i);\n        value = value.reduce((acc, item) => {\n          const v = resolve2(item, subpath);\n          if (v !== void 0) acc.push(v);\n          return acc;\n        }, []);\n        break;\n      } else {\n        value = getValue(value, field);\n      }\n      if (value === void 0) break;\n    }\n    return value;\n  }\n  const res = isScalar(obj) ? obj : resolve2(obj, selector.split(\".\"));\n  return isArray(res) && options?.unwrapArray ? unwrap(res, depth) : res;\n}\nfunction resolveGraph(obj, selector, options) {\n  const sep = selector.indexOf(\".\");\n  const key = sep == -1 ? selector : selector.substring(0, sep);\n  const next = selector.substring(sep + 1);\n  const hasNext = sep != -1;\n  if (isArray(obj)) {\n    const isIndex = /^\\d+$/.test(key);\n    const arr = isIndex && options?.preserveIndex ? [...obj] : [];\n    if (isIndex) {\n      const index = parseInt(key);\n      let value2 = getValue(obj, index);\n      if (hasNext) {\n        value2 = resolveGraph(value2, next, options);\n      }\n      if (options?.preserveIndex) {\n        arr[index] = value2;\n      } else {\n        arr.push(value2);\n      }\n    } else {\n      for (const item of obj) {\n        const value2 = resolveGraph(item, selector, options);\n        if (options?.preserveMissing) {\n          arr.push(value2 == void 0 ? MISSING : value2);\n        } else if (value2 != void 0 || options?.preserveIndex) {\n          arr.push(value2);\n        }\n      }\n    }\n    return arr;\n  }\n  const res = options?.preserveKeys ? { ...obj } : {};\n  let value = getValue(obj, key);\n  if (hasNext) {\n    value = resolveGraph(value, next, options);\n  }\n  if (value === void 0) return void 0;\n  res[key] = value;\n  return res;\n}\nfunction filterMissing(obj) {\n  if (isArray(obj)) {\n    for (let i = obj.length - 1; i >= 0; i--) {\n      if (obj[i] === MISSING) {\n        obj.splice(i, 1);\n      } else {\n        filterMissing(obj[i]);\n      }\n    }\n  } else if (isObject(obj)) {\n    for (const k in obj) {\n      if (has(obj, k)) {\n        filterMissing(obj[k]);\n      }\n    }\n  }\n}\nconst NUMBER_RE = /^\\d+$/;\nfunction walk(obj, selector, fn, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  if (names.length === 1) {\n    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {\n      fn(obj, key);\n    }\n  } else {\n    if (options?.buildGraph && isNil(obj[key])) {\n      obj[key] = {};\n    }\n    const item = obj[key];\n    if (!item) return;\n    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));\n    if (isArray(item) && options?.descendArray && !isNextArrayIndex) {\n      item.forEach((e) => walk(e, next, fn, options));\n    } else {\n      walk(item, next, fn, options);\n    }\n  }\n}\nfunction setValue(obj, selector, value) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      item[key] = isFunction(value) ? value(item[key]) : value;\n    },\n    { buildGraph: true }\n  );\n}\nfunction removeValue(obj, selector, options) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      if (isArray(item)) {\n        if (/^\\d+$/.test(key)) {\n          item.splice(parseInt(key), 1);\n        } else if (options && options.descendArray) {\n          for (const elem of item) {\n            if (isObject(elem)) {\n              delete elem[key];\n            }\n          }\n        }\n      } else if (isObject(item)) {\n        delete item[key];\n      }\n    },\n    options\n  );\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\nfunction isOperator(name) {\n  return OPERATOR_NAME_PATTERN.test(name);\n}\nfunction normalize(expr) {\n  if (isScalar(expr)) {\n    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n  }\n  if (isObjectLike(expr)) {\n    if (!Object.keys(expr).some(isOperator)) return { $eq: expr };\n    if (has(expr, \"$regex\")) {\n      const newExpr = { ...expr };\n      newExpr[\"$regex\"] = new RegExp(\n        expr[\"$regex\"],\n        expr[\"$options\"]\n      );\n      delete newExpr[\"$options\"];\n      return newExpr;\n    }\n  }\n  return expr;\n}\nfunction findInsertIndex(sorted, item, comparator = compare) {\n  let lo = 0;\n  let hi = sorted.length - 1;\n  while (lo <= hi) {\n    const mid = Math.round(lo + (hi - lo) / 2);\n    if (comparator(item, sorted[mid]) < 0) {\n      hi = mid - 1;\n    } else if (comparator(item, sorted[mid]) > 0) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return lo;\n}\nexport {\n  MingoError,\n  ValueMap,\n  assert,\n  cloneDeep,\n  compare,\n  ensureArray,\n  filterMissing,\n  findInsertIndex,\n  flatten,\n  groupBy,\n  has,\n  hashCode,\n  intersection,\n  into,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isNil,\n  isNotNaN,\n  isNumber,\n  isObject,\n  isObjectLike,\n  isOperator,\n  isRegExp,\n  isString,\n  isSymbol,\n  merge,\n  normalize,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue,\n  stringify,\n  truthy,\n  typeOf,\n  unique,\n  walk\n};\n","import {\n  assert,\n  has,\n  isArray,\n  isFunction,\n  isNil,\n  isObject,\n  isOperator,\n  isString,\n  resolve\n} from \"./util\";\nvar ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {\n  ProcessingMode2[ProcessingMode2[\"CLONE_OFF\"] = 0] = \"CLONE_OFF\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_INPUT\"] = 1] = \"CLONE_INPUT\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_OUTPUT\"] = 2] = \"CLONE_OUTPUT\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_ALL\"] = 3] = \"CLONE_ALL\";\n  return ProcessingMode2;\n})(ProcessingMode || {});\nclass ComputeOptions {\n  #options;\n  /** Reference to the root object when processing subgraphs of the object. */\n  #root;\n  #local;\n  constructor(options, root, local) {\n    this.#options = options;\n    this.update(root, local);\n  }\n  /**\n   * Initialize new ComputeOptions.\n   * @returns {ComputeOptions}\n   */\n  static init(options, root, local) {\n    return !(options instanceof ComputeOptions) ? new ComputeOptions(options, root, local) : new ComputeOptions(options.#options, options.root ?? root, {\n      ...options.#local,\n      ...local,\n      variables: Object.assign(\n        {},\n        options.#local?.variables,\n        local?.variables\n      )\n    });\n  }\n  /**\n   * Updates the internal state.\n   *\n   * @param root The new root context for this object.\n   * @param local The new local state to merge into current if it exists.\n   * @returns\n   */\n  update(root, local) {\n    this.#root = root;\n    const variables = Object.assign(\n      {},\n      this.#local?.variables,\n      local?.variables\n    );\n    if (Object.keys(variables).length) {\n      this.#local = { ...local, variables };\n    } else {\n      this.#local = local ?? {};\n    }\n    return this;\n  }\n  getOptions() {\n    return Object.freeze({\n      ...this.#options,\n      context: Context.from(this.#options.context)\n    });\n  }\n  get root() {\n    return this.#root;\n  }\n  get local() {\n    return this.#local;\n  }\n  get idKey() {\n    return this.#options.idKey;\n  }\n  get collation() {\n    return this.#options?.collation;\n  }\n  get processingMode() {\n    return this.#options?.processingMode || 0 /* CLONE_OFF */;\n  }\n  get useStrictMode() {\n    return this.#options?.useStrictMode;\n  }\n  get scriptEnabled() {\n    return this.#options?.scriptEnabled;\n  }\n  get useGlobalContext() {\n    return this.#options?.useGlobalContext;\n  }\n  get hashFunction() {\n    return this.#options?.hashFunction;\n  }\n  get collectionResolver() {\n    return this.#options?.collectionResolver;\n  }\n  get jsonSchemaValidator() {\n    return this.#options?.jsonSchemaValidator;\n  }\n  get variables() {\n    return this.#options?.variables;\n  }\n  get context() {\n    return this.#options?.context;\n  }\n}\nfunction initOptions(options) {\n  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({\n    idKey: \"_id\",\n    scriptEnabled: true,\n    useStrictMode: true,\n    useGlobalContext: true,\n    processingMode: 0 /* CLONE_OFF */,\n    ...options,\n    context: options?.context ? Context.from(options?.context) : Context.init()\n  });\n}\nvar OperatorType = /* @__PURE__ */ ((OperatorType2) => {\n  OperatorType2[\"ACCUMULATOR\"] = \"accumulator\";\n  OperatorType2[\"EXPRESSION\"] = \"expression\";\n  OperatorType2[\"PIPELINE\"] = \"pipeline\";\n  OperatorType2[\"PROJECTION\"] = \"projection\";\n  OperatorType2[\"QUERY\"] = \"query\";\n  OperatorType2[\"WINDOW\"] = \"window\";\n  return OperatorType2;\n})(OperatorType || {});\nclass Context {\n  #operators = /* @__PURE__ */ new Map();\n  constructor() {\n  }\n  static init() {\n    return new Context();\n  }\n  static from(ctx) {\n    const instance = Context.init();\n    if (isNil(ctx)) return instance;\n    ctx.#operators.forEach((v, k) => instance.addOperators(k, v));\n    return instance;\n  }\n  addOperators(type, operators) {\n    if (!this.#operators.has(type)) this.#operators.set(type, {});\n    for (const [name, fn] of Object.entries(operators)) {\n      if (!this.getOperator(type, name)) {\n        this.#operators.get(type)[name] = fn;\n      }\n    }\n    return this;\n  }\n  getOperator(type, name) {\n    const ops = this.#operators.get(type) ?? {};\n    return ops[name] ?? null;\n  }\n  addAccumulatorOps(ops) {\n    return this.addOperators(\"accumulator\", ops);\n  }\n  addExpressionOps(ops) {\n    return this.addOperators(\"expression\", ops);\n  }\n  addQueryOps(ops) {\n    return this.addOperators(\"query\", ops);\n  }\n  addPipelineOps(ops) {\n    return this.addOperators(\"pipeline\", ops);\n  }\n  addProjectionOps(ops) {\n    return this.addOperators(\"projection\", ops);\n  }\n  addWindowOps(ops) {\n    return this.addOperators(\"window\", ops);\n  }\n}\nconst GLOBAL_CONTEXT = Context.init();\nfunction useOperators(type, operators) {\n  for (const [name, fn] of Object.entries(operators)) {\n    assert(\n      isFunction(fn) && isOperator(name),\n      `'${name}' is not a valid operator`\n    );\n    const currentFn = getOperator(type, name, null);\n    assert(\n      !currentFn || fn === currentFn,\n      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`\n    );\n  }\n  switch (type) {\n    case \"accumulator\":\n      GLOBAL_CONTEXT.addAccumulatorOps(operators);\n      break;\n    case \"expression\":\n      GLOBAL_CONTEXT.addExpressionOps(operators);\n      break;\n    case \"pipeline\":\n      GLOBAL_CONTEXT.addPipelineOps(operators);\n      break;\n    case \"projection\":\n      GLOBAL_CONTEXT.addProjectionOps(operators);\n      break;\n    case \"query\":\n      GLOBAL_CONTEXT.addQueryOps(operators);\n      break;\n    case \"window\":\n      GLOBAL_CONTEXT.addWindowOps(operators);\n      break;\n  }\n}\nfunction getOperator(type, name, options) {\n  const { context: ctx, useGlobalContext: fallback } = options || {};\n  const fn = ctx ? ctx.getOperator(type, name) : null;\n  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, name) : fn;\n}\nfunction computeValue(obj, expr, operator, options) {\n  const copts = ComputeOptions.init(options, obj);\n  return !!operator && isOperator(operator) ? computeOperator(obj, expr, operator, copts) : computeExpression(obj, expr, copts);\n}\nconst SYSTEM_VARS = [\"$$ROOT\", \"$$CURRENT\", \"$$REMOVE\", \"$$NOW\"];\nfunction computeExpression(obj, expr, options) {\n  if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n    if (REDACT_ACTIONS.includes(expr)) return expr;\n    let ctx = options.root;\n    const arr = expr.split(\".\");\n    if (SYSTEM_VARS.includes(arr[0])) {\n      switch (arr[0]) {\n        case \"$$ROOT\":\n          break;\n        case \"$$CURRENT\":\n          ctx = obj;\n          break;\n        case \"$$REMOVE\":\n          ctx = void 0;\n          break;\n        case \"$$NOW\":\n          ctx = /* @__PURE__ */ new Date();\n          break;\n      }\n      expr = expr.slice(arr[0].length + 1);\n    } else if (arr[0].slice(0, 2) === \"$$\") {\n      ctx = Object.assign(\n        {},\n        // global vars\n        options.variables,\n        // current item is added before local variables because the binding may be changed.\n        { this: obj },\n        // local vars\n        options?.local?.variables\n      );\n      const name = arr[0].slice(2);\n      assert(has(ctx, name), `Use of undefined variable: ${name}`);\n      expr = expr.slice(2);\n    } else {\n      expr = expr.slice(1);\n    }\n    return expr === \"\" ? ctx : resolve(ctx, expr);\n  }\n  if (isArray(expr)) {\n    return expr.map((item) => computeExpression(obj, item, options));\n  }\n  if (isObject(expr)) {\n    const result = {};\n    const elems = Object.entries(expr);\n    for (const [key, val] of elems) {\n      if (isOperator(key)) {\n        assert(elems.length == 1, \"expression must have single operator.\");\n        return computeOperator(obj, val, key, options);\n      }\n      result[key] = computeExpression(obj, val, options);\n    }\n    return result;\n  }\n  return expr;\n}\nfunction computeOperator(obj, expr, operator, options) {\n  const callExpression = getOperator(\n    \"expression\",\n    operator,\n    options\n  );\n  if (callExpression) return callExpression(obj, expr, options);\n  const callAccumulator = getOperator(\n    \"accumulator\",\n    operator,\n    options\n  );\n  assert(!!callAccumulator, `accumulator '${operator}' is not registered.`);\n  if (!isArray(obj)) {\n    obj = computeExpression(obj, expr, options);\n    expr = null;\n  }\n  assert(isArray(obj), `arguments must resolve to array for ${operator}.`);\n  return callAccumulator(obj, expr, options);\n}\nconst REDACT_ACTIONS = [\"$$KEEP\", \"$$PRUNE\", \"$$DESCEND\"];\nfunction redact(obj, expr, options) {\n  const action = computeValue(obj, expr, null, options);\n  switch (action) {\n    case \"$$KEEP\":\n      return obj;\n    case \"$$PRUNE\":\n      return void 0;\n    case \"$$DESCEND\": {\n      if (!has(expr, \"$cond\")) return obj;\n      const output = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if (isArray(value)) {\n          const res = new Array();\n          for (let elem of value) {\n            if (isObject(elem)) {\n              elem = redact(elem, expr, options.update(elem));\n            }\n            if (!isNil(elem)) res.push(elem);\n          }\n          output[key] = res;\n        } else if (isObject(value)) {\n          const res = redact(\n            value,\n            expr,\n            options.update(value)\n          );\n          if (!isNil(res)) output[key] = res;\n        } else {\n          output[key] = value;\n        }\n      }\n      return output;\n    }\n    default:\n      return action;\n  }\n}\nexport {\n  ComputeOptions,\n  Context,\n  OperatorType,\n  ProcessingMode,\n  computeValue,\n  getOperator,\n  initOptions,\n  redact,\n  useOperators\n};\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $and = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return truthy(value, options.useStrictMode) && value.every((v) => truthy(v, options.useStrictMode));\n};\nexport {\n  $and\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, ensureArray } from \"../../../util\";\nconst $not = (obj, expr, options) => {\n  const booleanExpr = ensureArray(expr);\n  if (booleanExpr.length == 0) return false;\n  assert(booleanExpr.length == 1, \"Expression $not takes exactly 1 argument\");\n  return !computeValue(obj, booleanExpr[0], null, options);\n};\nexport {\n  $not\n};\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $or = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  const strict = options.useStrictMode;\n  return truthy(value, strict) && value.some((v) => truthy(v, strict));\n};\nexport {\n  $or\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, compare, isArray } from \"../../../util\";\nconst $cmp = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.length == 2,\n    \"$cmp: expression must resolve to array of size 2.\"\n  );\n  return compare(args[0], args[1]);\n};\nexport {\n  $cmp\n};\n","import { isArray, MingoError } from \"./util\";\nfunction Lazy(source) {\n  return source instanceof Iterator ? source : new Iterator(source);\n}\nfunction concat(...iterators) {\n  let index = 0;\n  return Lazy(() => {\n    while (index < iterators.length) {\n      const o = iterators[index].next();\n      if (!o.done) return o;\n      index++;\n    }\n    return { done: true };\n  });\n}\nfunction isGenerator(o) {\n  return !!o && typeof o === \"object\" && o?.next instanceof Function;\n}\nfunction dropItem(array, i) {\n  const rest = array.slice(i + 1);\n  array.splice(i);\n  Array.prototype.push.apply(array, rest);\n}\nconst DONE = new Error();\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[Action2[\"MAP\"] = 0] = \"MAP\";\n  Action2[Action2[\"FILTER\"] = 1] = \"FILTER\";\n  Action2[Action2[\"TAKE\"] = 2] = \"TAKE\";\n  Action2[Action2[\"DROP\"] = 3] = \"DROP\";\n  return Action2;\n})(Action || {});\nfunction createCallback(nextFn, iteratees, buffer) {\n  let done = false;\n  let index = -1;\n  let bufferIndex = 0;\n  return function(storeResult) {\n    try {\n      outer: while (!done) {\n        let o = nextFn();\n        index++;\n        let i = -1;\n        const size = iteratees.length;\n        let innerDone = false;\n        while (++i < size) {\n          const r = iteratees[i];\n          switch (r.action) {\n            case 0 /* MAP */:\n              o = r.func(o, index);\n              break;\n            case 1 /* FILTER */:\n              if (!r.func(o, index)) continue outer;\n              break;\n            case 2 /* TAKE */:\n              --r.count;\n              if (!r.count) innerDone = true;\n              break;\n            case 3 /* DROP */:\n              --r.count;\n              if (!r.count) dropItem(iteratees, i);\n              continue outer;\n            default:\n              break outer;\n          }\n        }\n        done = innerDone;\n        if (storeResult) {\n          buffer[bufferIndex++] = o;\n        } else {\n          return { value: o, done: false };\n        }\n      }\n    } catch (e) {\n      if (e !== DONE) throw e;\n    }\n    done = true;\n    return { done };\n  };\n}\nclass Iterator {\n  /**\n   * @param {*} source An iterable object or function.\n   *    Array - return one element per cycle\n   *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n   *    Function - call to return the next value\n   * @param {Function} fn An optional transformation function\n   */\n  constructor(source) {\n    this.#iteratees = [];\n    this.#yieldedValues = [];\n    this.isDone = false;\n    let nextVal;\n    if (source instanceof Function) {\n      source = { next: source };\n    }\n    if (isGenerator(source)) {\n      const src = source;\n      nextVal = () => {\n        const o = src.next();\n        if (o.done) throw DONE;\n        return o.value;\n      };\n    } else if (isArray(source)) {\n      const data = source;\n      const size = data.length;\n      let index = 0;\n      nextVal = () => {\n        if (index < size) return data[index++];\n        throw DONE;\n      };\n    } else if (!(source instanceof Function)) {\n      throw new MingoError(\n        `Lazy must be initialized with an array, generator, or function.`\n      );\n    }\n    this.#getNext = createCallback(\n      nextVal,\n      this.#iteratees,\n      this.#yieldedValues\n    );\n  }\n  #iteratees;\n  #yieldedValues;\n  #getNext;\n  /**\n   * Add an iteratee to this lazy sequence\n   */\n  push(action, value) {\n    if (typeof value === \"function\") {\n      this.#iteratees.push({ action, func: value });\n    } else if (typeof value === \"number\") {\n      this.#iteratees.push({ action, count: value });\n    }\n    return this;\n  }\n  next() {\n    return this.#getNext();\n  }\n  // Iteratees methods\n  /**\n   * Transform each item in the sequence to a new value\n   * @param {Function} f\n   */\n  map(f) {\n    return this.push(0 /* MAP */, f);\n  }\n  /**\n   * Select only items matching the given predicate\n   * @param {Function} pred\n   */\n  filter(predicate) {\n    return this.push(1 /* FILTER */, predicate);\n  }\n  /**\n   * Take given numbe for values from sequence\n   * @param {Number} n A number greater than 0\n   */\n  take(n) {\n    return n > 0 ? this.push(2 /* TAKE */, n) : this;\n  }\n  /**\n   * Drop a number of values from the sequence\n   * @param {Number} n Number of items to drop greater than 0\n   */\n  drop(n) {\n    return n > 0 ? this.push(3 /* DROP */, n) : this;\n  }\n  // Transformations\n  /**\n   * Returns a new lazy object with results of the transformation\n   * The entire sequence is realized.\n   *\n   * @param {Callback<Source, Any[]>} fn Tranform function of type (Array) => (Any)\n   */\n  transform(fn) {\n    const self = this;\n    let iter;\n    return Lazy(() => {\n      if (!iter) {\n        iter = Lazy(fn(self.value()));\n      }\n      return iter.next();\n    });\n  }\n  // Terminal methods\n  /**\n   * Returns the fully realized values of the iterators.\n   * The return value will be an array unless `lazy.first()` was used.\n   * The realized values are cached for subsequent calls.\n   */\n  value() {\n    if (!this.isDone) {\n      this.isDone = this.#getNext(true).done;\n    }\n    return this.#yieldedValues;\n  }\n  /**\n   * Execute the funcion for each value. Will stop when an execution returns false.\n   * @param {Function} f\n   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n   */\n  each(f) {\n    for (; ; ) {\n      const o = this.next();\n      if (o.done) break;\n      if (f(o.value) === false) return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the reduction of sequence according the reducing function\n   *\n   * @param {*} f a reducing function\n   * @param {*} initialValue\n   */\n  reduce(f, initialValue) {\n    let o = this.next();\n    if (initialValue === void 0 && !o.done) {\n      initialValue = o.value;\n      o = this.next();\n    }\n    while (!o.done) {\n      initialValue = f(initialValue, o.value);\n      o = this.next();\n    }\n    return initialValue;\n  }\n  /**\n   * Returns the number of matched items in the sequence\n   */\n  size() {\n    return this.reduce(\n      (acc, _) => ++acc,\n      0\n    );\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n}\nexport {\n  Iterator,\n  Lazy,\n  concat\n};\n","const $limit = (collection, expr, _options) => collection.take(expr);\nexport {\n  $limit\n};\n","import {\n  ComputeOptions,\n  computeValue,\n  getOperator\n} from \"../../core\";\nimport {\n  assert,\n  ensureArray,\n  filterMissing,\n  has,\n  isArray,\n  isBoolean,\n  isEmpty,\n  isNumber,\n  isObject,\n  isOperator,\n  isString,\n  merge,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue\n} from \"../../util\";\nconst $project = (collection, expr, options) => {\n  if (isEmpty(expr)) return collection;\n  validateExpression(expr, options);\n  return collection.map(createHandler(expr, ComputeOptions.init(options)));\n};\nfunction createHandler(expr, options, isRoot = true) {\n  const idKey = options.idKey;\n  const expressionKeys = Object.keys(expr);\n  const excludedKeys = new Array();\n  const includedKeys = new Array();\n  const handlers = {};\n  for (const key of expressionKeys) {\n    const subExpr = expr[key];\n    if (isNumber(subExpr) || isBoolean(subExpr)) {\n      if (subExpr) {\n        includedKeys.push(key);\n      } else {\n        excludedKeys.push(key);\n      }\n    } else if (isArray(subExpr)) {\n      handlers[key] = (o) => subExpr.map((v) => computeValue(o, v, null, options.update(o)) ?? null);\n    } else if (isObject(subExpr)) {\n      const subExprKeys = Object.keys(subExpr);\n      const operator = subExprKeys.length == 1 ? subExprKeys[0] : \"\";\n      const projectFn = getOperator(\n        \"projection\",\n        operator,\n        options\n      );\n      if (projectFn) {\n        const foundSlice = operator === \"$slice\";\n        if (foundSlice && !ensureArray(subExpr[operator]).every(isNumber)) {\n          handlers[key] = (o) => computeValue(o, subExpr, key, options.update(o));\n        } else {\n          handlers[key] = (o) => projectFn(o, subExpr[operator], key, options.update(o));\n        }\n      } else if (isOperator(operator)) {\n        handlers[key] = (o) => computeValue(o, subExpr[operator], operator, options);\n      } else {\n        validateExpression(subExpr, options);\n        handlers[key] = (o) => {\n          if (!has(o, key)) return computeValue(o, subExpr, null, options);\n          if (isRoot) options.update(o);\n          const target = resolve(o, key);\n          const fn = createHandler(subExpr, options, false);\n          if (isArray(target)) return target.map(fn);\n          if (isObject(target)) return fn(target);\n          return fn(o);\n        };\n      }\n    } else {\n      handlers[key] = isString(subExpr) && subExpr[0] === \"$\" ? (o) => computeValue(o, subExpr, key, options) : (_) => subExpr;\n    }\n  }\n  const handlerKeys = Object.keys(handlers);\n  const idKeyExcluded = excludedKeys.includes(idKey);\n  const idKeyOnlyExcluded = isRoot && idKeyExcluded && excludedKeys.length === 1 && !includedKeys.length && !handlerKeys.length;\n  if (idKeyOnlyExcluded) {\n    return (o) => {\n      const newObj = { ...o };\n      delete newObj[idKey];\n      return newObj;\n    };\n  }\n  const idKeyImplicit = isRoot && !idKeyExcluded && !includedKeys.includes(idKey);\n  const opts = {\n    preserveMissing: true\n  };\n  return (o) => {\n    const newObj = {};\n    if (excludedKeys.length && !includedKeys.length) {\n      merge(newObj, o);\n      for (const k of excludedKeys) {\n        removeValue(newObj, k, { descendArray: true });\n      }\n    }\n    for (const k of includedKeys) {\n      const pathObj = resolveGraph(o, k, opts) ?? {};\n      merge(newObj, pathObj);\n    }\n    if (includedKeys.length) filterMissing(newObj);\n    for (const k of handlerKeys) {\n      const value = handlers[k](o);\n      if (value === void 0) {\n        removeValue(newObj, k, { descendArray: true });\n      } else {\n        setValue(newObj, k, value);\n      }\n    }\n    if (idKeyImplicit && has(o, idKey)) {\n      newObj[idKey] = resolve(o, idKey);\n    }\n    return newObj;\n  };\n}\nfunction validateExpression(expr, options) {\n  let exclusions = false;\n  let inclusions = false;\n  for (const [k, v] of Object.entries(expr)) {\n    assert(!k.startsWith(\"$\"), \"Field names may not start with '$'.\");\n    assert(\n      !k.endsWith(\".$\"),\n      \"Positional projection operator '$' is not supported.\"\n    );\n    if (k === options?.idKey) continue;\n    if (v === 0 || v === false) {\n      exclusions = true;\n    } else if (v === 1 || v === true) {\n      inclusions = true;\n    }\n    assert(\n      !(exclusions && inclusions),\n      \"Projection cannot have a mix of inclusion and exclusion.\"\n    );\n  }\n}\nexport {\n  $project\n};\n","const $skip = (collection, expr, _options) => {\n  return collection.drop(expr);\n};\nexport {\n  $skip\n};\n","import {\n  assert,\n  compare,\n  groupBy,\n  isEmpty,\n  isObject,\n  isString,\n  resolve\n} from \"../../util\";\nconst $sort = (collection, sortKeys, options) => {\n  if (isEmpty(sortKeys) || !isObject(sortKeys)) return collection;\n  let cmp = compare;\n  const collationSpec = options.collation;\n  if (isObject(collationSpec) && isString(collationSpec.locale)) {\n    cmp = collationComparator(collationSpec);\n  }\n  return collection.transform((coll) => {\n    const modifiers = Object.keys(sortKeys);\n    for (const key of modifiers.reverse()) {\n      const groups = groupBy(\n        coll,\n        (obj) => resolve(obj, key),\n        options.hashFunction\n      );\n      const sortedKeys = Array.from(groups.keys()).sort(cmp);\n      if (sortKeys[key] === -1) sortedKeys.reverse();\n      let i = 0;\n      for (const k of sortedKeys) for (const v of groups.get(k)) coll[i++] = v;\n      assert(i == coll.length, \"bug: counter must match collection size.\");\n    }\n    return coll;\n  });\n};\nconst COLLATION_STRENGTH = {\n  // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.\n  1: \"base\",\n  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.\n  // Examples: a ≠ b, a ≠ á, a = A.\n  2: \"accent\",\n  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.\n  // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A\n  3: \"variant\"\n  // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.\n};\nfunction collationComparator(spec) {\n  const localeOpt = {\n    sensitivity: COLLATION_STRENGTH[spec.strength || 3],\n    caseFirst: spec.caseFirst === \"off\" ? \"false\" : spec.caseFirst || \"false\",\n    numeric: spec.numericOrdering || false,\n    ignorePunctuation: spec.alternate === \"shifted\"\n  };\n  if ((spec.caseLevel || false) === true) {\n    if (localeOpt.sensitivity === \"base\") localeOpt.sensitivity = \"case\";\n    if (localeOpt.sensitivity === \"accent\") localeOpt.sensitivity = \"variant\";\n  }\n  const collator = new Intl.Collator(spec.locale, localeOpt);\n  return (a, b) => {\n    if (!isString(a) || !isString(b)) return compare(a, b);\n    const i = collator.compare(a, b);\n    if (i < 0) return -1;\n    if (i > 0) return 1;\n    return 0;\n  };\n}\nexport {\n  $sort\n};\n","import {\n  ProcessingMode\n} from \"./core\";\nimport { concat, Lazy } from \"./lazy\";\nimport { $limit } from \"./operators/pipeline/limit\";\nimport { $project } from \"./operators/pipeline/project\";\nimport { $skip } from \"./operators/pipeline/skip\";\nimport { $sort } from \"./operators/pipeline/sort\";\nimport { cloneDeep, has } from \"./util\";\nconst OPERATORS = { $sort, $skip, $limit };\nclass Cursor {\n  #source;\n  #predicate;\n  #projection;\n  #options;\n  #operators = {};\n  #result = null;\n  #buffer = [];\n  constructor(source, predicate, projection, options) {\n    this.#source = source;\n    this.#predicate = predicate;\n    this.#projection = projection;\n    this.#options = options;\n  }\n  /** Returns the iterator from running the query */\n  fetch() {\n    if (this.#result) return this.#result;\n    this.#result = Lazy(this.#source).filter(this.#predicate);\n    const mode = this.#options.processingMode;\n    if (mode & ProcessingMode.CLONE_INPUT) this.#result.map(cloneDeep);\n    for (const op of [\"$sort\", \"$skip\", \"$limit\"]) {\n      if (has(this.#operators, op)) {\n        this.#result = OPERATORS[op](\n          this.#result,\n          this.#operators[op],\n          this.#options\n        );\n      }\n    }\n    if (Object.keys(this.#projection).length) {\n      this.#result = $project(this.#result, this.#projection, this.#options);\n    }\n    if (mode & ProcessingMode.CLONE_OUTPUT) this.#result.map(cloneDeep);\n    return this.#result;\n  }\n  /** Returns an iterator with the buffered data included */\n  fetchAll() {\n    const buffered = Lazy([...this.#buffer]);\n    this.#buffer = [];\n    return concat(buffered, this.fetch());\n  }\n  /**\n   * Return remaining objects in the cursor as an array. This method exhausts the cursor\n   * @returns {Array}\n   */\n  all() {\n    return this.fetchAll().value();\n  }\n  /**\n   * Returns the number of objects return in the cursor. This method exhausts the cursor\n   * @returns {Number}\n   */\n  count() {\n    return this.all().length;\n  }\n  /**\n   * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n   * @param {Number} n the number of results to skip.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  skip(n) {\n    this.#operators[\"$skip\"] = n;\n    return this;\n  }\n  /**\n   * Constrains the size of a cursor's result set.\n   * @param {Number} n the number of results to limit to.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  limit(n) {\n    this.#operators[\"$limit\"] = n;\n    return this;\n  }\n  /**\n   * Returns results ordered according to a sort specification.\n   * @param {AnyObject} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  sort(modifier) {\n    this.#operators[\"$sort\"] = modifier;\n    return this;\n  }\n  /**\n   * Specifies the collation for the cursor returned by the `mingo.Query.find`\n   * @param {*} spec\n   */\n  collation(spec) {\n    this.#options = { ...this.#options, collation: spec };\n    return this;\n  }\n  /**\n   * Returns the next document in a cursor.\n   * @returns {AnyObject | Boolean}\n   */\n  next() {\n    if (this.#buffer.length > 0) {\n      return this.#buffer.pop();\n    }\n    const o = this.fetch().next();\n    if (o.done) return;\n    return o.value;\n  }\n  /**\n   * Returns true if the cursor has documents and can be iterated.\n   * @returns {boolean}\n   */\n  hasNext() {\n    if (this.#buffer.length > 0) return true;\n    const o = this.fetch().next();\n    if (o.done) return false;\n    this.#buffer.push(o.value);\n    return true;\n  }\n  /**\n   * Applies a function to each document in a cursor and collects the return values in an array.\n   * @param fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.all().map(fn);\n  }\n  /**\n   * Applies a JavaScript function for every document in a cursor.\n   * @param fn\n   */\n  forEach(fn) {\n    this.all().forEach(fn);\n  }\n  [Symbol.iterator]() {\n    return this.fetchAll();\n  }\n}\nexport {\n  Cursor\n};\n","import { getOperator, initOptions } from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport { assert, cloneDeep, isObject, isOperator, normalize } from \"./util\";\nconst TOP_LEVEL_OPS = new Set(\n  Array.from([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"])\n);\nclass Query {\n  #compiled;\n  #options;\n  #condition;\n  constructor(condition, options) {\n    this.#condition = cloneDeep(condition);\n    this.#options = initOptions(options);\n    this.#compiled = [];\n    this.compile();\n  }\n  compile() {\n    assert(\n      isObject(this.#condition),\n      `query criteria must be an object: ${JSON.stringify(this.#condition)}`\n    );\n    const whereOperator = {};\n    for (const [field, expr] of Object.entries(this.#condition)) {\n      if (\"$where\" === field) {\n        assert(\n          this.#options.scriptEnabled,\n          \"$where operator requires 'scriptEnabled' option to be true.\"\n        );\n        Object.assign(whereOperator, { field, expr });\n      } else if (TOP_LEVEL_OPS.has(field)) {\n        this.processOperator(field, field, expr);\n      } else {\n        assert(!isOperator(field), `unknown top level operator: ${field}`);\n        for (const [operator, val] of Object.entries(\n          normalize(expr)\n        )) {\n          this.processOperator(field, operator, val);\n        }\n      }\n      if (whereOperator.field) {\n        this.processOperator(\n          whereOperator.field,\n          whereOperator.field,\n          whereOperator.expr\n        );\n      }\n    }\n  }\n  processOperator(field, operator, value) {\n    const call = getOperator(\"query\", operator, this.#options);\n    assert(!!call, `unknown query operator ${operator}`);\n    this.#compiled.push(call(field, value, this.#options));\n  }\n  /**\n   * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n   *\n   * @param obj The object to test\n   * @returns {boolean}\n   */\n  test(obj) {\n    return this.#compiled.every((p) => p(obj));\n  }\n  /**\n   * Returns a cursor to select matching documents from the input source.\n   *\n   * @param source A source providing a sequence of documents\n   * @param projection An optional projection criteria\n   * @returns {Cursor} A Cursor for iterating over the results\n   */\n  find(collection, projection) {\n    return new Cursor(\n      collection,\n      (o) => this.test(o),\n      projection || {},\n      this.#options\n    );\n  }\n  /**\n   * Remove matched documents from the collection returning the remainder\n   *\n   * @param collection An array of documents\n   * @returns {Array} A new array with matching elements removed\n   */\n  remove(collection) {\n    return collection.reduce((acc, obj) => {\n      if (!this.test(obj)) acc.push(obj);\n      return acc;\n    }, []);\n  }\n}\nexport {\n  Query\n};\n","import {\n  computeValue\n} from \"../core\";\nimport { Query } from \"../query\";\nimport {\n  compare as mingoCmp,\n  ensureArray,\n  flatten,\n  intersection,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isNil,\n  isNumber,\n  isObject,\n  isOperator,\n  isRegExp,\n  isString,\n  MingoError,\n  resolve,\n  truthy,\n  typeOf\n} from \"../util\";\nfunction createQueryOperator(predicate) {\n  const f = (selector, value, options) => {\n    const opts = { unwrapArray: true };\n    const depth = Math.max(1, selector.split(\".\").length - 1);\n    return (obj) => {\n      const lhs = resolve(obj, selector, opts);\n      return predicate(lhs, value, { ...options, depth });\n    };\n  };\n  return f;\n}\nfunction createExpressionOperator(predicate) {\n  return (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    return predicate(...args);\n  };\n}\nfunction $eq(a, b, options) {\n  if (isEqual(a, b)) return true;\n  if (isNil(a) && isNil(b)) return true;\n  if (isArray(a)) {\n    return a.some((v) => isEqual(v, b)) || flatten(a, options?.depth).some((v) => isEqual(v, b));\n  }\n  return false;\n}\nfunction $ne(a, b, options) {\n  return !$eq(a, b, options);\n}\nfunction $in(a, b, options) {\n  if (isNil(a)) return b.some((v) => v === null);\n  return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\nfunction $nin(a, b, options) {\n  return !$in(a, b, options);\n}\nfunction $lt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) < 0);\n}\nfunction $lte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) <= 0);\n}\nfunction $gt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) > 0);\n}\nfunction $gte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) >= 0);\n}\nfunction $mod(a, b, _options) {\n  return ensureArray(a).some(\n    (x) => b.length === 2 && x % b[0] === b[1]\n  );\n}\nfunction $regex(a, b, options) {\n  const lhs = ensureArray(a);\n  const match = (x) => isString(x) && truthy(b.exec(x), options?.useStrictMode);\n  return lhs.some(match) || flatten(lhs, 1).some(match);\n}\nfunction $all(values, queries, options) {\n  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {\n    return false;\n  }\n  let matched = true;\n  for (const query of queries) {\n    if (!matched) break;\n    if (isObject(query) && Object.keys(query).includes(\"$elemMatch\")) {\n      matched = $elemMatch(values, query[\"$elemMatch\"], options);\n    } else if (isRegExp(query)) {\n      matched = values.some((s) => typeof s === \"string\" && query.test(s));\n    } else {\n      matched = values.some((v) => isEqual(query, v));\n    }\n  }\n  return matched;\n}\nfunction $size(a, b, _options) {\n  return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n  return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\nfunction $elemMatch(a, b, options) {\n  if (isArray(a) && !isEmpty(a)) {\n    let format = (x) => x;\n    let criteria = b;\n    if (Object.keys(b).every(isNonBooleanOperator)) {\n      criteria = { temp: b };\n      format = (x) => ({ temp: x });\n    }\n    const query = new Query(criteria, options);\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (query.test(format(a[i]))) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nconst isNull = (a) => a === null;\nconst compareFuncs = {\n  array: isArray,\n  boolean: isBoolean,\n  bool: isBoolean,\n  date: isDate,\n  number: isNumber,\n  int: isNumber,\n  long: isNumber,\n  double: isNumber,\n  decimal: isNumber,\n  null: isNull,\n  object: isObject,\n  regexp: isRegExp,\n  regex: isRegExp,\n  string: isString,\n  // added for completeness\n  undefined: isNil,\n  // deprecated\n  function: (_) => {\n    throw new MingoError(\"unsupported type key `function`.\");\n  },\n  // Mongo identifiers\n  1: isNumber,\n  //double\n  2: isString,\n  3: isObject,\n  4: isArray,\n  6: isNil,\n  // deprecated\n  8: isBoolean,\n  9: isDate,\n  10: isNull,\n  11: isRegExp,\n  16: isNumber,\n  //int\n  18: isNumber,\n  //long\n  19: isNumber\n  //decimal\n};\nfunction compareType(a, b, _) {\n  const f = compareFuncs[b];\n  return f ? f(a) : false;\n}\nfunction $type(a, b, options) {\n  return isArray(b) ? b.findIndex((t) => compareType(a, t, options)) >= 0 : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n  return ensureArray(a).some((x) => typeOf(x) === typeOf(b) && f(x, b));\n}\nexport {\n  $all,\n  $elemMatch,\n  $eq,\n  $gt,\n  $gte,\n  $in,\n  $lt,\n  $lte,\n  $mod,\n  $ne,\n  $nin,\n  $regex,\n  $size,\n  $type,\n  createExpressionOperator,\n  createQueryOperator\n};\n","import { $eq as __eq, createExpressionOperator } from \"../../_predicates\";\nconst $eq = createExpressionOperator(__eq);\nexport {\n  $eq\n};\n","import { $gt as __gt, createExpressionOperator } from \"../../_predicates\";\nconst $gt = createExpressionOperator(__gt);\nexport {\n  $gt\n};\n","import { $gte as __gte, createExpressionOperator } from \"../../_predicates\";\nconst $gte = createExpressionOperator(__gte);\nexport {\n  $gte\n};\n","import { $lt as __lt, createExpressionOperator } from \"../../_predicates\";\nconst $lt = createExpressionOperator(__lt);\nexport {\n  $lt\n};\n","import { $lte as __lte, createExpressionOperator } from \"../../_predicates\";\nconst $lte = createExpressionOperator(__lte);\nexport {\n  $lte\n};\n","import { $ne as __ne, createExpressionOperator } from \"../../_predicates\";\nconst $ne = createExpressionOperator(__ne);\nexport {\n  $ne\n};\n","import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport {\n  assert,\n  compare,\n  findInsertIndex,\n  isArray,\n  isEqual,\n  isNil,\n  isNumber\n} from \"../../util\";\nconst $bucketAuto = (collection, expr, options) => {\n  const {\n    buckets: bucketCount,\n    groupBy: groupByExpr,\n    output: optOutputExpr,\n    // Available only if the all groupBy values are numeric and none of them are NaN.\n    granularity\n  } = expr;\n  const outputExpr = optOutputExpr ?? { count: { $sum: 1 } };\n  assert(\n    bucketCount > 0,\n    `$bucketAuto: 'buckets' field must be greater than 0, but found: ${bucketCount}`\n  );\n  if (granularity) {\n    assert(\n      /^(POWERSOF2|1-2-5|E(6|12|24|48|96|192)|R(5|10|20|40|80))$/.test(\n        granularity\n      ),\n      `$bucketAuto: invalid granularity '${granularity}'.`\n    );\n  }\n  const keyMap = /* @__PURE__ */ new Map();\n  const setKey = !granularity ? (o, k) => keyMap.set(o, k) : (_, _2) => {\n  };\n  const sorted = collection.map((o) => {\n    const k = computeValue(o, groupByExpr, null, options) ?? null;\n    assert(\n      !granularity || isNumber(k),\n      \"$bucketAuto: groupBy values must be numeric when granularity is specified.\"\n    );\n    setKey(o, k ?? null);\n    return [k ?? null, o];\n  }).value();\n  sorted.sort((x, y) => {\n    if (isNil(x[0])) return -1;\n    if (isNil(y[0])) return 1;\n    return compare(x[0], y[0]);\n  });\n  let getNext;\n  if (!granularity) {\n    getNext = granularityDefault(sorted, bucketCount, keyMap);\n  } else if (granularity == \"POWERSOF2\") {\n    getNext = granularityPowerOfTwo(\n      sorted,\n      bucketCount\n    );\n  } else {\n    getNext = granularityPreferredSeries(\n      sorted,\n      bucketCount,\n      granularity\n    );\n  }\n  let terminate = false;\n  return Lazy(() => {\n    if (terminate) return { done: true };\n    const { min, max, bucket, done } = getNext();\n    terminate = done;\n    const outFields = computeValue(\n      bucket,\n      outputExpr,\n      null,\n      options\n    );\n    for (const [k, v] of Object.entries(outFields)) {\n      if (isArray(v)) outFields[k] = v.filter((v2) => v2 !== void 0);\n    }\n    return {\n      done: false,\n      value: {\n        ...outFields,\n        _id: { min, max }\n      }\n    };\n  });\n};\nfunction granularityDefault(sorted, bucketCount, keyMap) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  let index = 0;\n  let nBuckets = 0;\n  return () => {\n    const isLastBucket = ++nBuckets == bucketCount;\n    const bucket = new Array();\n    while (index < size && (isLastBucket || bucket.length < approxBucketSize || index > 0 && isEqual(sorted[index - 1][0], sorted[index][0]))) {\n      bucket.push(sorted[index++][1]);\n    }\n    const min = keyMap.get(bucket[0]);\n    let max;\n    if (index < size) {\n      max = sorted[index][0];\n    } else {\n      max = keyMap.get(bucket[bucket.length - 1]);\n    }\n    assert(\n      isNil(max) || isNil(min) || min <= max,\n      `error: $bucketAuto boundary must be in order.`\n    );\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nfunction granularityPowerOfTwo(sorted, bucketCount) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  const roundUp2 = (n) => n === 0 ? 0 : 2 ** (Math.floor(Math.log2(n)) + 1);\n  let index = 0;\n  let min = 0;\n  let max = 0;\n  return () => {\n    const bucket = new Array();\n    const boundValue = roundUp2(max);\n    min = index > 0 ? max : 0;\n    while (bucket.length < approxBucketSize && index < size && (max === 0 || sorted[index][0] < boundValue)) {\n      bucket.push(sorted[index++][1]);\n    }\n    max = max == 0 ? roundUp2(sorted[index - 1][0]) : boundValue;\n    while (index < size && sorted[index][0] < max) {\n      bucket.push(sorted[index++][1]);\n    }\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nconst PREFERRED_NUMBERS = Object.freeze({\n  // \"Least rounded\" Renard number series, taken from Wikipedia page on preferred\n  // numbers: https://en.wikipedia.org/wiki/Preferred_number#Renard_numbers\n  R5: [10, 16, 25, 40, 63],\n  R10: [100, 125, 160, 200, 250, 315, 400, 500, 630, 800],\n  R20: [\n    100,\n    112,\n    125,\n    140,\n    160,\n    180,\n    200,\n    224,\n    250,\n    280,\n    315,\n    355,\n    400,\n    450,\n    500,\n    560,\n    630,\n    710,\n    800,\n    900\n  ],\n  R40: [\n    100,\n    106,\n    112,\n    118,\n    125,\n    132,\n    140,\n    150,\n    160,\n    170,\n    180,\n    190,\n    200,\n    212,\n    224,\n    236,\n    250,\n    265,\n    280,\n    300,\n    315,\n    355,\n    375,\n    400,\n    425,\n    450,\n    475,\n    500,\n    530,\n    560,\n    600,\n    630,\n    670,\n    710,\n    750,\n    800,\n    850,\n    900,\n    950\n  ],\n  R80: [\n    103,\n    109,\n    115,\n    122,\n    128,\n    136,\n    145,\n    155,\n    165,\n    175,\n    185,\n    195,\n    206,\n    218,\n    230,\n    243,\n    258,\n    272,\n    290,\n    307,\n    325,\n    345,\n    365,\n    387,\n    412,\n    437,\n    462,\n    487,\n    515,\n    545,\n    575,\n    615,\n    650,\n    690,\n    730,\n    775,\n    825,\n    875,\n    925,\n    975\n  ],\n  // https://en.wikipedia.org/wiki/Preferred_number#1-2-5_series\n  \"1-2-5\": [10, 20, 50],\n  // E series, taken from Wikipedia page on preferred numbers:\n  // https://en.wikipedia.org/wiki/Preferred_number#E_series\n  E6: [10, 15, 22, 33, 47, 68],\n  E12: [10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82],\n  E24: [\n    10,\n    11,\n    12,\n    13,\n    15,\n    16,\n    18,\n    20,\n    22,\n    24,\n    27,\n    30,\n    33,\n    36,\n    39,\n    43,\n    47,\n    51,\n    56,\n    62,\n    68,\n    75,\n    82,\n    91\n  ],\n  E48: [\n    100,\n    105,\n    110,\n    115,\n    121,\n    127,\n    133,\n    140,\n    147,\n    154,\n    162,\n    169,\n    178,\n    187,\n    196,\n    205,\n    215,\n    226,\n    237,\n    249,\n    261,\n    274,\n    287,\n    301,\n    316,\n    332,\n    348,\n    365,\n    383,\n    402,\n    422,\n    442,\n    464,\n    487,\n    511,\n    536,\n    562,\n    590,\n    619,\n    649,\n    681,\n    715,\n    750,\n    787,\n    825,\n    866,\n    909,\n    953\n  ],\n  E96: [\n    100,\n    102,\n    105,\n    107,\n    110,\n    113,\n    115,\n    118,\n    121,\n    124,\n    127,\n    130,\n    133,\n    137,\n    140,\n    143,\n    147,\n    150,\n    154,\n    158,\n    162,\n    165,\n    169,\n    174,\n    178,\n    182,\n    187,\n    191,\n    196,\n    200,\n    205,\n    210,\n    215,\n    221,\n    226,\n    232,\n    237,\n    243,\n    249,\n    255,\n    261,\n    267,\n    274,\n    280,\n    287,\n    294,\n    301,\n    309,\n    316,\n    324,\n    332,\n    340,\n    348,\n    357,\n    365,\n    374,\n    383,\n    392,\n    402,\n    412,\n    422,\n    432,\n    442,\n    453,\n    464,\n    475,\n    487,\n    499,\n    511,\n    523,\n    536,\n    549,\n    562,\n    576,\n    590,\n    604,\n    619,\n    634,\n    649,\n    665,\n    681,\n    698,\n    715,\n    732,\n    750,\n    768,\n    787,\n    806,\n    825,\n    845,\n    866,\n    887,\n    909,\n    931,\n    953,\n    976\n  ],\n  E192: [\n    100,\n    101,\n    102,\n    104,\n    105,\n    106,\n    107,\n    109,\n    110,\n    111,\n    113,\n    114,\n    115,\n    117,\n    118,\n    120,\n    121,\n    123,\n    124,\n    126,\n    127,\n    129,\n    130,\n    132,\n    133,\n    135,\n    137,\n    138,\n    140,\n    142,\n    143,\n    145,\n    147,\n    149,\n    150,\n    152,\n    154,\n    156,\n    158,\n    160,\n    162,\n    164,\n    165,\n    167,\n    169,\n    172,\n    174,\n    176,\n    178,\n    180,\n    182,\n    184,\n    187,\n    189,\n    191,\n    193,\n    196,\n    198,\n    200,\n    203,\n    205,\n    208,\n    210,\n    213,\n    215,\n    218,\n    221,\n    223,\n    226,\n    229,\n    232,\n    234,\n    237,\n    240,\n    243,\n    246,\n    249,\n    252,\n    255,\n    258,\n    261,\n    264,\n    267,\n    271,\n    274,\n    277,\n    280,\n    284,\n    287,\n    291,\n    294,\n    298,\n    301,\n    305,\n    309,\n    312,\n    316,\n    320,\n    324,\n    328,\n    332,\n    336,\n    340,\n    344,\n    348,\n    352,\n    357,\n    361,\n    365,\n    370,\n    374,\n    379,\n    383,\n    388,\n    392,\n    397,\n    402,\n    407,\n    412,\n    417,\n    422,\n    427,\n    432,\n    437,\n    442,\n    448,\n    453,\n    459,\n    464,\n    470,\n    475,\n    481,\n    487,\n    493,\n    499,\n    505,\n    511,\n    517,\n    523,\n    530,\n    536,\n    542,\n    549,\n    556,\n    562,\n    569,\n    576,\n    583,\n    590,\n    597,\n    604,\n    612,\n    619,\n    626,\n    634,\n    642,\n    649,\n    657,\n    665,\n    673,\n    681,\n    690,\n    698,\n    706,\n    715,\n    723,\n    732,\n    741,\n    750,\n    759,\n    768,\n    777,\n    787,\n    796,\n    806,\n    816,\n    825,\n    835,\n    845,\n    856,\n    866,\n    876,\n    887,\n    898,\n    909,\n    920,\n    931,\n    942,\n    953,\n    965,\n    976,\n    988\n  ]\n});\nconst roundUp = (n, granularity) => {\n  if (n == 0) return 0;\n  const series = PREFERRED_NUMBERS[granularity];\n  const first = series[0];\n  const last = series[series.length - 1];\n  let multiplier = 1;\n  while (n >= last * multiplier) {\n    multiplier *= 10;\n  }\n  let previousMin = 0;\n  while (n < first * multiplier) {\n    previousMin = first * multiplier;\n    multiplier /= 10;\n    if (n >= last * multiplier) {\n      return previousMin;\n    }\n  }\n  assert(\n    n >= first * multiplier && n < last * multiplier,\n    \"$bucketAuto: number out of range of series.\"\n  );\n  const i = findInsertIndex(series, n, (a, b) => {\n    b *= multiplier;\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  const seriesNumber = series[i] * multiplier;\n  return n == seriesNumber ? series[i + 1] * multiplier : seriesNumber;\n};\nfunction granularityPreferredSeries(sorted, bucketCount, granularity) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  let index = 0;\n  let nBuckets = 0;\n  let min = 0;\n  let max = 0;\n  return () => {\n    const isLastBucket = ++nBuckets == bucketCount;\n    const bucket = new Array();\n    min = index > 0 ? max : 0;\n    while (index < size && (isLastBucket || bucket.length < approxBucketSize)) {\n      bucket.push(sorted[index++][1]);\n    }\n    max = roundUp(sorted[index - 1][0], granularity);\n    const nItems = bucket.length;\n    while (index < size && (isLastBucket || sorted[index][0] < max)) {\n      bucket.push(sorted[index++][1]);\n    }\n    if (nItems != bucket.length) {\n      max = roundUp(sorted[index - 1][0], granularity);\n    }\n    assert(min < max, `$bucketAuto: ${min} < ${max}.`);\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nexport {\n  $bucketAuto\n};\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber, MingoError } from \"../../../util\";\nconst LEAP_YEAR_REF_POINT = -1e9;\nconst DAYS_PER_WEEK = 7;\nconst isLeapYear = (y) => (y & 3) == 0 && (y % 100 != 0 || y % 400 == 0);\nconst DAYS_IN_YEAR = [\n  365,\n  366\n  /*leap*/\n];\nconst daysInYear = (year) => DAYS_IN_YEAR[+isLeapYear(year)];\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInMonth = (d) => DAYS_IN_MONTH[d.getUTCMonth()] + Number(\n  d.getUTCMonth() === 1 && isLeapYear(d.getUTCFullYear())\n);\nconst YEAR_DAYS_OFFSET = [\n  [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]\n  /*leap*/\n];\nconst dayOfYear = (d) => YEAR_DAYS_OFFSET[+isLeapYear(d.getUTCFullYear())][d.getUTCMonth()] + d.getUTCDate();\nconst isoWeekday = (date, startOfWeek = \"sun\") => {\n  const dow = date.getUTCDay() || 7;\n  return (dow - ISO_WEEKDAY_MAP[startOfWeek] + DAYS_PER_WEEK) % DAYS_PER_WEEK;\n};\nconst p = (y) => (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400)) % 7;\nconst weeks = (y) => 52 + Number(p(y) == 4 || p(y - 1) == 3);\nfunction isoWeek(d) {\n  const dow = d.getUTCDay() || 7;\n  const w = Math.floor((10 + dayOfYear(d) - dow) / 7);\n  if (w < 1) return weeks(d.getUTCFullYear() - 1);\n  if (w > weeks(d.getUTCFullYear())) return 1;\n  return w;\n}\nfunction isoWeekYear(d) {\n  return d.getUTCFullYear() - Number(d.getUTCMonth() === 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);\n}\nconst MINUTES_PER_HOUR = 60;\nconst MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;\nconst TIMEUNIT_IN_MILLIS = {\n  week: MILLIS_PER_DAY * DAYS_PER_WEEK,\n  day: MILLIS_PER_DAY,\n  hour: 1e3 * 60 * 60,\n  minute: 1e3 * 60,\n  second: 1e3,\n  millisecond: 1\n};\nconst DAYS_OF_WEEK = [\n  \"monday\",\n  \"mon\",\n  \"tuesday\",\n  \"tue\",\n  \"wednesday\",\n  \"wed\",\n  \"thursday\",\n  \"thu\",\n  \"friday\",\n  \"fri\",\n  \"saturday\",\n  \"sat\",\n  \"sunday\",\n  \"sun\"\n];\nconst DAYS_OF_WEEK_SET = new Set(DAYS_OF_WEEK);\nconst ISO_WEEKDAY_MAP = Object.freeze({\n  mon: 1,\n  tue: 2,\n  wed: 3,\n  thu: 4,\n  fri: 5,\n  sat: 6,\n  sun: 7\n});\nconst DATE_FORMAT = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nconst DATE_PART_INTERVAL = [\n  [\"year\", 0, 9999],\n  [\"month\", 1, 12],\n  [\"day\", 1, 31],\n  [\"hour\", 0, 23],\n  [\"minute\", 0, 59],\n  [\"second\", 0, 59],\n  [\"millisecond\", 0, 999]\n];\nconst DATE_SYM_TABLE = Object.freeze({\n  \"%Y\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%G\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%m\": { name: \"month\", padding: 2, re: /(0[1-9]|1[012])/ },\n  \"%d\": { name: \"day\", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },\n  \"%H\": { name: \"hour\", padding: 2, re: /([01][0-9]|2[0-3])/ },\n  \"%M\": { name: \"minute\", padding: 2, re: /([0-5][0-9])/ },\n  \"%S\": { name: \"second\", padding: 2, re: /([0-5][0-9]|60)/ },\n  \"%L\": { name: \"millisecond\", padding: 3, re: /([0-9]{3})/ },\n  \"%u\": { name: \"weekday\", padding: 1, re: /([1-7])/ },\n  \"%U\": { name: \"week\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%V\": { name: \"isoWeek\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%z\": {\n    name: \"timezone\",\n    padding: 2,\n    re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/\n  },\n  \"%Z\": { name: \"minuteOffset\", padding: 3, re: /([+-][0-9]{3})/ }\n  // \"%%\": \"%\",\n});\nconst TIMEZONE_RE = /^[a-zA-Z_]+\\/[a-zA-Z_]+$/;\nfunction parseTimezone(tzstr) {\n  if (isNil(tzstr)) return 0;\n  if (TIMEZONE_RE.test(tzstr)) {\n    const date = /* @__PURE__ */ new Date();\n    const utcDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"UTC\" }));\n    const tzDate = new Date(date.toLocaleString(\"en-US\", { timeZone: tzstr }));\n    return (tzDate.getTime() - utcDate.getTime()) / 6e4;\n  }\n  const m = DATE_SYM_TABLE[\"%z\"].re.exec(tzstr);\n  if (!m) {\n    throw new MingoError(`Timezone '${tzstr}' is invalid or not supported`);\n  }\n  const hr = parseInt(m[2]) || 0;\n  const min = parseInt(m[3]) || 0;\n  return (Math.abs(hr * MINUTES_PER_HOUR) + min) * (hr < 0 ? -1 : 1);\n}\nfunction formatTimezone(minuteOffset) {\n  return (minuteOffset < 0 ? \"-\" : \"+\") + padDigits(Math.abs(Math.floor(minuteOffset / MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % MINUTES_PER_HOUR, 2);\n}\nfunction adjustDate(d, minuteOffset) {\n  d.setUTCMinutes(d.getUTCMinutes() + minuteOffset);\n}\nfunction computeDate(obj, expr, options) {\n  if (isDate(obj)) return obj;\n  const d = computeValue(obj, expr, null, options);\n  if (isDate(d)) return new Date(d);\n  if (isNumber(d)) return new Date(d * 1e3);\n  if (d.date) {\n    const date = isDate(d.date) ? new Date(d.date) : new Date(d.date * 1e3);\n    if (d.timezone) {\n      adjustDate(date, parseTimezone(d.timezone));\n    }\n    return date;\n  }\n  throw Error(`cannot convert ${JSON.stringify(expr)} to date`);\n}\nfunction padDigits(n, digits) {\n  return new Array(Math.max(digits - String(n).length + 1, 0)).join(\"0\") + n.toString();\n}\nconst leapYearsSinceReferencePoint = (year) => {\n  const yearsSinceReferencePoint = year - LEAP_YEAR_REF_POINT;\n  return Math.trunc(yearsSinceReferencePoint / 4) - Math.trunc(yearsSinceReferencePoint / 100) + Math.trunc(yearsSinceReferencePoint / 400);\n};\nfunction daysBetweenYears(startYear, endYear) {\n  return Math.trunc(\n    leapYearsSinceReferencePoint(endYear - 1) - leapYearsSinceReferencePoint(startYear - 1) + (endYear - startYear) * DAYS_IN_YEAR[0]\n  );\n}\nconst dateDiffYear = (start, end) => end.getUTCFullYear() - start.getUTCFullYear();\nconst dateDiffMonth = (start, end) => end.getUTCMonth() - start.getUTCMonth() + dateDiffYear(start, end) * 12;\nconst dateDiffQuarter = (start, end) => {\n  const a = Math.trunc(start.getUTCMonth() / 3);\n  const b = Math.trunc(end.getUTCMonth() / 3);\n  return b - a + dateDiffYear(start, end) * 4;\n};\nconst dateDiffDay = (start, end) => dayOfYear(end) - dayOfYear(start) + daysBetweenYears(start.getUTCFullYear(), end.getUTCFullYear());\nconst dateDiffWeek = (start, end, startOfWeek) => {\n  const wk = (startOfWeek || \"sun\").substring(0, 3);\n  return Math.trunc(\n    (dateDiffDay(start, end) + isoWeekday(start, wk) - isoWeekday(end, wk)) / DAYS_PER_WEEK\n  );\n};\nconst dateDiffHour = (start, end) => end.getUTCHours() - start.getUTCHours() + dateDiffDay(start, end) * 24;\nconst addMonth = (d, amount) => {\n  const m = d.getUTCMonth() + amount;\n  const yearOffset = Math.floor(m / 12);\n  if (m < 0) {\n    const month = m % 12 + 12;\n    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, month, d.getUTCDate());\n  } else {\n    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, m % 12, d.getUTCDate());\n  }\n};\nconst dateAdd = (date, unit, amount, _timezone) => {\n  const d = new Date(date);\n  switch (unit) {\n    case \"year\":\n      d.setUTCFullYear(d.getUTCFullYear() + amount);\n      break;\n    case \"quarter\":\n      addMonth(d, 3 * amount);\n      break;\n    case \"month\":\n      addMonth(d, amount);\n      break;\n    default:\n      d.setTime(d.getTime() + TIMEUNIT_IN_MILLIS[unit] * amount);\n  }\n  return d;\n};\nexport {\n  DATE_FORMAT,\n  DATE_PART_INTERVAL,\n  DATE_SYM_TABLE,\n  DAYS_OF_WEEK,\n  DAYS_OF_WEEK_SET,\n  DAYS_PER_WEEK,\n  LEAP_YEAR_REF_POINT,\n  MILLIS_PER_DAY,\n  MINUTES_PER_HOUR,\n  TIMEUNIT_IN_MILLIS,\n  adjustDate,\n  computeDate,\n  dateAdd,\n  dateDiffDay,\n  dateDiffHour,\n  dateDiffMonth,\n  dateDiffQuarter,\n  dateDiffWeek,\n  dateDiffYear,\n  dayOfYear,\n  daysBetweenYears,\n  daysInMonth,\n  daysInYear,\n  formatTimezone,\n  isLeapYear,\n  isoWeek,\n  isoWeekYear,\n  isoWeekday,\n  padDigits,\n  parseTimezone\n};\n","import { ComputeOptions } from \"../../core\";\nimport { concat, Lazy } from \"../../lazy\";\nimport { TIME_UNITS } from \"../../types\";\nimport {\n  assert,\n  isArray,\n  isDate,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  resolve,\n  ValueMap\n} from \"../../util\";\nimport { $dateAdd } from \"../expression/date/dateAdd\";\nimport { $sort } from \"./sort\";\nconst EMPTY_OBJECT = Object.freeze({});\nconst $densify = (collection, expr, options) => {\n  const { step, bounds, unit } = expr.range;\n  if (unit) {\n    assert(TIME_UNITS.includes(unit), \"\");\n    assert(\n      Number.isInteger(step) && step > 0,\n      \"The step parameter in a range statement must be a whole number when densifying a date range.\"\n    );\n  } else {\n    assert(\n      isNumber(step) && step > 0,\n      \"The step parameter in a range statement must be a strictly positive numeric value.\"\n    );\n  }\n  if (isArray(bounds)) {\n    assert(\n      !!bounds && bounds.length === 2,\n      \"A bounding array in a range statement must have exactly two elements.\"\n    );\n    assert(\n      (bounds.every(isNumber) || bounds.every(isDate)) && bounds[0] < bounds[1],\n      \"A bounding array must be an ascending array of either two dates or two numbers.\"\n    );\n    assert(\n      unit && !bounds.some(isNumber),\n      \"Numeric bounds may not have unit parameter.\"\n    );\n  }\n  if (expr.partitionByFields) {\n    assert(\n      isArray(expr.partitionByFields),\n      \"$densify: `partitionByFields` must be an array of strings\"\n    );\n  }\n  collection = $sort(collection, { [expr.field]: 1 }, options);\n  const nilOptions = ComputeOptions.init(options, null);\n  const computeNextValue = (value) => {\n    return isNumber(value) ? value + step : $dateAdd(\n      EMPTY_OBJECT,\n      { startDate: value, unit, amount: step },\n      nilOptions\n    );\n  };\n  const isValidUnit = !!unit && TIME_UNITS.includes(unit);\n  const getFieldValue = (o) => {\n    const v = resolve(o, expr.field);\n    if (isNil(v)) return v;\n    if (isNumber(v)) {\n      assert(\n        !isValidUnit,\n        \"$densify: Encountered non-date value in collection when step has a date unit.\"\n      );\n    } else if (isDate(v)) {\n      assert(\n        isValidUnit,\n        \"$densify: Encountered date value in collection when step does not have a date unit.\"\n      );\n    } else {\n      assert(false, \"$densify: Densify field type must be numeric or a date\");\n    }\n    return v;\n  };\n  const peekItem = new Array();\n  const nilFieldsIterator = Lazy(() => {\n    const item = collection.next();\n    const fieldValue = getFieldValue(item.value);\n    if (isNil(fieldValue)) return item;\n    peekItem.push(item);\n    return { done: true };\n  });\n  const nextDensifyValueMap = ValueMap.init(\n    options.hashFunction\n  );\n  const [lower, upper] = isArray(bounds) ? bounds : [bounds, bounds];\n  let maxFieldValue = void 0;\n  const updateMaxFieldValue = (value) => {\n    maxFieldValue = maxFieldValue === void 0 || maxFieldValue < value ? value : maxFieldValue;\n  };\n  const rootKey = [];\n  const densifyIterator = Lazy(() => {\n    const item = peekItem.length > 0 ? peekItem.pop() : collection.next();\n    if (item.done) return item;\n    let partitionKey = rootKey;\n    if (isArray(expr.partitionByFields)) {\n      partitionKey = expr.partitionByFields.map(\n        (k) => resolve(item.value, k)\n      );\n      assert(\n        partitionKey.every(isString),\n        \"$densify: Partition fields must evaluate to string values.\"\n      );\n    }\n    assert(isObject(item.value), \"$densify: collection must contain documents\");\n    const itemValue = getFieldValue(item.value);\n    if (!nextDensifyValueMap.has(partitionKey)) {\n      if (lower == \"full\") {\n        if (!nextDensifyValueMap.has(rootKey)) {\n          nextDensifyValueMap.set(rootKey, itemValue);\n        }\n        nextDensifyValueMap.set(partitionKey, nextDensifyValueMap.get(rootKey));\n      } else if (lower == \"partition\") {\n        nextDensifyValueMap.set(partitionKey, itemValue);\n      } else {\n        nextDensifyValueMap.set(partitionKey, lower);\n      }\n    }\n    const densifyValue = nextDensifyValueMap.get(partitionKey);\n    if (\n      // current item field value is lower than current densify value.\n      itemValue <= densifyValue || // range value equals or exceeds upper bound\n      upper != \"full\" && upper != \"partition\" && densifyValue >= upper\n    ) {\n      if (densifyValue <= itemValue) {\n        nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));\n      }\n      updateMaxFieldValue(itemValue);\n      return item;\n    }\n    nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));\n    updateMaxFieldValue(densifyValue);\n    const denseObj = { [expr.field]: densifyValue };\n    if (partitionKey) {\n      partitionKey.forEach((v, i) => {\n        denseObj[expr.partitionByFields[i]] = v;\n      });\n    }\n    peekItem.push(item);\n    return { done: false, value: denseObj };\n  });\n  if (lower !== \"full\") return concat(nilFieldsIterator, densifyIterator);\n  let paritionIndex = -1;\n  let partitionKeysSet = void 0;\n  const fullBoundsIterator = Lazy(() => {\n    if (paritionIndex === -1) {\n      const fullDensifyValue = nextDensifyValueMap.get(rootKey);\n      nextDensifyValueMap.delete(rootKey);\n      partitionKeysSet = Array.from(nextDensifyValueMap.keys());\n      if (partitionKeysSet.length === 0) {\n        partitionKeysSet.push(rootKey);\n        nextDensifyValueMap.set(rootKey, fullDensifyValue);\n      }\n      paritionIndex++;\n    }\n    do {\n      const partitionKey = partitionKeysSet[paritionIndex];\n      const partitionMaxValue = nextDensifyValueMap.get(partitionKey);\n      if (partitionMaxValue < maxFieldValue) {\n        nextDensifyValueMap.set(\n          partitionKey,\n          computeNextValue(partitionMaxValue)\n        );\n        const denseObj = { [expr.field]: partitionMaxValue };\n        partitionKey.forEach((v, i) => {\n          denseObj[expr.partitionByFields[i]] = v;\n        });\n        return { done: false, value: denseObj };\n      }\n      paritionIndex++;\n    } while (paritionIndex < partitionKeysSet.length);\n    return { done: true };\n  });\n  return concat(nilFieldsIterator, densifyIterator, fullBoundsIterator);\n};\nexport {\n  $densify\n};\n","import { $nin as __nin, createExpressionOperator } from \"../../_predicates\";\nconst $nin = createExpressionOperator(__nin);\nexport {\n  $nin\n};\n","import { isNumber } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { withMemo } from \"./_internal\";\nconst interpolate = (x1, y1, x2, y2, x) => y1 + (x - x1) * ((y2 - y1) / (x2 - x1));\nconst $linearFill = (_, collection, expr, options) => {\n  return withMemo(\n    collection,\n    expr,\n    () => {\n      const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n      const points = $push(\n        collection,\n        [sortKey, expr.inputExpr],\n        options\n      ).filter(([x, _2]) => isNumber(+x));\n      if (points.length !== collection.length) return null;\n      let lindex = -1;\n      let rindex = 0;\n      while (rindex < points.length) {\n        while (lindex + 1 < points.length && isNumber(points[lindex + 1][1])) {\n          lindex++;\n          rindex = lindex;\n        }\n        while (rindex + 1 < points.length && !isNumber(points[rindex + 1][1])) {\n          rindex++;\n        }\n        if (rindex + 1 >= points.length) break;\n        rindex++;\n        while (lindex + 1 < rindex) {\n          points[lindex + 1][1] = interpolate(\n            points[lindex][0],\n            points[lindex][1],\n            points[rindex][0],\n            points[rindex][1],\n            points[lindex + 1][0]\n          );\n          lindex++;\n        }\n        lindex = rindex;\n      }\n      return points.map(([_2, y]) => y);\n    },\n    (values) => values[expr.documentNumber - 1]\n  );\n};\nexport {\n  $linearFill\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil } from \"../../../util\";\nconst $slice = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const arr = args[0];\n  let skip = args[1];\n  let limit = args[2];\n  if (isNil(limit)) {\n    if (skip < 0) {\n      skip = Math.max(0, arr.length + skip);\n    } else {\n      limit = skip;\n      skip = 0;\n    }\n  } else {\n    if (skip < 0) {\n      skip = Math.max(0, arr.length + skip);\n    }\n    assert(\n      limit > 0,\n      `Invalid argument for $slice operator. Limit must be a positive number`\n    );\n    limit += skip;\n  }\n  return arr.slice(skip, limit);\n};\nexport {\n  $slice\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil, isNumber } from \"../../../util\";\nconst bitwise = (op, compute) => (obj, expr, options) => {\n  assert(isArray(expr), `${op}: expression must be an array.`);\n  const nums = computeValue(obj, expr, null, options);\n  if (nums.some(isNil)) return null;\n  assert(\n    nums.every(isNumber),\n    `${op}: expression must evalue to array of numbers.`\n  );\n  return compute(nums);\n};\nexport {\n  bitwise\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport {\n  adjustDate,\n  DATE_FORMAT,\n  DATE_SYM_TABLE,\n  MINUTES_PER_HOUR,\n  parseTimezone\n} from \"./_internal\";\nconst buildMap = (letters, sign) => {\n  const h = {};\n  letters.split(\"\").forEach((v, i) => h[v] = sign * (i + 1));\n  return h;\n};\nconst TZ_LETTER_OFFSETS = {\n  ...buildMap(\"ABCDEFGHIKLM\", 1),\n  ...buildMap(\"NOPQRSTUVWXY\", -1),\n  Z: 0\n};\nconst regexStrip = (s) => s.replace(/^\\//, \"\").replace(/\\/$/, \"\");\nconst REGEX_SPECIAL_CHARS = [\"^\", \".\", \"-\", \"*\", \"?\", \"$\"];\nconst regexQuote = (s) => {\n  REGEX_SPECIAL_CHARS.forEach((c) => {\n    s = s.replace(c, `\\\\${c}`);\n  });\n  return s;\n};\nconst $dateFromString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  args.format = args.format || DATE_FORMAT;\n  args.onNull = args.onNull || null;\n  let dateString = args.dateString;\n  if (isNil(dateString)) return args.onNull;\n  const separators = args.format.split(/%[YGmdHMSLuVzZ]/);\n  separators.reverse();\n  const matches = args.format.match(\n    /(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g\n  );\n  const dateParts = {};\n  let expectedPattern = \"\";\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    if (isObject(props)) {\n      const m2 = props.re.exec(dateString);\n      const delimiter = separators.pop() || \"\";\n      if (m2 !== null) {\n        dateParts[props.name] = /^\\d+$/.exec(m2[0]) ? parseInt(m2[0]) : m2[0];\n        dateString = dateString.substr(0, m2.index) + dateString.substr(m2.index + m2[0].length);\n        expectedPattern += regexQuote(delimiter) + regexStrip(props.re.toString());\n      } else {\n        dateParts[props.name] = null;\n      }\n    }\n  }\n  if (isNil(dateParts.year) || isNil(dateParts.month) || isNil(dateParts.day) || !new RegExp(\"^\" + expectedPattern + \"[A-Z]?$\").exec(args.dateString)) {\n    return args.onError;\n  }\n  const m = args.dateString.match(/([A-Z])$/);\n  assert(\n    // only one of in-date timeone or timezone argument but not both.\n    !(m && args.timezone),\n    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`\n  );\n  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * MINUTES_PER_HOUR : parseTimezone(args.timezone);\n  const d = new Date(\n    Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0)\n  );\n  if (!isNil(dateParts.hour)) d.setUTCHours(dateParts.hour);\n  if (!isNil(dateParts.minute)) d.setUTCMinutes(dateParts.minute);\n  if (!isNil(dateParts.second)) d.setUTCSeconds(dateParts.second);\n  if (!isNil(dateParts.millisecond))\n    d.setUTCMilliseconds(dateParts.millisecond);\n  adjustDate(d, -minuteOffset);\n  return d;\n};\nexport {\n  $dateFromString\n};\n","import { bitwise } from \"./_internal\";\nconst $bitAnd = bitwise(\n  \"$bitAnd\",\n  (nums) => nums.reduce((a, b) => a & b, -1)\n);\nexport {\n  $bitAnd\n};\n","import { bitwise } from \"./_internal\";\nconst $bitOr = bitwise(\n  \"$bitOr\",\n  (nums) => nums.reduce((a, b) => a | b, 0)\n);\nexport {\n  $bitOr\n};\n","import { bitwise } from \"./_internal\";\nconst $bitXor = bitwise(\n  \"$bitXor\",\n  (nums) => nums.reduce((a, b) => a ^ b, 0)\n);\nexport {\n  $bitXor\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNumber, isString } from \"../../../util\";\nconst UTF8_MASK = [192, 224, 240];\nfunction toUtf8(n) {\n  if (n < 128) return [n];\n  let count = n < 2048 && 1 || n < 65536 && 2 || 3;\n  const offset = UTF8_MASK[count - 1];\n  const utf8 = [(n >> 6 * count) + offset];\n  while (count > 0) utf8.push(128 | n >> 6 * --count & 63);\n  return utf8;\n}\nfunction utf8Encode(s) {\n  const buf = [];\n  for (let i = 0, len = s.length; i < len; i++) {\n    buf.push(toUtf8(s.codePointAt(i)));\n  }\n  return buf;\n}\nconst $substrBytes = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const s = args[0];\n  const index = args[1];\n  const count = args[2];\n  assert(\n    isString(s) && isNumber(index) && index >= 0 && isNumber(count) && count >= 0,\n    \"$substrBytes: invalid arguments\"\n  );\n  const buf = utf8Encode(s);\n  const validIndex = [];\n  let acc = 0;\n  for (let i = 0; i < buf.length; i++) {\n    validIndex.push(acc);\n    acc += buf[i].length;\n  }\n  const begin = validIndex.indexOf(index);\n  const end = validIndex.indexOf(index + count);\n  assert(\n    begin > -1 && end > -1,\n    \"$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.\"\n  );\n  return s.substring(begin, end);\n};\nexport {\n  $substrBytes\n};\n","import { computeValue } from \"../../../core\";\nimport { MingoError } from \"../../../util\";\nconst FIXED_POINTS = {\n  undefined: null,\n  null: null,\n  NaN: NaN,\n  Infinity: new Error(),\n  \"-Infinity\": new Error()\n};\nfunction createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {\n  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);\n  const keySet = new Set(Object.keys(fp));\n  return (obj, expr, options) => {\n    const n = computeValue(obj, expr, null, options);\n    if (keySet.has(`${n}`)) {\n      const res = fp[`${n}`];\n      if (res instanceof Error) {\n        throw new MingoError(\n          `cannot apply $${f.name} to -inf, value must in (-inf,inf)`\n        );\n      }\n      return res;\n    }\n    return f(n);\n  };\n}\nexport {\n  createTrignometryOperator\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $acos = createTrignometryOperator(Math.acos, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acos\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $acosh = createTrignometryOperator(Math.acosh, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acosh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $asin = createTrignometryOperator(Math.asin);\nexport {\n  $asin\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $asinh = createTrignometryOperator(Math.asinh, {\n  Infinity: Infinity,\n  \"-Infinity\": -Infinity\n});\nexport {\n  $asinh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $atan = createTrignometryOperator(Math.atan);\nexport {\n  $atan\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $atanh = createTrignometryOperator(Math.atanh, {\n  1: Infinity,\n  \"-1\": -Infinity\n});\nexport {\n  $atanh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $cos = createTrignometryOperator(Math.cos);\nexport {\n  $cos\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $cosh = createTrignometryOperator(Math.cosh, {\n  \"-Infinity\": Infinity,\n  Infinity: Infinity\n});\nexport {\n  $cosh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst RADIANS_FACTOR = Math.PI / 180;\nconst $degreesToRadians = createTrignometryOperator(\n  (n) => n * RADIANS_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": Infinity\n  }\n);\nexport {\n  $degreesToRadians\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst DEGREES_FACTOR = 180 / Math.PI;\nconst $radiansToDegrees = createTrignometryOperator(\n  (n) => n * DEGREES_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": -Infinity\n  }\n);\nexport {\n  $radiansToDegrees\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $sin = createTrignometryOperator(Math.sin);\nexport {\n  $sin\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $sinh = createTrignometryOperator(Math.sinh, {\n  \"-Infinity\": -Infinity,\n  Infinity: Infinity\n});\nexport {\n  $sinh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $tan = createTrignometryOperator(Math.tan);\nexport {\n  $tan\n};\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber, isString } from \"../../../util\";\nconst MAX_INT = 2147483647;\nconst MIN_INT = -2147483648;\nconst MAX_LONG = Number.MAX_SAFE_INTEGER;\nconst MIN_LONG = Number.MIN_SAFE_INTEGER;\nclass TypeConvertError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nfunction toInteger(obj, expr, options, min, max) {\n  const val = computeValue(obj, expr, null, options);\n  if (val === true) return 1;\n  if (val === false) return 0;\n  if (isNil(val)) return null;\n  if (isDate(val)) return val.getTime();\n  const n = Number(val);\n  if (isNumber(n) && n >= min && n <= max) {\n    if (!isString(val) || n.toString().indexOf(\".\") === -1) {\n      return Math.trunc(n);\n    }\n  }\n  throw new TypeConvertError(\n    `cannot convert '${val}' to ${max == MAX_INT ? \"int\" : \"long\"}`\n  );\n}\nexport {\n  MAX_INT,\n  MAX_LONG,\n  MIN_INT,\n  MIN_LONG,\n  TypeConvertError,\n  toInteger\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil, isString } from \"../../../util\";\nconst $toBool = (obj, expr, options) => {\n  const val = computeValue(obj, expr, null, options);\n  if (isNil(val)) return null;\n  if (isString(val)) return true;\n  return Boolean(val);\n};\nexport {\n  $toBool\n};\n","import { Query } from \"../../query\";\nimport { assert, isArray, resolve } from \"../../util\";\nconst $elemMatch = (obj, expr, field, options) => {\n  const arr = resolve(obj, field);\n  const query = new Query(expr, options);\n  assert(isArray(arr), \"$elemMatch: argument must resolve to array\");\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (query.test(arr[i])) {\n      if (options.useStrictMode) return [arr[i]];\n      result.push(arr[i]);\n    }\n  }\n  return result.length > 0 ? result : void 0;\n};\nexport {\n  $elemMatch\n};\n","import { isArray, resolve } from \"../../util\";\nimport { $slice as __slice } from \"../expression/array/slice\";\nconst $slice = (obj, expr, field, options) => {\n  const xs = resolve(obj, field);\n  const exprAsArray = expr;\n  if (!isArray(xs)) return xs;\n  return __slice(\n    obj,\n    isArray(expr) ? [xs, ...exprAsArray] : [xs, expr],\n    options\n  );\n};\nexport {\n  $slice\n};\n","import { $all as __all, createQueryOperator } from \"../../_predicates\";\nconst $all = createQueryOperator(__all);\nexport {\n  $all\n};\n","import {\n  $elemMatch as __elemMatch,\n  createQueryOperator\n} from \"../../_predicates\";\nconst $elemMatch = createQueryOperator(__elemMatch);\nexport {\n  $elemMatch\n};\n","import { $size as __size, createQueryOperator } from \"../../_predicates\";\nconst $size = createQueryOperator(__size);\nexport {\n  $size\n};\n","import { isArray } from \"../../../util\";\nimport { createQueryOperator } from \"../../_predicates\";\nconst createBitwiseOperator = (predicate) => {\n  return createQueryOperator(\n    (value, mask, _options) => {\n      let b = 0;\n      if (isArray(mask)) {\n        for (const n of mask) b = b | 1 << n;\n      } else {\n        b = mask;\n      }\n      return predicate(value & b, b);\n    }\n  );\n};\nexport {\n  createBitwiseOperator\n};\n","import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAllClear = createBitwiseOperator((result, _) => result == 0);\nexport {\n  $bitsAllClear\n};\n","import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAllSet = createBitwiseOperator(\n  (result, mask) => result == mask\n);\nexport {\n  $bitsAllSet\n};\n","import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAnyClear = createBitwiseOperator(\n  (result, mask) => result < mask\n);\nexport {\n  $bitsAnyClear\n};\n","import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAnySet = createBitwiseOperator((result, _) => result > 0);\nexport {\n  $bitsAnySet\n};\n","import { $eq as __eq, createQueryOperator } from \"../../_predicates\";\nconst $eq = createQueryOperator(__eq);\nexport {\n  $eq\n};\n","import { $gt as __gt, createQueryOperator } from \"../../_predicates\";\nconst $gt = createQueryOperator(__gt);\nexport {\n  $gt\n};\n","import { $gte as __gte, createQueryOperator } from \"../../_predicates\";\nconst $gte = createQueryOperator(__gte);\nexport {\n  $gte\n};\n","import { $in as __in, createQueryOperator } from \"../../_predicates\";\nconst $in = createQueryOperator(__in);\nexport {\n  $in\n};\n","import { $lt as __lt, createQueryOperator } from \"../../_predicates\";\nconst $lt = createQueryOperator(__lt);\nexport {\n  $lt\n};\n","import { $lte as __lte, createQueryOperator } from \"../../_predicates\";\nconst $lte = createQueryOperator(__lte);\nexport {\n  $lte\n};\n","import { $ne as __ne, createQueryOperator } from \"../../_predicates\";\nconst $ne = createQueryOperator(__ne);\nexport {\n  $ne\n};\n","import { $nin as __nin, createQueryOperator } from \"../../_predicates\";\nconst $nin = createQueryOperator(__nin);\nexport {\n  $nin\n};\n","import { isArray, resolve, resolveGraph } from \"../../../util\";\nconst $exists = (selector, value, _options) => {\n  const nested = selector.includes(\".\");\n  const b = !!value;\n  if (!nested || selector.match(/\\.\\d+$/)) {\n    return (o) => resolve(o, selector) !== void 0 === b;\n  }\n  return (o) => {\n    const path = resolveGraph(o, selector, { preserveIndex: true });\n    const val = resolve(path, selector.substring(0, selector.lastIndexOf(\".\")));\n    return isArray(val) ? val.some((v) => v !== void 0) === b : val !== void 0 === b;\n  };\n};\nexport {\n  $exists\n};\n","import { $type as __type, createQueryOperator } from \"../../_predicates\";\nconst $type = createQueryOperator(__type);\nexport {\n  $type\n};\n","import { computeValue } from \"../../../core\";\nfunction $expr(_, rhs, options) {\n  return (obj) => computeValue(obj, rhs, null, options);\n}\nexport {\n  $expr\n};\n","import { MingoError } from \"../../../util\";\nfunction $jsonSchema(_, schema, options) {\n  if (!options?.jsonSchemaValidator) {\n    throw new MingoError(\n      \"Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.\"\n    );\n  }\n  const validate = options?.jsonSchemaValidator(schema);\n  return (obj) => validate(obj);\n}\nexport {\n  $jsonSchema\n};\n","import { $mod as __mod, createQueryOperator } from \"../../_predicates\";\nconst $mod = createQueryOperator(__mod);\nexport {\n  $mod\n};\n","import { $regex as __regex, createQueryOperator } from \"../../_predicates\";\nconst $regex = createQueryOperator(__regex);\nexport {\n  $regex\n};\n","import { assert, isFunction, truthy } from \"../../../util\";\nfunction $where(_, rhs, options) {\n  assert(\n    options.scriptEnabled,\n    \"$where operator requires 'scriptEnabled' option to be true\"\n  );\n  const f = rhs;\n  assert(isFunction(f), \"$where only accepts a Function object\");\n  return (obj) => truthy(f.call(obj), options?.useStrictMode);\n}\nexport {\n  $where\n};\n","import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $and = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression: $and expects value to be an Array.\"\n  );\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.every((q) => q.test(obj));\n};\nexport {\n  $and\n};\n","import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $or = (_, rhs, options) => {\n  assert(isArray(rhs), \"Invalid expression. $or expects value to be an Array\");\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.some((q) => q.test(obj));\n};\nexport {\n  $or\n};\n","import { assert, isArray } from \"../../../util\";\nimport { $or } from \"./or\";\nconst $nor = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression. $nor expects value to be an array.\"\n  );\n  const f = $or(\"$or\", rhs, options);\n  return (obj) => !f(obj);\n};\nexport {\n  $nor\n};\n","import { Query } from \"../../../query\";\nimport { normalize } from \"../../../util\";\nconst $not = (selector, rhs, options) => {\n  const criteria = {};\n  criteria[selector] = normalize(rhs);\n  const query = new Query(criteria, options);\n  return (obj) => !query.test(obj);\n};\nexport {\n  $not\n};\n","import { useOperators } from \"../core\";\nimport * as booleanOperators from \"../operators/expression/boolean\";\nimport * as comparisonOperators from \"../operators/expression/comparison\";\nimport { $limit, $project, $skip, $sort } from \"../operators/pipeline\";\nimport * as projectionOperators from \"../operators/projection\";\nimport * as queryOperators from \"../operators/query\";\nuseOperators(\"expression\", {\n  ...booleanOperators,\n  ...comparisonOperators\n});\nuseOperators(\"pipeline\", {\n  $project,\n  $skip,\n  $limit,\n  $sort\n});\nuseOperators(\"projection\", projectionOperators);\nuseOperators(\"query\", queryOperators);\n","import { Context, initOptions } from \"../../core\";\nimport * as booleanOperators from \"../../operators/expression/boolean\";\nimport * as comparisonOperators from \"../../operators/expression/comparison\";\nimport * as queryOperators from \"../../operators/query\";\nimport { Query } from \"../../query\";\nimport {\n  assert,\n  cloneDeep,\n  isArray,\n  isDate,\n  isObject,\n  isRegExp,\n  resolve,\n  walk\n} from \"../../util\";\nconst UPDATE_OPTIONS = {\n  cloneMode: \"copy\",\n  queryOptions: initOptions({\n    context: Context.init().addQueryOps(queryOperators).addExpressionOps(booleanOperators).addExpressionOps(comparisonOperators)\n  })\n};\nconst clone = (mode, val) => {\n  switch (mode) {\n    case \"deep\":\n      return cloneDeep(val);\n    case \"copy\": {\n      if (isDate(val)) return new Date(val);\n      if (isArray(val)) return [...val];\n      if (isObject(val)) return { ...val };\n      if (isRegExp(val)) return new RegExp(val);\n      return val;\n    }\n    default:\n      return val;\n  }\n};\nconst FILTER_IDENT_RE = /^[a-z]+[a-zA-Z0-9]*$/;\nfunction tokenizePath(selector) {\n  if (!selector.includes(\".$\")) {\n    return [{ parent: selector, selector }, []];\n  }\n  const begin = selector.indexOf(\".$\");\n  const end = selector.indexOf(\"]\");\n  const parent = selector.substring(0, begin);\n  const child = selector.substring(begin + 3, end);\n  assert(\n    child === \"\" || FILTER_IDENT_RE.test(child),\n    \"The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters.\"\n  );\n  const rest = selector.substring(end + 2);\n  const [next, elems] = rest ? tokenizePath(rest) : [];\n  return [\n    { selector, parent, child: child || \"$\", next },\n    [child, ...elems || []].filter(Boolean)\n  ];\n}\nconst applyUpdate = (o, n, q, f, opts) => {\n  const { parent, child: c, next } = n;\n  if (!c) {\n    let b = false;\n    const g = (u, k) => b = Boolean(f(u, k)) || b;\n    walk(o, parent, g, opts);\n    return b;\n  }\n  const t = resolve(o, parent);\n  if (!isArray(t)) return false;\n  return t.map((e, i) => {\n    if (q[c] && !q[c].test({ [c]: e })) return false;\n    return next ? applyUpdate(e, next, q, f, opts) : f(t, i);\n  }).some(Boolean);\n};\nfunction walkExpression(expr, arrayFilter, options, callback) {\n  const res = [];\n  for (const [selector, val] of Object.entries(expr)) {\n    const [node, vars] = tokenizePath(selector);\n    if (!vars.length) {\n      if (callback(val, node, {})) res.push(node.parent);\n    } else {\n      const conditions = {};\n      arrayFilter.forEach((o) => {\n        Object.keys(o).forEach((k) => {\n          vars.forEach((w) => {\n            if (k === w || k.startsWith(w + \".\")) {\n              conditions[w] = conditions[w] || {};\n              Object.assign(conditions[w], { [k]: o[k] });\n            }\n          });\n        });\n      });\n      const queries = {};\n      for (const [k, condition] of Object.entries(conditions)) {\n        queries[k] = new Query(condition, options.queryOptions);\n      }\n      if (callback(val, node, queries)) res.push(node.parent);\n    }\n  }\n  return res;\n}\nexport {\n  UPDATE_OPTIONS,\n  applyUpdate,\n  clone,\n  tokenizePath,\n  walkExpression\n};\n","import { has, intersection, isObject, unique } from \"../../util\";\nimport {\n  applyUpdate,\n  clone,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $addToSet = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const args = { $each: [val] };\n    if (isObject(val) && has(val, \"$each\")) {\n      Object.assign(args, val);\n    }\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        const prev = o[k] ||= [];\n        const common = intersection([prev, args.$each]);\n        if (common.length === args.$each.length) return false;\n        o[k] = clone(options.cloneMode, unique(prev.concat(args.$each)));\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $addToSet\n};\n","import { assert, isNumber } from \"../../util\";\nimport {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst BIT_OPS = /* @__PURE__ */ new Set([\"and\", \"or\", \"xor\"]);\nconst $bit = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const op = Object.keys(val);\n    assert(\n      op.length === 1 && BIT_OPS.has(op[0]),\n      `Invalid bit operator '${op[0]}'. Must be one of 'and', 'or', or 'xor'.`\n    );\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        let n = o[k];\n        const v = val[op[0]];\n        if (n !== void 0 && !(isNumber(n) && isNumber(v))) return false;\n        n = n || 0;\n        switch (op[0]) {\n          case \"and\":\n            o[k] = n & v;\n            break;\n          case \"or\":\n            o[k] = n | v;\n            break;\n          case \"xor\":\n            o[k] = n ^ v;\n            break;\n        }\n        return o[k] !== n;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $bit\n};\n","import {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $currentDate = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  const now = Date.now();\n  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        o[k] = now;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $currentDate\n};\n","import { assert, isNumber, resolve } from \"../../util\";\nimport { applyUpdate, UPDATE_OPTIONS, walkExpression } from \"./_internal\";\nconst $inc = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    if (!node.child) {\n      const n = resolve(obj, node.parent);\n      assert(\n        n === void 0 || isNumber(n),\n        `cannot apply $inc to a value of non-numeric type`\n      );\n    }\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        o[k] = (o[k] ||= 0) + val;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $inc\n};\n","import { compare } from \"../../util\";\nimport {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $max = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        if (o[k] !== void 0 && compare(o[k], val) > -1) return false;\n        o[k] = val;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $max\n};\n","import { compare } from \"../../util\";\nimport {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $min = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        if (o[k] !== void 0 && compare(o[k], val) < 1) return false;\n        o[k] = val;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $min\n};\n","import {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $mul = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        const prev = o[k];\n        o[k] = o[k] === void 0 ? 0 : o[k] * val;\n        return o[k] !== prev;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $mul\n};\n","import { assert, isArray } from \"../../util\";\nimport {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $pop = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(obj, node, queries, (o, k) => {\n      const arr = o[k];\n      assert(\n        isArray(arr),\n        `path '${node.selector}' contains an element of non-array type.`\n      );\n      if (!arr.length) return false;\n      if (val === -1) {\n        arr.splice(0, 1);\n      } else {\n        arr.pop();\n      }\n      return true;\n    });\n  });\n};\nexport {\n  $pop\n};\n","import { Query } from \"../../query\";\nimport { isObject, isOperator } from \"../../util\";\nimport {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $pull = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const wrap = !isObject(val) || Object.keys(val).some(isOperator);\n    const query = new Query(\n      wrap ? { k: val } : val,\n      options.queryOptions\n    );\n    const pred = wrap ? (v) => query.test({ k: v }) : (v) => query.test(v);\n    return applyUpdate(obj, node, queries, (o, k) => {\n      const prev = o[k];\n      const curr = new Array();\n      const found = prev.map((v) => {\n        const b = pred(v);\n        if (!b) curr.push(v);\n        return b;\n      }).some(Boolean);\n      if (!found) return false;\n      o[k] = curr;\n      return true;\n    });\n  });\n};\nexport {\n  $pull\n};\n","import { UPDATE_OPTIONS } from \"./_internal\";\nimport { $pull } from \"./pull\";\nconst $pullAll = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  const pullExpr = {};\n  Object.entries(expr).forEach(([k, v]) => {\n    pullExpr[k] = { $in: v };\n  });\n  return $pull(obj, pullExpr, arrayFilters, options);\n};\nexport {\n  $pullAll\n};\n","import { compare, has, isEqual, isNumber, isObject, resolve } from \"../../util\";\nimport {\n  applyUpdate,\n  clone,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst OPERATOR_MODIFIERS = Object.freeze([\n  \"$each\",\n  \"$slice\",\n  \"$sort\",\n  \"$position\"\n]);\nconst $push = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const args = {\n      $each: [val]\n    };\n    if (isObject(val) && OPERATOR_MODIFIERS.some((m) => has(val, m))) {\n      Object.assign(args, val);\n    }\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        const arr = o[k] ||= [];\n        const prev = arr.slice(0, args.$slice || arr.length);\n        const oldsize = arr.length;\n        const pos = isNumber(args.$position) ? args.$position : arr.length;\n        arr.splice(pos, 0, ...clone(options.cloneMode, args.$each));\n        if (args.$sort) {\n          const sortKey = isObject(args.$sort) ? Object.keys(args.$sort || {}).pop() : \"\";\n          const order = !sortKey ? args.$sort : args.$sort[sortKey];\n          const f = !sortKey ? (a) => a : (a) => resolve(a, sortKey);\n          arr.sort((a, b) => order * compare(f(a), f(b)));\n        }\n        if (isNumber(args.$slice)) {\n          if (args.$slice < 0) arr.splice(0, arr.length + args.$slice);\n          else arr.splice(args.$slice);\n        }\n        return oldsize != arr.length || !isEqual(prev, arr);\n      },\n      { descendArray: true, buildGraph: true }\n    );\n  });\n};\nexport {\n  $push\n};\n","import { isEqual } from \"../../util\";\nimport {\n  applyUpdate,\n  clone,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nconst $set = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        if (isEqual(o[k], val)) return false;\n        o[k] = clone(options.cloneMode, val);\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $set\n};\n","import { has } from \"../../util\";\nimport {\n  applyUpdate,\n  UPDATE_OPTIONS,\n  walkExpression\n} from \"./_internal\";\nimport { $set } from \"./set\";\nconst $rename = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  const res = [];\n  const changed = walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(obj, node, queries, (o, k) => {\n      if (!has(o, k)) return false;\n      res.push(...$set(obj, { [val]: o[k] }, arrayFilters, options));\n      delete o[k];\n      return true;\n    });\n  });\n  return Array.from(new Set(changed.concat(res)));\n};\nexport {\n  $rename\n};\n","import { has, isArray } from \"../../util\";\nimport { applyUpdate, UPDATE_OPTIONS, walkExpression } from \"./_internal\";\nconst $unset = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {\n  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {\n    return applyUpdate(obj, node, queries, (o, k) => {\n      if (!has(o, k)) return false;\n      if (isArray(o)) {\n        o[k] = null;\n      } else {\n        delete o[k];\n      }\n      return true;\n    });\n  });\n};\nexport {\n  $unset\n};\n","import * as UPDATE_OPERATORS from \"./operators/update\";\nimport { UPDATE_OPTIONS } from \"./operators/update/_internal\";\nimport { Query } from \"./query\";\nimport { assert, has } from \"./util\";\nfunction createUpdater(defaultOptions) {\n  defaultOptions = defaultOptions ?? UPDATE_OPTIONS;\n  return (obj, expr, arrayFilters = [], condition = {}, options = defaultOptions) => {\n    const entry = Object.entries(expr);\n    assert(\n      entry.length === 1,\n      \"Update expression must contain only one operator.\"\n    );\n    const [op, args] = entry[0];\n    assert(\n      has(UPDATE_OPERATORS, op),\n      `Update operator '${op}' is not supported.`\n    );\n    const mutate = UPDATE_OPERATORS[op];\n    if (Object.keys(condition).length) {\n      const q = new Query(condition, options.queryOptions);\n      if (!q.test(obj)) return [];\n    }\n    return mutate(obj, args, arrayFilters, options);\n  };\n}\nconst update = createUpdater();\nconst updateObject = update;\nexport {\n  createUpdater,\n  update,\n  updateObject\n};\n"],"names":["MingoError","Error","MISSING","Symbol","CYCLE_FOUND_ERROR","Object","freeze","DEFAULT_HASH_FUNCTION","value","s","stringify","hash","i","length","charCodeAt","isPrimitive","v","isScalar","isDate","isRegExp","SORT_ORDER","undefined","null","number","string","symbol","object","array","arraybuffer","boolean","date","regexp","function","compare","a","b","u","map","n","typeOf","isEqual","_hashFn","WeakMap","_keyMap","_unpack","ValueMap","Map","constructor","super","_classPrivateFieldInitSpec","key","_classPrivateFieldGet","this","call","get","find","k","init","fn","m","_classPrivateFieldSet","clear","delete","masterKey","set","filter","_","has","keys","push","size","assert","condition","message","STRING_REP","reduce","memo","toUpperCase","substring","prototype","toString","name","toLowerCase","isBoolean","isString","isSymbol","isNumber","isNaN","isArray","Array","isObject","p","getPrototypeOf","isObjectLike","Date","RegExp","isFunction","isNil","truthy","arg","strict","isEmpty","x","ensureArray","obj","prop","hasOwnProperty","isTypedArray","ArrayBuffer","isView","cloneDeep","refs","ctor","Set","add","arr","isMissing","merge","target","input","intersection","hashFunction","vmaps","some","forEach","reverse","from","flatten","xs","depth","flatten2","ys","len","Math","max","getMembersOf","o","props","getOwnPropertyNames","hasCustomString","includes","is","aKeys","sort","bKeys","unique","JSON","toISOString","s2","join","hashCode","groupBy","collection","keyFn","lookup","result","existingKey","getValue","unwrap","resolve","selector","options","resolve2","path","field","isText","exec","subpath","slice","acc","item","res","split","unwrapArray","resolveGraph","sep","indexOf","next","hasNext","isIndex","test","preserveIndex","index","parseInt","value2","preserveMissing","preserveKeys","filterMissing","splice","NUMBER_RE","walk","names","buildGraph","isNextArrayIndex","descendArray","e","setValue","removeValue","elem","OPERATOR_NAME_PATTERN","isOperator","normalize","expr","$regex","$eq","newExpr","ProcessingMode","ProcessingMode2","_options","_root","_local","ComputeOptions","root","local","update","variables","assign","getOptions","context","Context","idKey","collation","processingMode","useStrictMode","scriptEnabled","useGlobalContext","collectionResolver","jsonSchemaValidator","initOptions","_operators","ctx","instance","addOperators","type","operators","entries","getOperator","ops","addAccumulatorOps","addExpressionOps","addQueryOps","addPipelineOps","addProjectionOps","addWindowOps","GLOBAL_CONTEXT","useOperators","currentFn","fallback","computeValue","operator","copts","computeOperator","computeExpression","SYSTEM_VARS","REDACT_ACTIONS","elems","val","callExpression","callAccumulator","$and","every","$not","booleanExpr","$or","$cmp","args","Lazy","source","Iterator","concat","iterators","done","isGenerator","Function","dropItem","rest","apply","DONE","createCallback","nextFn","iteratees","buffer","bufferIndex","storeResult","outer","innerDone","r","action","func","count","_iteratees","_yieldedValues","_getNext","nextVal","isDone","src","data","f","predicate","take","drop","transform","self","iter","each","initialValue","iterator","$limit","$project","validateExpression","createHandler","isRoot","expressionKeys","excludedKeys","includedKeys","handlers","subExpr","subExprKeys","projectFn","foundSlice","handlerKeys","idKeyExcluded","idKeyOnlyExcluded","newObj","idKeyImplicit","opts","pathObj","exclusions","inclusions","startsWith","endsWith","$skip","$sort","sortKeys","cmp","collationSpec","locale","collationComparator","coll","modifiers","groups","sortedKeys","COLLATION_STRENGTH","spec","localeOpt","sensitivity","strength","caseFirst","numeric","numericOrdering","ignorePunctuation","alternate","caseLevel","collator","Intl","Collator","OPERATORS","_source","_predicate","_projection","_result","_buffer","Cursor","projection","fetch","mode","CLONE_INPUT","op","CLONE_OUTPUT","fetchAll","buffered","all","skip","limit","modifier","pop","TOP_LEVEL_OPS","_compiled","_condition","Query","compile","whereOperator","processOperator","remove","createQueryOperator","lhs","createExpressionOperator","$ne","$in","$nin","$lt","y","mingoCmp","$lte","$gt","$gte","$mod","match","$all","values","queries","matched","query","$elemMatch","$size","isNonBooleanOperator","format","criteria","temp","isNull","compareFuncs","bool","int","long","double","decimal","regex","compareType","$type","findIndex","t","__eq","__gt","__gte","__lt","__lte","__ne","R5","R10","R20","R40","R80","E6","E12","E24","E48","E96","E192","DAYS_OF_WEEK","mon","tue","wed","thu","fri","sat","sun","padding","re","__nin","$slice","bitwise","compute","nums","buildMap","letters","sign","h","FIXED_POINTS","NaN","Infinity","createTrignometryOperator","fixedPoints","fp","keySet","acos","acosh","asin","asinh","atan","atanh","cos","cosh","RADIANS_FACTOR","PI","DEGREES_FACTOR","sin","sinh","tan","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","exprAsArray","__slice","__all","__elemMatch","__size","createBitwiseOperator","mask","$bitsAllClear","$bitsAllSet","$bitsAnyClear","$bitsAnySet","__in","$exists","nested","lastIndexOf","__type","$expr","rhs","$jsonSchema","schema","validate","__mod","__regex","$where","q","$nor","booleanOperators","comparisonOperators","projectionOperators","queryOperators","UPDATE_OPTIONS","cloneMode","queryOptions","clone","FILTER_IDENT_RE","tokenizePath","parent","begin","end","child","Boolean","applyUpdate","c","g","walkExpression","arrayFilter","callback","node","vars","conditions","w","$addToSet","arrayFilters","$each","prev","common","BIT_OPS","$bit","$currentDate","now","$inc","$max","$min","$mul","$pop","$pull","wrap","pred","curr","found","$pullAll","pullExpr","OPERATOR_MODIFIERS","$push","oldsize","pos","$position","sortKey","order","$set","$rename","changed","$unset","createUpdater","defaultOptions","entry","UPDATE_OPERATORS","mutate"],"sourceRoot":""}