{"version":3,"file":"js/385.28cd78c5.js","mappings":"uUAEA,SAASA,EAAWC,GAChB,OAAIC,EAAcD,GACPA,EAAQE,MAGRF,EAAQG,IAEvB,CAEA,SAASF,EAAcG,GACnB,OAAO,EAAAC,EAAA,GAASD,EAAIF,QAAwB,KAAdE,EAAIF,KACtC,CACO,MAAMI,EACT,cAAIC,GACA,OAAOC,KAAKC,WAChB,CACA,cAAIF,CAAWG,GACXF,KAAKC,YAAcC,CACvB,CACA,WAAAC,CAAYF,GACRD,KAAKC,YAAcA,CACvB,CACA,MAAAG,CAAOC,GACHA,EAAQC,MAAMN,OACd,EAAAO,EAAA,GAAQP,KAAKD,YAAaS,IACtBA,EAAKJ,OAAOC,EAAQ,GAE5B,EAEG,MAAM,UAAoBP,EAC7B,WAAAK,CAAYM,GACRC,MAAM,IACNV,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,CACA,cAAId,CAAWA,GAEf,CACA,cAAIA,GACA,YAA4Be,IAAxBd,KAAKe,eACEf,KAAKe,eAAehB,WAExB,EACX,CACA,MAAAK,CAAOC,GACHA,EAAQC,MAAMN,KAElB,EAEG,MAAMgB,UAAalB,EACtB,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKiB,QAAU,IACf,OAAOjB,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMK,UAAoBpB,EAC7B,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKmB,mBAAoB,GACzB,OAAOnB,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMO,UAAetB,EACxB,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMQ,UAA4BvB,EACrC,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMS,UAAyCxB,EAClD,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMU,UAAmBzB,EAC5B,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMW,UAAgC1B,EACzC,WAAAK,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMY,UAAoB3B,EAC7B,cAAIC,GACA,OAAOC,KAAKC,WAChB,CACA,cAAIF,CAAWG,GACXF,KAAKC,YAAcC,CACvB,CACA,WAAAC,CAAYM,GACRC,MAAMD,EAAQV,YACdC,KAAKW,IAAM,EACXX,KAAKmB,mBAAoB,EACzBnB,KAAK0B,eAAgB,GACrB,OAAO1B,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,EAEG,MAAMc,EACT,WAAAxB,CAAYM,GACRT,KAAKW,IAAM,GACX,OAAOX,MAAM,EAAAY,EAAA,GAAOH,GAAUI,QAAYC,IAAND,IACxC,CACA,MAAAT,CAAOC,GACHA,EAAQC,MAAMN,KAClB,EAEG,SAAS4B,EAAiBC,GAC7B,OAAO,OAAIA,EAAUC,EACzB,CACO,SAASA,EAAoBC,GAChC,SAASC,EAAkBjC,GACvB,OAAO,OAAIA,EAAY+B,EAC3B,CAEA,GAAIC,aAAgB,EAAa,CAC7B,MAAME,EAAwB,CAC1BC,KAAM,cACNvC,KAAMoC,EAAKI,gBACXxB,IAAKoB,EAAKpB,KAKd,OAHI,EAAAd,EAAA,GAASkC,EAAKK,SACdH,EAAsBG,MAAQL,EAAKK,OAEhCH,CACX,CACK,GAAIF,aAAgBb,EACrB,MAAO,CACHgB,KAAM,cACNnC,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBX,EACrB,MAAO,CACHc,KAAM,SACNvB,IAAKoB,EAAKpB,IACVZ,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBV,EACrB,MAAO,CACHa,KAAM,sBACNvB,IAAKoB,EAAKpB,IACVZ,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBT,EACrB,MAAO,CACHY,KAAM,mCACNvB,IAAKoB,EAAKpB,IACV0B,UAAYP,EAAoB,IAAIH,EAAS,CAAEW,aAAcP,EAAKM,aAClEtC,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBP,EACrB,MAAO,CACHU,KAAM,0BACNvB,IAAKoB,EAAKpB,IACV0B,UAAYP,EAAoB,IAAIH,EAAS,CAAEW,aAAcP,EAAKM,aAClEtC,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBR,EACrB,MAAO,CACHW,KAAM,aACNvB,IAAKoB,EAAKpB,IACVZ,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBN,EACrB,MAAO,CACHS,KAAM,cACNvB,IAAKoB,EAAKpB,IACVZ,WAAYiC,EAAkBD,EAAKhC,aAGtC,GAAIgC,aAAgBJ,EAAU,CAC/B,MAAMY,EAAqB,CACvBL,KAAM,WACNvC,KAAMoC,EAAKO,aAAa3C,KACxByC,MAAO7C,EAAWwC,EAAKO,cACvB3B,IAAKoB,EAAKpB,MAEV,EAAAd,EAAA,GAASkC,EAAKK,SACdG,EAAmBC,cAAgBT,EAAKK,OAE5C,MAAMK,EAAUV,EAAKO,aAAaI,QAMlC,OALIX,EAAKO,aAAaI,UAClBH,EAAmBE,SAAU,EAAAE,EAAA,GAASF,GAChCA,EAAQG,OACRH,GAEHF,CACX,CACK,GAAIR,aAAgBf,EACrB,MAAO,CACHkB,KAAM,OACNvC,KAAMoC,EAAKpC,KACXsB,QAASc,EAAKd,QACdlB,WAAYiC,EAAkBD,EAAKhC,aAKvC,MAAM8C,MAAM,uBAEpB,CC9NO,MAAM,EACT,KAAAvC,CAAMyB,GACF,MAAMe,EAAUf,EAChB,OAAQe,EAAQ3C,aACZ,KAAK,EACD,OAAOH,KAAK+C,iBAAiBD,GACjC,KAAK5B,EACD,OAAOlB,KAAKgD,iBAAiBF,GACjC,KAAK1B,EACD,OAAOpB,KAAKiD,YAAYH,GAC5B,KAAKzB,EACD,OAAOrB,KAAKkD,yBAAyBJ,GACzC,KAAKxB,EACD,OAAOtB,KAAKmD,sCAAsCL,GACtD,KAAKtB,EACD,OAAOxB,KAAKoD,6BAA6BN,GAC7C,KAAKvB,EACD,OAAOvB,KAAKqD,gBAAgBP,GAChC,KAAKrB,EACD,OAAOzB,KAAKsD,iBAAiBR,GACjC,KAAKnB,EACD,OAAO3B,KAAKuD,cAAcT,GAC9B,KAAK9B,EACD,OAAOhB,KAAKwD,UAAUV,GAE1B,QACI,MAAMD,MAAM,wBAExB,CAEA,gBAAAE,CAAiBhB,GAAQ,CAEzB,gBAAAiB,CAAiBjB,GAAQ,CAEzB,WAAAkB,CAAYlB,GAAQ,CAEpB,eAAAsB,CAAgBtB,GAAQ,CAExB,wBAAAmB,CAAyBnB,GAAQ,CAEjC,qCAAAoB,CAAsCpB,GAAQ,CAE9C,4BAAAqB,CAA6BrB,GAAQ,CAErC,gBAAAuB,CAAiBvB,GAAQ,CAEzB,aAAAwB,CAAcxB,GAAQ,CAEtB,SAAAyB,CAAUzB,GAAQ,E,kCC/Cf,SAAS0B,EAAejD,GAC3B,OAAQA,aAAgBU,GACpBV,aAAgBY,GAChBZ,aAAgBe,GAChBf,aAAgBa,GAChBb,aAAgBc,GAChBd,aAAgBgB,GAChBhB,aAAgBmB,GAChBnB,aAAgBQ,CACxB,CACO,SAAS0C,EAAelD,EAAMmD,EAAiB,IAClD,MAAMC,EAAqBpD,aAAgBY,GACvCZ,aAAgBe,GAChBf,aAAgBgB,EACpB,QAAIoC,IAMApD,aAAgBiB,GAET,OAAKjB,EAAKT,YAAa8D,GACnBH,EAAeG,EAASF,OAG9BnD,aAAgB,IAAe,EAAAsD,EAAA,GAASH,EAAgBnD,MAIxDA,aAAgBV,IACjBU,aAAgB,GAChBmD,EAAeI,KAAKvD,IAEjB,EAAAwD,EAAA,GAAMxD,EAAKT,YAAa8D,GACpBH,EAAeG,EAASF,OAM3C,CACO,SAASM,EAAgBzD,GAC5B,OAAOA,aAAgBiB,CAC3B,CACO,SAASyC,EAAqB1D,GAEjC,GAAIA,aAAgB,EAChB,MAAO,UAEN,GAAIA,aAAgBY,EACrB,MAAO,SAEN,GAAIZ,aAAgBiB,EACrB,MAAO,KAEN,GAAIjB,aAAgBa,EACrB,MAAO,eAEN,GAAIb,aAAgBc,EACrB,MAAO,mBAEN,GAAId,aAAgBgB,EACrB,MAAO,WAEN,GAAIhB,aAAgBe,EACrB,MAAO,OAEN,GAAIf,aAAgBmB,EACrB,MAAO,UAIP,MAAMkB,MAAM,uBAEpB,CCxEO,MAAMsB,EACT,IAAAC,CAAK5D,EAAM6D,EAAW,KAClB,EAAA9D,EAAA,GAAQC,EAAKT,YAAY,CAAC8D,EAASS,KAC/B,MAAMC,GAAW,EAAAC,EAAA,GAAKhE,EAAKT,WAAYuE,EAAQ,GAE/C,GAAIT,aAAmB,EACnB7D,KAAKyE,YAAYZ,EAASU,EAAUF,QAEnC,GAAIR,aAAmBlC,EACxB3B,KAAK0E,aAAab,EAASU,EAAUF,QAEpC,GAAIR,aAAmB3C,EACxBlB,KAAK2E,SAASd,EAASU,EAAUF,QAEhC,GAAIR,aAAmBzC,EACxBpB,KAAK4E,WAAWf,EAASU,EAAUF,QAElC,GAAIR,aAAmBxC,EACxBrB,KAAK6E,eAAehB,EAASU,EAAUF,QAEtC,GAAIR,aAAmBvC,EACxBtB,KAAK8E,kBAAkBjB,EAASU,EAAUF,QAEzC,GAAIR,aAAmBrC,EACxBxB,KAAK+E,YAAYlB,EAASU,EAAUF,QAEnC,GAAIR,aAAmBtC,EACxBvB,KAAKgF,SAASnB,EAASU,EAAUF,OAEhC,MAAIR,aAAmBpC,GAIxB,MAAMoB,MAAM,wBAHZ7C,KAAKiF,OAAOpB,EAASU,EAAUF,EAInC,IAER,CACA,YAAAK,CAAaQ,EAAUX,EAAUF,GAAY,CAC7C,WAAAI,CAAYU,EAASZ,EAAUF,GAAY,CAC3C,QAAAM,CAASS,EAAUb,EAAUF,GAEzB,MAAMgB,EAAad,EAASe,OAAOjB,GACnCrE,KAAKoE,KAAKgB,EAAUC,EACxB,CACA,UAAAT,CAAWW,EAAYhB,EAAUF,GAE7B,MAAMgB,EAAad,EAASe,OAAOjB,GACnCrE,KAAKoE,KAAKmB,EAAYF,EAC1B,CACA,cAAAR,CAAeW,EAAgBjB,EAAUF,GAErC,MAAMoB,EAAqB,CACvB,IAAIrE,EAAO,CAAErB,WAAYyF,EAAezF,cAC1CuF,OAAOf,EAAUF,GACnBrE,KAAKoE,KAAKoB,EAAgBC,EAC9B,CACA,iBAAAX,CAAkBY,EAAmBnB,EAAUF,GAE3C,MAAMsB,EAAwBC,EAA+BF,EAAmBnB,EAAUF,GAC1FrE,KAAKoE,KAAKsB,EAAmBC,EACjC,CACA,QAAAX,CAASa,EAAUtB,EAAUF,GAEzB,MAAMyB,EAAe,CACjB,IAAI1E,EAAO,CAAErB,WAAY8F,EAAS9F,cACpCuF,OAAOf,EAAUF,GACnBrE,KAAKoE,KAAKyB,EAAUC,EACxB,CACA,WAAAf,CAAYgB,EAAaxB,EAAUF,GAE/B,MAAM2B,EAAkBJ,EAA+BG,EAAaxB,EAAUF,GAC9ErE,KAAKoE,KAAK2B,EAAaC,EAC3B,CACA,MAAAf,CAAOgB,EAAQ1B,EAAUF,GAErB,MAAMgB,EAAad,EAASe,OAAOjB,IAEnC,EAAA9D,EAAA,GAAQ0F,EAAOlG,YAAamG,IAIxB,MAAMC,EAAc,IAAIjF,EAAY,CAAEnB,WAAY,CAACmG,KACnDlG,KAAKoE,KAAK+B,EAAad,EAAW,GAE1C,EAEJ,SAASO,EAA+BQ,EAAY7B,EAAUF,GAC1D,MAAMgC,EAAa,CACf,IAAIjF,EAAO,CACPrB,WAAY,CACR,IAAI4B,EAAS,CAAEW,aAAc8D,EAAW/D,aAC1CiD,OAAOc,EAAWrG,eAGtBuG,EAAiBD,EAAWf,OAAOf,EAAUF,GACnD,OAAOiC,CACX,C,sBCnGO,SAASC,EAAM/F,GAElB,GAAIA,aAAgB,EAShB,OAAO+F,EAAM/F,EAAKO,gBAEjB,GAAIP,aAAgBmB,EACrB,OAAO6E,EAAiBhG,GAEvB,GAAIiD,EAAejD,GACpB,OAAOiG,EAAiBjG,GAEvB,GAAIyD,EAAgBzD,GACrB,OAAOkG,EAAkBlG,GAGzB,MAAMqC,MAAM,uBAEpB,CACO,SAAS4D,EAAiBjG,GAC7B,IAAImG,EAAW,GACf,MAAMC,EAAMpG,EAAKT,WACjB,IAEI8G,EAFAC,EAAiB,EACjBC,EAAyBH,EAAII,OAASF,EAGtCG,GAA0B,EAE9B,MAAOF,GAA0BE,EAC7BJ,EAAcD,EAAIE,GAClBG,EAA0BvD,EAAemD,GACzCF,EAAWA,EAASrB,OAAOiB,EAAMM,IACjCC,GAAkC,EAClCC,EAAyBH,EAAII,OAASF,EAE1C,OAAO,EAAAI,EAAA,GAAKP,EAChB,CACO,SAASD,EAAkBlG,GAC9B,MAAM2G,GAAwB,OAAI3G,EAAKT,YAAaqH,GACzCb,EAAMa,KAEjB,OAAO,EAAAF,EAAA,IAAK,OAAQC,GACxB,CACO,SAASX,EAAiBtB,GAC7B,MAAO,CAACA,EAAS5C,aACrB,CCrDO,MAAM,EAAK,SCMX,MAAM+E,UAA4BlD,EACrC,WAAAhE,CAAYmH,GACR5G,QACAV,KAAKsH,QAAUA,EACftH,KAAKuH,QAAU,CAAC,CACpB,CACA,YAAAC,GAEI,OADAxH,KAAKoE,KAAKpE,KAAKsH,SACRtH,KAAKuH,OAChB,CACA,YAAA7C,CAAaQ,EAAUX,EAAUF,GAEjC,CACA,WAAAI,CAAYU,EAASZ,EAAUF,GAC3B,MAAMoD,EAAaC,EAA8BvC,EAAQpE,eAAgBoE,EAAQxE,KAC7EX,KAAKsH,QAAQ3H,KACXgI,EAAWpD,EAASe,OAAOjB,GAC3BuD,EAAW,IAAI1G,EAAY,CAAEnB,WAAY4H,IACzCE,EAAuBtB,EAAMqB,GACnC5H,KAAKuH,QAAQE,GAAcI,CAC/B,EAEG,SAASC,EAAuBC,GACnC,MAAMC,EAAgB,CAAC,EAKvB,OAJA,EAAAzH,EAAA,GAAQwH,GAAiBT,IACrB,MAAMW,EAAiB,IAAIZ,EAAoBC,GAASE,gBACxD,OAAOQ,EAAeC,EAAe,IAElCD,CACX,CACO,SAASN,EAA8BQ,EAAOC,GACjD,OAAOD,EAAMvI,KAAOwI,EAAoB,CAC5C,C,kCCpCO,MAAMC,EAA6B,CACtC,yBAAAC,EAA0B,SAAEC,EAAQ,OAAEC,EAAM,SAAEC,EAAQ,SAAEC,IACpD,MAAMC,GAAW,OAAcJ,GACzBK,EAAcD,EACd,WAAO,QAAWJ,SAClB,wBAAqBA,EAAS3I,WAC9BiJ,EAAM,aAAaD,uBAA8BJ,EAAOM,aAC9D,OAAOD,CACX,EACA,6BAAAE,EAA8B,eAAEC,EAAc,SAAEN,IAC5C,MAAO,6CAA+CM,EAAeF,KACzE,EACA,uBAAAG,EAAwB,oBAAEC,EAAmB,OAAEV,EAAM,SAAEC,EAAQ,sBAAEU,EAAqB,SAAET,IACpF,MAAMU,EAAY,cAEZC,GAAa,OAAMb,GAAQM,MAC3BQ,EAAY,iBAAmBD,EAAa,IAClD,GAAIF,EACA,OAAOC,EAAYD,EAAwBG,EAE1C,CACD,MAAMC,GAAoB,EAAAC,EAAA,GAAON,GAAqB,CAACO,EAAQC,IAAiBD,EAAOlE,OAAOmE,IAAe,IACvGC,GAA0B,OAAIJ,GAAoBK,GAAa,KAAI,OAAIA,GAAWC,IAAkB,QAAWA,KAAgBC,KAAK,WACpIC,GAAyB,OAAIJ,GAAyB,CAACK,EAASpJ,IAAQ,KAAKA,EAAM,MAAMoJ,MACzFC,EAAwB,2CAA2CF,EAAuBD,KAAK,QACrG,OAAOV,EAAYa,EAAwBX,CAC/C,CACJ,EACA,qBAAAY,EAAsB,uBAAEC,EAAsB,OAAE3B,EAAM,sBAAEW,EAAqB,SAAET,IAC3E,MAAMU,EAAY,cAEZC,GAAa,OAAMb,GAAQM,MAC3BQ,EAAY,iBAAmBD,EAAa,IAClD,GAAIF,EACA,OAAOC,EAAYD,EAAwBG,EAE1C,CACD,MAAMK,GAA0B,OAAIQ,GAAyBP,GAAa,KAAI,OAAIA,GAAWC,IAAkB,QAAWA,KAAgBC,KAAK,UACzIG,EACF,kGAAIN,EAAwBG,KAAK,SACrC,OAAOV,EAAYa,EAAwBX,CAC/C,CACJ,GAEJc,OAAOC,OAAOhC,GACP,MAAMiC,GAAsC,CAC/C,sBAAAC,CAAuBC,EAAcC,GACjC,MAAM5B,EAAM,gEACR4B,EAAcrI,gBADN,gCAIRoI,EAAa5K,KACb,KACJ,OAAOiJ,CACX,GAES6B,GAAuC,CAChD,wBAAAC,CAAyBH,EAAcI,GACnC,SAASC,EAA2BpK,GAChC,OAAIA,aAAgBmB,EACTnB,EAAK8B,aAAa3C,KAEpBa,aAAgB,EACdA,EAAK2B,gBAGL,EAEf,CACA,MAAM0I,EAAeN,EAAa5K,KAC5BmL,GAAgB,OAAMH,GACtBrG,EAAQwG,EAAcnK,IACtBoK,EAAU7G,EAAqB4G,GAC/BE,EAAgBJ,EAA2BE,GAC3CG,EAAmB3G,EAAQ,EACjC,IAAIsE,EAAM,KAAKmC,IAAUE,EAAmB3G,EAAQ,QAAQ0G,EAAgB,oBAAoBA,MAAoB,iDAChFL,EAAe3D,0CAA0C6D,iJAM7F,OAFAjC,EAAMA,EAAIsC,QAAQ,UAAW,KAC7BtC,EAAMA,EAAIsC,QAAQ,SAAU,MACrBtC,CACX,EACA,2BAAAuC,CAA4BC,GACxB,MAAMC,EACF,iHAA2ED,EAAKzL,mPAIpF,OAAO0L,CACX,EACA,oCAAAC,CAAqC7K,GACjC,MAAM8K,GAAU,OAAI9K,EAAQ+K,YAAaC,IAAY,QAAWA,KAAU5B,KAAK,MACzE6B,EAAyC,IAA5BjL,EAAQkL,YAAYhL,IAAY,GAAKF,EAAQkL,YAAYhL,IACtE0K,EAAS,4BAA4B5K,EAAQmL,iBAAiB/B,KAAK,gDAC5D6B,cAAuBjL,EAAQ8J,aAAa5K,iBACjD4L,sKAGR,OAAOF,CACX,EACA,8BAAAQ,CAA+BpL,GAC3B,MAAM8K,GAAU,OAAI9K,EAAQ+K,YAAaM,IAAY,QAAWA,KAAUjC,KAAK,MACzE6B,EAAyC,IAA5BjL,EAAQkL,YAAYhL,IAAY,GAAKF,EAAQkL,YAAYhL,IAC5E,IAAIoL,EAAc,qCAAqCtL,EAAQmL,iBAAiB/B,KAAK,gBAAgB6B,cACrFjL,EAAQ8J,aAAa5K,iBAC7B4L,+DAKR,OAJAQ,GACIA,mHAGGA,CACX,EACA,yBAAAC,CAA0BvL,GACtB,IAAIsK,EAAU7G,EAAqBzD,EAAQwL,YACZ,IAA3BxL,EAAQwL,WAAWtL,MACnBoK,GAAWtK,EAAQwL,WAAWtL,KAElC,MAAM0K,EAAS,mBAAmBN,mBAAyBtK,EAAQ8J,aAAa5K,4EAEhF,OAAO0L,CACX,EAGA,mBAAAa,CAAoBzL,GAEhB,MAAO,YACX,EACA,0BAAA0L,CAA2B1L,GACvB,MAAM4K,EAAS,iCAAiC5K,EAAQ2L,eAAiB,YAC3D3L,EAAQkL,YAAYhL,gBAAgBF,EAAQ8J,aAAa5K,sEAEvE,OAAO0L,CACX,EACA,6BAAAgB,CAA8B5L,GAC1B,MAAM4K,EACF,8DAAM5K,EAAQkL,YAAYhL,gBAAgBF,EAAQ8J,aAAa5K,qBAAqBc,EAAQkL,YAAY5L,WAAWiH,OAAS,kBAChI,OAAOqE,CACX,EACA,uBAAAiB,CAAwB7L,GACpB,MAAMgI,EAAWhI,EAAQ8J,aAAa5K,KAChC4M,GAAY,OAAI9L,EAAQ+L,mBAAoBC,GAAaA,EAAS9M,OAClE+M,EAAoB,GAAGjE,YAAgB8D,EACxCjH,OAAO,CAACmD,IACRoB,KAAK,cACJwB,EACF,4CAAU5C,kIACgEiE,oIAG9E,OAAOrB,CACX,EAGA,yBAAAsB,CAA0BlM,GAEtB,MAAO,YACX,EACA,2BAAAmM,CAA4BnM,GACxB,IAAIgI,EAEAA,EADAhI,EAAQ8J,wBAAwBvJ,EACrBP,EAAQ8J,aAAa5K,KAGrBc,EAAQ8J,aAEvB,MAAMc,EAAS,iCAAiC5C,4CAAmDhI,EAAQoM,gBAC3G,OAAOxB,CACX,G,eCzKG,SAASyB,GAAeC,EAAWC,GACtC,MAAMC,EAAc,IAAIC,GAAuBH,EAAWC,GAE1D,OADAC,EAAYE,cACLF,EAAYG,MACvB,CACO,MAAMF,WAA+B,EACxC,WAAA/M,CAAYkN,EAAeL,GACvBtM,QACAV,KAAKqN,cAAgBA,EACrBrN,KAAKgN,eAAiBA,EACtBhN,KAAKoN,OAAS,EAClB,CACA,WAAAD,IACI,EAAA5M,EAAA,IAAQ,OAAOP,KAAKqN,gBAAiB7M,IACjCR,KAAKsN,aAAe9M,EACpBA,EAAKJ,OAAOJ,KAAK,GAEzB,CACA,gBAAA+C,CAAiBhB,GACb,MAAMwL,EAAMvN,KAAKqN,cAActL,EAAKI,iBACpC,GAAKoL,EAUDxL,EAAKhB,eAAiBwM,MAVhB,CACN,MAAM3E,EAAM5I,KAAKgN,eAAe1C,uBAAuBtK,KAAKsN,aAAcvL,GAC1E/B,KAAKoN,OAAOrJ,KAAK,CACbyJ,QAAS5E,EACT1G,KAAMuL,GAA0BC,uBAChCjF,SAAUzI,KAAKsN,aAAa3N,KAC5BgO,kBAAmB5L,EAAKI,iBAEhC,CAIJ,E,4FC/BG,MAAMyL,WAAyCzJ,EAClD,WAAAhE,CAAYmH,EAASuG,GACjBnN,QACAV,KAAKsH,QAAUA,EACftH,KAAK6N,KAAOA,EACZ7N,KAAK8N,iBAAmB,GACxB9N,KAAK+N,mBAAqB,GAC1B/N,KAAKgO,yBAA2B,EAChChO,KAAKiO,OAAQ,EACbjO,KAAKkO,eAAgB,CACzB,CACA,YAAA1G,GAEI,GADAxH,KAAKiO,OAAQ,EACTjO,KAAK6N,KAAKM,UAAU,KAAOnO,KAAKsH,QAAQ3H,KACxC,MAAMkD,MAAM,uDAUhB,OAPA7C,KAAKmO,WAAY,EAAAC,EAAA,GAAMpO,KAAK6N,KAAKM,WAAWE,UAC5CrO,KAAKsO,iBAAkB,EAAAF,EAAA,GAAMpO,KAAK6N,KAAKS,iBAAiBD,UAExDrO,KAAKmO,UAAUI,MACfvO,KAAKsO,gBAAgBC,MACrBvO,KAAKwO,qBACLxO,KAAKoE,KAAKpE,KAAKsH,SACRtH,KAAK8N,gBAChB,CACA,IAAA1J,CAAK5D,EAAM6D,EAAW,IAEbrE,KAAKiO,OACNvN,MAAM0D,KAAK5D,EAAM6D,EAEzB,CACA,WAAAI,CAAYU,EAASZ,EAAUF,GAE3B,GAAIc,EAAQpE,eAAepB,OAASK,KAAK+N,oBACrC5I,EAAQxE,MAAQX,KAAKgO,yBAA0B,CAC/C,MAAMrG,EAAWpD,EAASe,OAAOjB,GACjCrE,KAAKwO,qBACLxO,KAAKoE,KAAKe,EAAQpE,eAAgB4G,EACtC,CACJ,CACA,kBAAA6G,IAEQ,EAAAC,EAAA,GAAQzO,KAAKmO,YAGbnO,KAAK+N,mBAAqB,GAC1B/N,KAAKgO,yBAA2B,EAChChO,KAAKkO,eAAgB,IAGrBlO,KAAK+N,mBAAqB/N,KAAKmO,UAAUI,MACzCvO,KAAKgO,yBAA2BhO,KAAKsO,gBAAgBC,MAE7D,EAEG,MAAMG,WAA6Bd,GACtC,WAAAzN,CAAYmH,EAASuG,GACjBnN,MAAM4G,EAASuG,GACf7N,KAAK6N,KAAOA,EACZ7N,KAAK2O,iBAAmB,GACxB3O,KAAK4O,uBAAyB,EAC9B5O,KAAK2O,iBAAmB3O,KAAK6N,KAAKgB,QAAQlP,KAC1CK,KAAK4O,uBAAyB5O,KAAK6N,KAAKiB,iBAC5C,CACA,YAAApK,CAAaQ,EAAUX,EAAUF,GAC7B,GAAIrE,KAAKkO,eACLhJ,EAAS5C,aAAa3C,OAASK,KAAK2O,kBACpCzJ,EAASvE,MAAQX,KAAK4O,yBACrB5O,KAAKiO,MAAO,CACb,MAAMtG,EAAWpD,EAASe,OAAOjB,GAC3BuD,EAAW,IAAI1G,EAAY,CAAEnB,WAAY4H,IAC/C3H,KAAK8N,iBAAmBvH,EAAMqB,GAC9B5H,KAAKiO,OAAQ,CACjB,CACJ,EAMG,MAAMc,WAAkD5K,EAC3D,WAAAhE,CAAY6O,EAAStD,GACjBhL,QACAV,KAAKgP,QAAUA,EACfhP,KAAK0L,WAAaA,EAClB1L,KAAKwJ,OAAS,CACVyF,WAAOnO,EACP4K,gBAAY5K,EACZoO,iBAAapO,EAErB,CACA,YAAA0G,GAEI,OADAxH,KAAKoE,KAAKpE,KAAKgP,SACRhP,KAAKwJ,MAChB,EAEG,MAAM2F,WAAoCJ,GAC7C,QAAA/J,CAASa,EAAUtB,EAAUF,GACzB,GAAIwB,EAASlF,MAAQX,KAAK0L,WAAY,CAClC,MAAM0D,GAAiB,OAAO7K,EAASe,OAAOjB,IAC9CrE,KAAKwJ,OAAO0F,iBAAiCpO,IAAnBsO,EACtBA,aAA0BzN,IAC1B3B,KAAKwJ,OAAOyF,MAAQG,EAAe9M,aACnCtC,KAAKwJ,OAAOkC,WAAa0D,EAAezO,IAEhD,MAEID,MAAMsE,SAASa,EAAUtB,EAAUF,EAE3C,EAEG,MAAMgL,WAAuCN,GAChD,WAAAhK,CAAYgB,EAAaxB,EAAUF,GAC/B,GAAI0B,EAAYpF,MAAQX,KAAK0L,WAAY,CACrC,MAAM4D,GAAoB,OAAO/K,EAASe,OAAOjB,IACjDrE,KAAKwJ,OAAO0F,iBAAoCpO,IAAtBwO,EACtBA,aAA6B3N,IAC7B3B,KAAKwJ,OAAOyF,MAAQK,EAAkBhN,aACtCtC,KAAKwJ,OAAOkC,WAAa4D,EAAkB3O,IAEnD,MAEID,MAAMqE,YAAYgB,EAAaxB,EAAUF,EAEjD,EAEG,MAAMkL,WAA0CR,GACnD,cAAAlK,CAAeW,EAAgBjB,EAAUF,GACrC,GAAImB,EAAe7E,MAAQX,KAAK0L,WAAY,CACxC,MAAM8D,GAAuB,OAAOjL,EAASe,OAAOjB,IACpDrE,KAAKwJ,OAAO0F,iBAAuCpO,IAAzB0O,EACtBA,aAAgC7N,IAChC3B,KAAKwJ,OAAOyF,MAAQO,EAAqBlN,aACzCtC,KAAKwJ,OAAOkC,WAAa8D,EAAqB7O,IAEtD,MAEID,MAAMmE,eAAeW,EAAgBjB,EAAUF,EAEvD,EAGG,MAAMoL,WAA6CV,GACtD,iBAAAjK,CAAkB4K,EAAmBnL,EAAUF,GAC3C,GAAIqL,EAAkB/O,MAAQX,KAAK0L,WAAY,CAC3C,MAAMiE,GAAoC,OAAOpL,EAASe,OAAOjB,IACjErE,KAAKwJ,OAAO0F,iBAAoDpO,IAAtC6O,EACtBA,aAA6ChO,IAC7C3B,KAAKwJ,OAAOyF,MAAQU,EAAkCrN,aACtDtC,KAAKwJ,OAAOkC,WAAaiE,EAAkChP,IAEnE,MAEID,MAAMoE,kBAAkB4K,EAAmBnL,EAAUF,EAE7D,EAEG,SAASuL,GAAkBC,EAAWC,EAAWnG,EAAW,IAE/DA,GAAW,EAAAyE,EAAA,GAAMzE,GACjB,IAAIH,EAAS,GACTuG,EAAI,EAER,SAASC,EAAkBC,GACvB,OAAOA,EAAQ3K,QAAO,EAAAd,EAAA,GAAKqL,EAAWE,EAAI,GAC9C,CAEA,SAASG,EAAuBnQ,GAC5B,MAAMoQ,EAAeP,GAAkBI,EAAkBjQ,GAAa+P,EAAWnG,GACjF,OAAOH,EAAOlE,OAAO6K,EACzB,CAQA,MAAOxG,EAAS3C,OAAS8I,GAAaC,EAAIF,EAAU7I,OAAQ,CACxD,MAAMxG,EAAOqP,EAAUE,GAEvB,GAAIvP,aAAgBU,EAChB,OAAOgP,EAAuB1P,EAAKT,YAElC,GAAIS,aAAgB,EACrB,OAAO0P,EAAuB1P,EAAKT,YAElC,GAAIS,aAAgBY,EACrBoI,EAAS0G,EAAuB1P,EAAKT,gBAEpC,IAAIS,aAAgBa,EAAqB,CAC1C,MAAM+O,EAAS5P,EAAKT,WAAWuF,OAAO,CAClC,IAAI/D,EAAW,CACXxB,WAAYS,EAAKT,eAGzB,OAAOmQ,EAAuBE,EAClC,CACK,GAAI5P,aAAgBc,EAAkC,CACvD,MAAM8O,EAAS,CACX,IAAIlP,EAAY,CAAEnB,WAAYS,EAAKT,aACnC,IAAIwB,EAAW,CACXxB,WAAY,CAAC,IAAI4B,EAAS,CAAEW,aAAc9B,EAAK6B,aAAciD,OAAO9E,EAAKT,eAGjF,OAAOmQ,EAAuBE,EAClC,CACK,GAAI5P,aAAgBgB,EAAyB,CAC9C,MAAM4O,EAAS5P,EAAKT,WAAWuF,OAAO,CAClC,IAAI/D,EAAW,CACXxB,WAAY,CAAC,IAAI4B,EAAS,CAAEW,aAAc9B,EAAK6B,aAAciD,OAAO9E,EAAKT,gBAGjFyJ,EAAS0G,EAAuBE,EACpC,MACK,GAAI5P,aAAgBe,EAAY,CACjC,MAAM6O,EAAS5P,EAAKT,WAAWuF,OAAO,CAClC,IAAI/D,EAAW,CACXxB,WAAYS,EAAKT,eAGzByJ,EAAS0G,EAAuBE,EACpC,KACK,IAAI5P,aAAgBiB,EASrB,OARA,EAAAlB,EAAA,GAAQC,EAAKT,YAAasQ,KAIc,KAAhC,EAAA5B,EAAA,GAAQ4B,EAAQtQ,cAChByJ,EAAS0G,EAAuBG,EAAQtQ,YAC5C,IAEGyJ,EAEN,KAAIhJ,aAAgBmB,GAIrB,MAAMkB,MAAM,wBAHZ8G,EAAS5F,KAAKvD,EAAK8B,aAIvB,EACAyN,GACJ,CAKA,OAJAvG,EAAOzF,KAAK,CACRuM,YAAa3G,EACb4G,WAAW,EAAA/L,EAAA,GAAKqL,EAAWE,KAExBvG,CACX,CACO,SAASgH,GAAwBC,EAAYC,EAAaC,EAAYC,GACzE,MAAMC,EAAoB,qBAEpBC,EAAwB,CAACD,GACzBE,EAAmB,mBACzB,IAAIC,GAAoB,EACxB,MAAMC,EAAoBP,EAAY1J,OAChCkK,EAA2BD,EAAoBL,EAAe,EAC9DpH,EAAS,GACT2H,EAAgB,GACtBA,EAAcpN,KAAK,CACfpD,KAAM,EACNyQ,IAAKX,EACLtC,UAAW,GACXG,gBAAiB,KAErB,QAAQ,EAAAG,EAAA,GAAQ0C,GAAgB,CAC5B,MAAMxH,EAAWwH,EAAc5C,MAE/B,GAAI5E,IAAaoH,EAAkB,CAC3BC,IACA,EAAAK,GAAA,GAAKF,GAAexQ,KAAOuQ,GAE3BC,EAAc5C,MAElB,QACJ,CACA,MAAM+C,EAAU3H,EAASyH,IACnBG,EAAU5H,EAAShJ,IACnB6Q,EAAgB7H,EAASwE,UACzBsD,EAAsB9H,EAAS2E,gBAErC,IAAI,EAAAG,EAAA,GAAQ6C,GACR,SAEJ,MAAM9Q,EAAO8Q,EAAQ,GAErB,GAAI9Q,IAASqQ,EAAmB,CAC5B,MAAMa,EAAW,CACb/Q,IAAK4Q,EACLH,KAAK,EAAA5M,EAAA,GAAK8M,GACVnD,WAAW,EAAAwD,GAAA,GAAUH,GACrBlD,iBAAiB,EAAAqD,GAAA,GAAUF,IAE/BN,EAAcpN,KAAK2N,EACvB,MACK,GAAIlR,aAAgBmB,EAErB,GAAI4P,EAAUN,EAAoB,EAAG,CACjC,MAAMW,EAAUL,EAAU,EACpBM,EAAcnB,EAAYkB,GAChC,GAAIjB,EAAWkB,EAAarR,EAAK8B,cAAe,CAC5C,MAAMoP,EAAW,CACb/Q,IAAKiR,EACLR,KAAK,EAAA5M,EAAA,GAAK8M,GACVnD,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAK2N,EACvB,CAEJ,KACK,IAAIH,IAAYN,EAAoB,EAWrC,MAAMpO,MAAM,wBATZ2G,EAAOzF,KAAK,CACR+N,cAAetR,EAAK8B,aACpByP,oBAAqBvR,EAAKG,IAC1BwN,UAAWqD,EACXlD,gBAAiBmD,IAErBT,GAAoB,CAIxB,MAEC,GAAIxQ,aAAgB,EAAa,CAClC,MAAMwR,GAAe,EAAA5D,EAAA,GAAMoD,GAC3BQ,EAAajO,KAAKvD,EAAK2B,iBACvB,MAAM8P,GAAqB,EAAA7D,EAAA,GAAMqD,GACjCQ,EAAmBlO,KAAKvD,EAAKG,KAC7B,MAAM+Q,EAAW,CACb/Q,IAAK4Q,EACLH,IAAK5Q,EAAKT,WAAWuF,OAAOwL,GAAuB,EAAAtM,EAAA,GAAK8M,IACxDnD,UAAW6D,EACX1D,gBAAiB2D,GAErBd,EAAcpN,KAAK2N,EACvB,MACK,GAAIlR,aAAgBY,EAAQ,CAE7B,MAAM8Q,EAAkB,CACpBvR,IAAK4Q,EACLH,KAAK,EAAA5M,EAAA,GAAK8M,GACVnD,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKmO,GAEnBf,EAAcpN,KAAKgN,GACnB,MAAMoB,EAAe,CACjBxR,IAAK4Q,EACLH,IAAK5Q,EAAKT,WAAWuF,QAAO,EAAAd,EAAA,GAAK8M,IACjCnD,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKoO,EACvB,MACK,GAAI3R,aAAgBa,EAAqB,CAE1C,MAAM+Q,EAAkB,IAAI7Q,EAAW,CACnCxB,WAAYS,EAAKT,WACjBY,IAAKH,EAAKG,MAERsP,EAAUzP,EAAKT,WAAWuF,OAAO,CAAC8M,IAAkB,EAAA5N,EAAA,GAAK8M,IACzDI,EAAW,CACb/Q,IAAK4Q,EACLH,IAAKnB,EACL9B,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAK2N,EACvB,MACK,GAAIlR,aAAgBc,EAAkC,CAEvD,MAAM+Q,EAAgB,IAAI1Q,EAAS,CAC/BW,aAAc9B,EAAK6B,YAEjB+P,EAAkB,IAAI7Q,EAAW,CACnCxB,WAAY,CAACsS,GAAe/M,OAAO9E,EAAKT,YACxCY,IAAKH,EAAKG,MAERsP,EAAUzP,EAAKT,WAAWuF,OAAO,CAAC8M,IAAkB,EAAA5N,EAAA,GAAK8M,IACzDI,EAAW,CACb/Q,IAAK4Q,EACLH,IAAKnB,EACL9B,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAK2N,EACvB,MACK,GAAIlR,aAAgBgB,EAAyB,CAE9C,MAAM0Q,EAAkB,CACpBvR,IAAK4Q,EACLH,KAAK,EAAA5M,EAAA,GAAK8M,GACVnD,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKmO,GAEnBf,EAAcpN,KAAKgN,GACnB,MAAMsB,EAAgB,IAAI1Q,EAAS,CAC/BW,aAAc9B,EAAK6B,YAEjBiQ,EAAgB,IAAI/Q,EAAW,CACjCxB,WAAY,CAACsS,GAAe/M,OAAO9E,EAAKT,YACxCY,IAAKH,EAAKG,MAERsP,EAAUzP,EAAKT,WAAWuF,OAAO,CAACgN,IAAgB,EAAA9N,EAAA,GAAK8M,IACvDa,EAAe,CACjBxR,IAAK4Q,EACLH,IAAKnB,EACL9B,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKoO,EACvB,MACK,GAAI3R,aAAgBe,EAAY,CAEjC,MAAM2Q,EAAkB,CACpBvR,IAAK4Q,EACLH,KAAK,EAAA5M,EAAA,GAAK8M,GACVnD,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKmO,GAEnBf,EAAcpN,KAAKgN,GAEnB,MAAMuB,EAAgB,IAAI/Q,EAAW,CACjCxB,WAAYS,EAAKT,WACjBY,IAAKH,EAAKG,MAERsP,EAAUzP,EAAKT,WAAWuF,OAAO,CAACgN,IAAgB,EAAA9N,EAAA,GAAK8M,IACvDa,EAAe,CACjBxR,IAAK4Q,EACLH,IAAKnB,EACL9B,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKoO,EACvB,MACK,GAAI3R,aAAgBiB,EAErB,IAAK,IAAIsO,EAAIvP,EAAKT,WAAWiH,OAAS,EAAG+I,GAAK,EAAGA,IAAK,CAClD,MAAMM,EAAU7P,EAAKT,WAAWgQ,GAC1BwC,EAAc,CAChB5R,IAAK4Q,EACLH,IAAKf,EAAQtQ,WAAWuF,QAAO,EAAAd,EAAA,GAAK8M,IACpCnD,UAAWqD,EACXlD,gBAAiBmD,GAErBN,EAAcpN,KAAKwO,GACnBpB,EAAcpN,KAAKgN,EACvB,MAEC,GAAIvQ,aAAgBU,EACrBiQ,EAAcpN,KAAK,CACfpD,IAAK4Q,EACLH,IAAK5Q,EAAKT,WAAWuF,QAAO,EAAAd,EAAA,GAAK8M,IACjCnD,UAAWqD,EACXlD,gBAAiBmD,QAGpB,MAAIjR,aAAgBQ,GAKrB,MAAM6B,MAAM,wBAHZsO,EAAcpN,KAAKyO,GAAmBhS,EAAM+Q,EAASC,EAAeC,GAIxE,CACJ,CACA,OAAOjI,CACX,CACA,SAASgJ,GAAmBxD,EAASuC,EAASC,EAAeC,GACzD,MAAMO,GAAe,EAAA5D,EAAA,GAAMoD,GAC3BQ,EAAajO,KAAKiL,EAAQrP,MAC1B,MAAM8S,GAAyB,EAAArE,EAAA,GAAMqD,GAGrC,OADAgB,EAAuB1O,KAAK,GACrB,CACHpD,IAAK4Q,EACLH,IAAKpC,EAAQjP,WACboO,UAAW6D,EACX1D,gBAAiBmE,EAEzB,C,ICreWC,G,WASJ,SAASC,GAAYnS,GAExB,GAAIA,aAAgBY,GAAmB,WAATZ,EAC1B,OAAOkS,GAAUE,OAEhB,GAAIpS,aAAgBe,GAAuB,eAATf,EACnC,OAAOkS,GAAUG,WAEhB,GAAIrS,aAAgBa,GACZ,wBAATb,EACA,OAAOkS,GAAUI,qBAEhB,GAAItS,aAAgBc,GACZ,qCAATd,EACA,OAAOkS,GAAUK,oCAEhB,GAAIvS,aAAgBgB,GACZ,4BAAThB,EACA,OAAOkS,GAAUM,0BAEhB,GAAIxS,aAAgBiB,GAAwB,gBAATjB,EACpC,OAAOkS,GAAUO,YAGjB,MAAMpQ,MAAM,uBAEpB,CAWO,SAASqQ,GAAwBxH,EAAYyH,EAAaC,EAAc1R,EAAe2R,EAAsBC,GAChH,MAAMC,EAAiBC,GAAuB9H,EAAYyH,EAAaC,GACjEK,EAAeC,GAA0BH,GACzC,MACA,MACN,OAAOD,EAAcC,EAAgB7R,EAAe+R,EAAcJ,EACtE,CAaO,SAASM,GAAkCjI,EAAYyH,EAAaS,EAAGP,EAAsBQ,EAAUC,GAC1G,MAAMP,EAAiBQ,GAAiCrI,EAAYyH,EAAaU,EAAUD,GACrFH,EAAeC,GAA0BH,GACzC,MACA,MACN,OAAOO,EAAiBP,EAAe,GAAIE,EAAcJ,EAC7D,CACO,SAASW,GAA+BC,EAAMvS,EAAe+R,EAAcJ,GAC9E,MAAMa,EAAYD,EAAKjN,OACjBmN,GAA0B,EAAAnQ,EAAA,GAAMiQ,GAAO5D,IAClC,EAAArM,EAAA,GAAMqM,GAAU1G,GACQ,IAApBA,EAAS3C,WAIxB,GAAItF,EAIA,OAAO,SAAU0S,GAIb,MAAMC,GAAa,OAAID,GAAS/D,GAAYA,EAAQiE,OACpD,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAWK,IAAK,CAChC,MAAMlE,EAAU4D,EAAKM,GACfC,EAAiBnE,EAAQrJ,OACzByN,EAAgBJ,EAAWE,GACjC,QAAsBzT,IAAlB2T,IAA4D,IAA7BA,EAAcC,KAAK1U,MAItD0R,EAAU,IAAK,IAAIiD,EAAI,EAAGA,EAAIH,EAAgBG,IAAK,CAC/C,MAAMhL,EAAW0G,EAAQsE,GACnBC,EAAiBjL,EAAS3C,OAChC,IAAK,IAAI+I,EAAI,EAAGA,EAAI6E,EAAgB7E,IAAK,CACrC,MAAM8E,EAAY7U,KAAK8U,GAAG/E,EAAI,GAC9B,IAA6C,IAAzC0D,EAAaoB,EAAWlL,EAASoG,IAGjC,SAAS2B,CAEjB,CAGA,OAAO6C,CACX,CAGJ,CAGJ,EAEC,GAAIJ,IAA4Bd,EAAsB,CAGvD,MAAM0B,GAAkB,OAAId,GAAO5D,IACxB,OAAQA,KAEb2E,GAAc,EAAAzL,EAAA,GAAOwL,GAAiB,CAACvL,EAAQ6G,EAAS1P,MAC1D,EAAAJ,EAAA,GAAQ8P,GAAU4E,KACT,EAAAC,EAAA,GAAI1L,EAAQyL,EAAYE,gBACzB3L,EAAOyL,EAAYE,cAAgBxU,IAEvC,EAAAJ,EAAA,GAAQ0U,EAAYG,iBAAkBC,KAC7B,EAAAH,EAAA,GAAI1L,EAAQ6L,KACb7L,EAAO6L,GAAqB1U,EAChC,GACF,IAEC6I,IACR,CAAC,GAIJ,OAAO,WACH,MAAMqL,EAAY7U,KAAK8U,GAAG,GAC1B,OAAOE,EAAYH,EAAUM,aACjC,CACJ,CAOI,OAAO,WACH,IAAK,IAAIZ,EAAI,EAAGA,EAAIL,EAAWK,IAAK,CAChC,MAAMlE,EAAU4D,EAAKM,GACfC,EAAiBnE,EAAQrJ,OAC/B0K,EAAU,IAAK,IAAIiD,EAAI,EAAGA,EAAIH,EAAgBG,IAAK,CAC/C,MAAMhL,EAAW0G,EAAQsE,GACnBC,EAAiBjL,EAAS3C,OAChC,IAAK,IAAI+I,EAAI,EAAGA,EAAI6E,EAAgB7E,IAAK,CACrC,MAAM8E,EAAY7U,KAAK8U,GAAG/E,EAAI,GAC9B,IAA6C,IAAzC0D,EAAaoB,EAAWlL,EAASoG,IAGjC,SAAS2B,CAEjB,CAGA,OAAO6C,CACX,CAGJ,CAGJ,CAER,CACO,SAASe,GAAwCpP,EAAKuN,EAAcJ,GACvE,MAAMc,GAA0B,EAAAnQ,EAAA,GAAMkC,GAAMyD,GACb,IAApBA,EAAS3C,SAEduO,EAAarP,EAAIc,OAGvB,GAAImN,IAA4Bd,EAAsB,CAClD,MAAMmC,GAAoB,OAAQtP,GAClC,GAAiC,IAA7BsP,EAAkBxO,SAClB,EAAAyH,EAAA,GAAQ+G,EAAkB,GAAGJ,iBAAkB,CAC/C,MAAMK,EAAoBD,EAAkB,GACtCE,EAAyBD,EAAkBN,aACjD,OAAO,WACH,OAAOnV,KAAK8U,GAAG,GAAGK,eAAiBO,CACvC,CACJ,CACK,CACD,MAAMV,GAAc,EAAAzL,EAAA,GAAOiM,GAAmB,CAAChM,EAAQyL,EAAatU,KAChE6I,EAAOyL,EAAYE,eAAgB,GACnC,EAAA5U,EAAA,GAAQ0U,EAAYG,iBAAkBC,IAClC7L,EAAO6L,IAAqB,CAAI,IAE7B7L,IACR,IACH,OAAO,WACH,MAAMqL,EAAY7U,KAAK8U,GAAG,GAC1B,OAA+C,IAAxCE,EAAYH,EAAUM,aACjC,CACJ,CACJ,CAEI,OAAO,WACHzD,EAAU,IAAK,IAAIiD,EAAI,EAAGA,EAAIY,EAAYZ,IAAK,CAC3C,MAAMhL,EAAWzD,EAAIyO,GACfC,EAAiBjL,EAAS3C,OAChC,IAAK,IAAI+I,EAAI,EAAGA,EAAI6E,EAAgB7E,IAAK,CACrC,MAAM8E,EAAY7U,KAAK8U,GAAG/E,EAAI,GAC9B,IAA6C,IAAzC0D,EAAaoB,EAAWlL,EAASoG,IAGjC,SAAS2B,CAEjB,CAEA,OAAO,CACX,CAEA,OAAO,CACX,CAER,EArOA,SAAWgB,GACPA,EAAUA,EAAU,UAAY,GAAK,SACrCA,EAAUA,EAAU,cAAgB,GAAK,aACzCA,EAAUA,EAAU,wBAA0B,GAAK,uBACnDA,EAAUA,EAAU,uCAAyC,GAAK,sCAClEA,EAAUA,EAAU,6BAA+B,GAAK,4BACxDA,EAAUA,EAAU,eAAiB,GAAK,aAC7C,EAPD,CAOGA,KAAcA,GAAY,CAAC,IA+N9B,MAAMiD,WAAmCxR,EACrC,WAAAhE,CAAYmH,EAASsO,EAAkBC,GACnCnV,QACAV,KAAKsH,QAAUA,EACftH,KAAK4V,iBAAmBA,EACxB5V,KAAK6V,eAAiBA,CAC1B,CACA,YAAArO,GAEI,OADAxH,KAAKoE,KAAKpE,KAAKsH,SACRtH,KAAK8V,OAChB,CACA,aAAAC,CAAchU,EAAMiU,EAAkBzR,EAAUF,GAC5C,OAAItC,EAAKpB,MAAQX,KAAK4V,kBAClB5V,KAAK6V,iBAAmBG,IACxBhW,KAAK8V,QAAUvR,EAASe,OAAOjB,IACxB,EAIf,CACA,UAAAO,CAAWW,EAAYhB,EAAUF,GACxBrE,KAAK+V,cAAcxQ,EAAYmN,GAAUE,OAAQrO,EAAUF,IAC5D3D,MAAMkE,WAAWW,EAAYhB,EAAUF,EAE/C,CACA,cAAAQ,CAAeW,EAAgBjB,EAAUF,GAChCrE,KAAK+V,cAAcvQ,EAAgBkN,GAAUI,qBAAsBvO,EAAUF,IAC9E3D,MAAMkE,WAAWY,EAAgBjB,EAAUF,EAEnD,CACA,iBAAAS,CAAkBY,EAAmBnB,EAAUF,GACtCrE,KAAK+V,cAAcrQ,EAAmBgN,GAAUK,oCAAqCxO,EAAUF,IAChG3D,MAAMkE,WAAWc,EAAmBnB,EAAUF,EAEtD,CACA,QAAAW,CAASa,EAAUtB,EAAUF,GACpBrE,KAAK+V,cAAclQ,EAAU6M,GAAUG,WAAYtO,EAAUF,IAC9D3D,MAAMkE,WAAWiB,EAAUtB,EAAUF,EAE7C,CACA,WAAAU,CAAYgB,EAAaxB,EAAUF,GAC1BrE,KAAK+V,cAAchQ,EAAa2M,GAAUM,0BAA2BzO,EAAUF,IAChF3D,MAAMkE,WAAWmB,EAAaxB,EAAUF,EAEhD,EAKJ,MAAM4R,WAAsC,EACxC,WAAA9V,CAAYyV,EAAkBC,EAAgBK,GAC1CxV,QACAV,KAAK4V,iBAAmBA,EACxB5V,KAAK6V,eAAiBA,EACtB7V,KAAKkW,UAAYA,EACjBlW,KAAKwJ,OAAS,EAClB,CACA,aAAAuM,CAAchU,EAAMoU,GACZpU,EAAKpB,MAAQX,KAAK4V,kBAClB5V,KAAK6V,iBAAmBM,QACJrV,IAAnBd,KAAKkW,WAA2BnU,IAAS/B,KAAKkW,YAC/ClW,KAAKwJ,OAASzH,EAAKhC,WAE3B,CACA,WAAAkD,CAAYlB,GACR/B,KAAK+V,cAAchU,EAAM2Q,GAAUE,OACvC,CACA,eAAAvP,CAAgBtB,GACZ/B,KAAK+V,cAAchU,EAAM2Q,GAAUG,WACvC,CACA,wBAAA3P,CAAyBnB,GACrB/B,KAAK+V,cAAchU,EAAM2Q,GAAUI,qBACvC,CACA,qCAAA3P,CAAsCpB,GAClC/B,KAAK+V,cAAchU,EAAM2Q,GAAUK,oCACvC,CACA,4BAAA3P,CAA6BrB,GACzB/B,KAAK+V,cAAchU,EAAM2Q,GAAUM,0BACvC,CACA,gBAAA1P,CAAiBvB,GACb/B,KAAK+V,cAAchU,EAAM2Q,GAAUO,YACvC,EAEJ,SAASmD,GAAwBC,GAC7B,MAAM7M,EAAS,IAAI8M,MAAMD,GACzB,IAAK,IAAItG,EAAI,EAAGA,EAAIsG,EAAMtG,IACtBvG,EAAOuG,GAAK,GAEhB,OAAOvG,CACX,CAMA,SAAS+M,GAAe1I,GACpB,IAAI2I,EAAO,CAAC,IACZ,IAAK,IAAIzG,EAAI,EAAGA,EAAIlC,EAAK7G,OAAQ+I,IAAK,CAClC,MAAMvQ,EAAUqO,EAAKkC,GACf0G,EAAa,GACnB,IAAK,IAAI9B,EAAI,EAAGA,EAAI6B,EAAKxP,OAAQ2N,IAAK,CAClC,MAAM+B,EAAiBF,EAAK7B,GAC5B8B,EAAW1S,KAAK2S,EAAiB,IAAMlX,EAAQ2V,cAC/C,IAAK,IAAIZ,EAAI,EAAGA,EAAI/U,EAAQ4V,gBAAgBpO,OAAQuN,IAAK,CACrD,MAAMoC,EAAsB,IAAMnX,EAAQ4V,gBAAgBb,GAC1DkC,EAAW1S,KAAK2S,EAAiBC,EACrC,CACJ,CACAH,EAAOC,CACX,CACA,OAAOD,CACX,CAIA,SAASI,GAAmBC,EAAmBC,EAAgBnW,GAC3D,IAAK,IAAIoW,EAAa,EAAGA,EAAaF,EAAkB7P,OAAQ+P,IAAc,CAE1E,GAAIA,IAAepW,EACf,SAEJ,MAAMqW,EAAyBH,EAAkBE,GACjD,IAAK,IAAIE,EAAY,EAAGA,EAAYH,EAAe9P,OAAQiQ,IAAa,CACpE,MAAMC,EAAYJ,EAAeG,GACjC,IAA0C,IAAtCD,EAAuBE,GACvB,OAAO,CAEf,CACJ,CAEA,OAAO,CACX,CACO,SAASC,GAAkCC,EAAUxD,GACxD,MAAMyD,GAAc,OAAID,GAAW/G,GAAYT,GAAkB,CAACS,GAAU,KACtEiH,EAAclB,GAAwBiB,EAAYrQ,QAClDuQ,GAAa,OAAIF,GAAc5N,IACjC,MAAM+N,EAAO,CAAC,EAOd,OANA,EAAAjX,EAAA,GAAQkJ,GAAegO,IACnB,MAAMjB,EAAOD,GAAekB,EAAKnH,cACjC,EAAA/P,EAAA,GAAQiW,GAAOkB,IACXF,EAAKE,IAAW,CAAI,GACtB,IAECF,CAAI,IAEf,IAAIG,EAAUN,EAEd,IAAK,IAAIO,EAAa,EAAGA,GAAchE,EAAGgE,IAAc,CACpD,MAAMC,EAAcF,EACpBA,EAAUvB,GAAwByB,EAAY7Q,QAE9C,IAAK,IAAI8Q,EAAS,EAAGA,EAASD,EAAY7Q,OAAQ8Q,IAAU,CACxD,MAAMC,EAA0BF,EAAYC,GAE5C,IAAK,IAAIE,EAAc,EAAGA,EAAcD,EAAwB/Q,OAAQgR,IAAe,CACnF,MAAMC,EAAiBF,EAAwBC,GAAa1H,YACtDC,EAAYwH,EAAwBC,GAAazH,UACjD2H,EAAa3B,GAAe0B,GAC5BE,EAAWvB,GAAmBW,EAAYW,EAAYJ,GAE5D,GAAIK,IAAY,EAAA1J,EAAA,GAAQ8B,IAAc0H,EAAejR,SAAW4M,EAAG,CAC/D,MAAMwE,EAAgBd,EAAYQ,GAElC,IAAoD,IAAhDO,GAAaD,EAAeH,GAA2B,CACvDG,EAAcrU,KAAKkU,GAEnB,IAAK,IAAItD,EAAI,EAAGA,EAAIuD,EAAWlR,OAAQ2N,IAAK,CACxC,MAAM+C,EAAUQ,EAAWvD,GAC3B4C,EAAWO,GAAQJ,IAAW,CAClC,CACJ,CACJ,KAEK,CACD,MAAMY,EAA6B1I,GAAkBW,EAAWqH,EAAa,EAAGK,GAChFN,EAAQG,GAAUH,EAAQG,GAAQxS,OAAOgT,IAEzC,EAAA/X,EAAA,GAAQ+X,GAA6Bb,IACjC,MAAMS,EAAa3B,GAAekB,EAAKnH,cACvC,EAAA/P,EAAA,GAAQ2X,GAAaK,IACjBhB,EAAWO,GAAQS,IAAO,CAAI,GAChC,GAEV,CACJ,CACJ,CACJ,CACA,OAAOjB,CACX,CACO,SAAS9D,GAAuB9H,EAAYyH,EAAaS,EAAG3N,GAC/D,MAAM5F,EAAU,IAAI4V,GAA8BvK,EAAYgH,GAAUO,YAAahN,GAErF,OADAkN,EAAY/S,OAAOC,GACZ8W,GAAkC9W,EAAQmJ,OAAQoK,EAC7D,CACO,SAASG,GAAiCrI,EAAYyH,EAAaU,EAAUD,GAChF,MAAM4E,EAAmB,IAAIvC,GAA8BvK,EAAYmI,GACvEV,EAAY/S,OAAOoY,GACnB,MAAMC,EAAYD,EAAiBhP,OAC7BkP,EAAiB,IAAI/C,GAA2BxC,EAAazH,EAAYmI,GACzE8E,EAAWD,EAAelR,eAC1BoR,EAAa,IAAI1X,EAAgB,CAAEnB,WAAY0Y,IAC/CI,EAAY,IAAI3X,EAAgB,CAAEnB,WAAY4Y,IACpD,OAAOxB,GAAkC,CAACyB,EAAYC,GAAYjF,EACtE,CACO,SAASyE,GAAaS,EAAaC,GACtCC,EAAkB,IAAK,IAAIjJ,EAAI,EAAGA,EAAI+I,EAAY9R,OAAQ+I,IAAK,CAC3D,MAAMkJ,EAAYH,EAAY/I,GAC9B,GAAIkJ,EAAUjS,SAAW+R,EAAW/R,OAApC,CAGA,IAAK,IAAI2N,EAAI,EAAGA,EAAIsE,EAAUjS,OAAQ2N,IAAK,CACvC,MAAMuE,EAAYH,EAAWpE,GACvBwE,EAAWF,EAAUtE,GACrByE,EAAiBF,IAAcC,QACuBrY,IAAxDqY,EAASE,mBAAmBH,EAAU/D,cAC1C,IAAuB,IAAnBiE,EACA,SAASJ,CAEjB,CACA,OAAO,CAVP,CAWJ,CACA,OAAO,CACX,CACO,SAASM,GAAqBC,EAAQC,GACzC,OAAQD,EAAOvS,OAASwS,EAAMxS,SAC1B,EAAAhD,EAAA,GAAMuV,GAAQ,CAAC/Z,EAASmB,KACpB,MAAM8Y,EAAeD,EAAM7Y,GAC3B,OAAQnB,IAAYia,GAChBA,EAAaJ,mBAAmB7Z,EAAQ2V,aAAc,GAEtE,CACO,SAASzB,GAA0BH,GACtC,OAAO,EAAAvP,EAAA,GAAMuP,GAAiBmG,IAAmB,EAAA1V,EAAA,GAAM0V,GAAiBC,IAAe,EAAA3V,EAAA,GAAM2V,GAAa1K,IAAU,EAAAR,EAAA,GAAQQ,EAAMmG,sBACtI,CC/cO,SAASwE,GAAkBnZ,GAC9B,MAAMoZ,EAAmCpZ,EAAQqZ,kBAAkBC,SAAS,CACxEC,MAAOvZ,EAAQuZ,MACfC,WAAYxZ,EAAQwZ,WACpBpN,YAAapM,EAAQoM,cAEzB,OAAO,OAAIgN,GAAmCK,GAAkB/P,OAAOgQ,OAAO,CAAEjY,KAAMuL,GAA0B2M,6BAA+BF,IACnJ,CACO,SAASG,GAAgBtN,EAAWkN,EAAYjN,EAAgBH,GACnE,MAAMyN,GAAkB,EAAAC,GAAA,GAAQxN,GAAYO,GAAiBkN,GAA6BlN,EAAcN,KAClGyN,EAA+BC,GAAuC3N,EAAWkN,EAAYjN,GAC7F2N,GAAoB,EAAAJ,GAAA,GAAQxN,GAAY6N,GAAYC,GAAoBD,EAAS5N,KACjF8N,GAAsB,EAAAP,GAAA,GAAQxN,GAAY6N,GAAYG,GAAgCH,EAAS7N,EAAWF,EAAaG,KAC7H,OAAOsN,EAAgBhV,OAAOmV,EAA8BE,EAAmBG,EACnF,CACA,SAASN,GAA6BjQ,EAAcyC,GAChD,MAAMgO,EAAmB,IAAIC,GAC7B1Q,EAAanK,OAAO4a,GACpB,MAAME,EAAqBF,EAAiBG,eACtCC,GAAmB,QAAQF,EAAoBG,IAC/CC,GAAa,EAAA1a,EAAA,GAAOwa,GAAmBG,GAClCA,EAAUvU,OAAS,IAExBoG,GAAS,QAAI,OAAOkO,IAAcE,IACpC,MAAMC,GAAY,OAAMD,GAClB5S,EAAMoE,EAAetC,yBAAyBH,EAAciR,GAC5DzQ,EAAU7G,EAAqBuX,GAC/BC,EAAW,CACblO,QAAS5E,EACT1G,KAAMuL,GAA0BkO,sBAChClT,SAAU8B,EAAa5K,KACvBoL,QAASA,EACTW,WAAY+P,EAAU9a,KAEpBib,EAAQhR,GAA2B6Q,GAIzC,OAHIG,IACAF,EAASG,UAAYD,GAElBF,CAAQ,IAEnB,OAAOtO,CACX,CACO,SAASiO,GAAgC7a,GAC5C,MAAO,GAAG0D,EAAqB1D,QAAWA,EAAKG,SAASiK,GAA2BpK,IACvF,CACA,SAASoK,GAA2BpK,GAChC,OAAIA,aAAgBmB,EACTnB,EAAK8B,aAAa3C,KAEpBa,aAAgB,EACdA,EAAK2B,gBAGL,EAEf,CACO,MAAM8Y,WAAsC,EAC/C,WAAA9a,GACIO,SAASob,WACT9b,KAAKmb,eAAiB,EAC1B,CACA,gBAAApY,CAAiBgZ,GACb/b,KAAKmb,eAAepX,KAAKgY,EAC7B,CACA,WAAA9Y,CAAY+Y,GACRhc,KAAKmb,eAAepX,KAAKiY,EAC7B,CACA,4BAAA5Y,CAA6B6Y,GACzBjc,KAAKmb,eAAepX,KAAKkY,EAC7B,CACA,wBAAA/Y,CAAyBgZ,GACrBlc,KAAKmb,eAAepX,KAAKmY,EAC7B,CACA,qCAAA/Y,CAAsCgZ,GAClCnc,KAAKmb,eAAepX,KAAKoY,EAC7B,CACA,eAAA9Y,CAAgB+Y,GACZpc,KAAKmb,eAAepX,KAAKqY,EAC7B,CACA,gBAAA9Y,CAAiB+Y,GACbrc,KAAKmb,eAAepX,KAAKsY,EAC7B,CACA,aAAA9Y,CAAc2B,GACVlF,KAAKmb,eAAepX,KAAKmB,EAC7B,EAEG,SAAS6V,GAAgC3P,EAAMkR,EAAUC,EAAWvP,GACvE,MAAMI,EAAS,GACToP,GAAc,EAAAjT,EAAA,GAAO+S,GAAU,CAAC9S,EAAQoR,IACtCA,EAAQjb,OAASyL,EAAKzL,KACf6J,EAAS,EAEbA,GACR,GACH,GAAIgT,EAAc,EAAG,CACjB,MAAMnR,EAAS2B,EAAeJ,4BAA4B,CACtDrC,aAAca,EACdyB,YAAa0P,IAEjBnP,EAAOrJ,KAAK,CACRyJ,QAASnC,EACTnJ,KAAMuL,GAA0BgP,oBAChChU,SAAU2C,EAAKzL,MAEvB,CACA,OAAOyN,CACX,CAIO,SAASsP,GAAyBjU,EAAUkU,EAAmBJ,GAClE,MAAMnP,EAAS,GACf,IAAI/B,EAWJ,OAVK,EAAAvH,EAAA,GAAS6Y,EAAmBlU,KAC7B4C,EACI,kCAAkC5C,8CAAqD8T,wDAE3FnP,EAAOrJ,KAAK,CACRyJ,QAASnC,EACTnJ,KAAMuL,GAA0BmP,sBAChCnU,SAAUA,KAGX2E,CACX,CACO,SAASyP,GAAwB7N,EAASvC,EAAUO,EAAgBa,EAAO,IAC9E,MAAMT,EAAS,GACT0P,EAAmBC,GAAqBtQ,EAAS1M,YACvD,IAAI,EAAA0O,EAAA,GAAQqO,GACR,MAAO,GAEN,CACD,MAAMrU,EAAWuG,EAAQrP,KACnBqd,GAAqB,EAAAlZ,EAAA,GAASgZ,EAAkB9N,GAClDgO,GACA5P,EAAOrJ,KAAK,CACRyJ,QAASR,EAAeV,wBAAwB,CAC5C/B,aAAcyE,EACdxC,kBAAmBqB,IAEvB3L,KAAMuL,GAA0BwP,eAChCxU,SAAUA,IAKlB,MAAMyU,GAAiB,EAAAC,GAAA,GAAWL,EAAkBjP,EAAKvI,OAAO,CAAC0J,KAC3DoO,GAAsB,EAAA7C,GAAA,GAAQ2C,GAAiBG,IACjD,MAAMC,GAAU,EAAAlP,EAAA,GAAMP,GAEtB,OADAyP,EAAQvZ,KAAKsZ,GACNR,GAAwB7N,EAASqO,EAAarQ,EAAgBsQ,EAAQ,IAEjF,OAAOlQ,EAAO9H,OAAO8X,EACzB,CACJ,CACO,SAASL,GAAqBhd,GACjC,IAAIyJ,EAAS,GACb,IAAI,EAAAiF,EAAA,GAAQ1O,GACR,OAAOyJ,EAEX,MAAMiS,GAAY,OAAM1b,GAExB,GAAI0b,aAAqB,EACrBjS,EAAOzF,KAAK0X,EAAU1a,qBAErB,GAAI0a,aAAqBva,GAC1Bua,aAAqBra,GACrBqa,aAAqBpa,GACrBoa,aAAqBna,GACrBma,aAAqBja,GACrBia,aAAqBla,EACrBiI,EAASA,EAAOlE,OAAOyX,GAAqBtB,EAAU1b,kBAErD,GAAI0b,aAAqBha,EAE1B+H,GAAS,QAAQ,OAAIiS,EAAU1b,YAAawd,GAAeR,GAAqBQ,EAAWxd,oBAE1F,KAAI0b,aAAqB9Z,GAI1B,MAAMkB,MAAM,wBAEhB,MAAM2a,EAAkB9Z,EAAe+X,GACjCgC,EAAU1d,EAAWiH,OAAS,EACpC,GAAIwW,GAAmBC,EAAS,CAC5B,MAAMC,GAAO,EAAAlZ,EAAA,GAAKzE,GAClB,OAAOyJ,EAAOlE,OAAOyX,GAAqBW,GAC9C,CAEI,OAAOlU,CAEf,CACA,MAAMmU,WAAoB,EACtB,WAAAxd,GACIO,SAASob,WACT9b,KAAK4d,aAAe,EACxB,CACA,gBAAAta,CAAiBvB,GACb/B,KAAK4d,aAAa7Z,KAAKhC,EAC3B,EAEG,SAAS8b,GAA2BtT,EAAcyC,GACrD,MAAM8Q,EAAc,IAAIH,GACxBpT,EAAanK,OAAO0d,GACpB,MAAMC,EAAMD,EAAYF,aAClBxQ,GAAS,EAAAmN,GAAA,GAAQwD,GAAMC,IACzB,MAAMC,GAAa,EAAAtM,GAAA,GAAUqM,EAAOje,YACpC,OAAO,EAAAwa,GAAA,GAAQ0D,GAAY,CAACC,EAAiBnH,KACzC,MAAMoH,EAAqB3N,GAAwB,CAAC0N,GAAkB,GAAI,MAAwB,GAClG,OAAI,EAAAzP,EAAA,GAAQ0P,GACD,CACH,CACI3Q,QAASR,EAAeb,2BAA2B,CAC/C5B,aAAcA,EACdoB,YAAaqS,EACb5R,eAAgB2K,IAEpB7U,KAAMuL,GAA0B2Q,oBAChC3V,SAAU8B,EAAa5K,KACvB+L,WAAYsS,EAAOrd,IACnBmY,YAAa/B,EAAa,IAK3B,EACX,GACF,IAEN,OAAO3J,CACX,CACO,SAASiR,GAAyC9T,EAAc+T,EAAoBtR,GACvF,MAAM8Q,EAAc,IAAIH,GACxBpT,EAAanK,OAAO0d,GACpB,IAAIC,EAAMD,EAAYF,aAGtBG,GAAM,EAAAQ,GAAA,GAAOR,GAAMC,IAAwC,IAA7BA,EAAO7c,oBACrC,MAAMiM,GAAS,EAAAmN,GAAA,GAAQwD,GAAMC,IACzB,MAAMQ,EAAiBR,EAAOrd,IACxB8d,EAAqBT,EAAO5K,cAAgBkL,EAC5CnO,EAAeqD,GAAuBgL,EAAgBjU,EAAckU,EAAoBT,GACxFU,EAAsBC,GAA6BxO,EAAc6N,EAAQzT,EAAcyC,GACvF4R,EAA4BC,GAAmC1O,EAAc6N,EAAQzT,EAAcyC,GACzG,OAAO0R,EAAoBpZ,OAAOsZ,EAA0B,IAEhE,OAAOxR,CACX,CACO,MAAM0R,WAA4B,EACrC,WAAA3e,GACIO,SAASob,WACT9b,KAAKmb,eAAiB,EAC1B,CACA,4BAAA/X,CAA6B6Y,GACzBjc,KAAKmb,eAAepX,KAAKkY,EAC7B,CACA,wBAAA/Y,CAAyBgZ,GACrBlc,KAAKmb,eAAepX,KAAKmY,EAC7B,CACA,qCAAA/Y,CAAsCgZ,GAClCnc,KAAKmb,eAAepX,KAAKoY,EAC7B,CACA,eAAA9Y,CAAgB+Y,GACZpc,KAAKmb,eAAepX,KAAKqY,EAC7B,EAEG,SAASvB,GAAoBtQ,EAAcyC,GAC9C,MAAM8Q,EAAc,IAAIH,GACxBpT,EAAanK,OAAO0d,GACpB,MAAMC,EAAMD,EAAYF,aAClBxQ,GAAS,EAAAmN,GAAA,GAAQwD,GAAMC,GACrBA,EAAOje,WAAWiH,OAAS,IACpB,CACH,CACIwG,QAASR,EAAeX,8BAA8B,CAClD9B,aAAcA,EACdoB,YAAaqS,IAEjB9b,KAAMuL,GAA0BsR,cAChCtW,SAAU8B,EAAa5K,KACvB+L,WAAYsS,EAAOrd,MAKpB,KAGf,OAAOyM,CACX,CACO,SAAS4R,GAAkCC,EAAe7L,EAAcpG,GAC3E,MAAMI,EAAS,GAwBf,OAvBA,EAAA7M,EAAA,GAAQ0e,GAAgBC,IACpB,MAAMlE,EAAmB,IAAI8D,GAC7BI,EAAY9e,OAAO4a,GACnB,MAAME,EAAqBF,EAAiBG,gBAC5C,EAAA5a,EAAA,GAAQ2a,GAAqBiE,IACzB,MAAMtL,EAAWlB,GAAYwM,GACvBV,EAAqBU,EAAS/L,cAAgBA,EAC9CoL,EAAiBW,EAASxe,IAC1Bye,EAAQrL,GAAiCyK,EAAgBU,EAAarL,EAAU4K,GAChFY,EAAwBD,EAAM,GACpC,IAAI,EAAA3Q,EAAA,IAAQ,OAAQ4Q,IAAyB,CACzC,MAAMhU,EAAS2B,EAAehB,0BAA0B,CACpDzB,aAAc2U,EACdjT,WAAYkT,IAEhB/R,EAAOrJ,KAAK,CACRyJ,QAASnC,EACTnJ,KAAMuL,GAA0B6R,uBAChC7W,SAAUyW,EAAYvf,MAE9B,IACF,IAECyN,CACX,CACA,SAASuR,GAA6BxO,EAAcxE,EAAaP,EAAM4B,GACnE,MAAMuS,EAAsB,GACtBC,GAAuB,EAAAjW,EAAA,GAAO4G,GAAc,CAAC3G,EAAQ6G,EAAS0G,MAEH,IAAzDpL,EAAY5L,WAAWgX,GAAY5V,oBAGvC,EAAAZ,EAAA,GAAQ8P,GAAU1G,IACd,MAAM8V,EAAwB,CAAC1I,IAC/B,EAAAxW,EAAA,GAAQ4P,GAAc,CAACuP,EAAcC,KAC7B5I,IAAe4I,GACftH,GAAaqH,EAAc/V,KAEmC,IAA9DgC,EAAY5L,WAAW4f,GAAiBxe,mBACxCse,EAAsB1b,KAAK4b,EAC/B,IAEAF,EAAsBzY,OAAS,IAC9BqR,GAAakH,EAAqB5V,KACnC4V,EAAoBxb,KAAK4F,GACzBH,EAAOzF,KAAK,CACRkQ,KAAMwL,EACN5R,KAAMlE,IAEd,IAnBOH,IAsBZ,IACGoW,GAAa,OAAIJ,GAAuBK,IAC1C,MAAMC,GAAc,OAAID,EAAkB5L,MAAO8C,GAAeA,EAAa,IACvEhL,EAAciB,EAAenB,+BAA+B,CAC9DtB,aAAca,EACdO,YAAaA,EACbC,iBAAkBkU,EAClBtU,WAAYqU,EAAkBhS,OAElC,MAAO,CACHL,QAASzB,EACT7J,KAAMuL,GAA0BsS,eAChCtX,SAAU2C,EAAKzL,KACf+L,WAAYC,EAAYhL,IACxBwP,aAAc0P,EAAkB5L,KACnC,IAEL,OAAO2L,CACX,CACO,SAASf,GAAmC1O,EAAcxE,EAAaP,EAAM4B,GAEhF,MAAMgT,GAAkB,EAAAzW,EAAA,GAAO4G,GAAc,CAAC3G,EAAQ6G,EAAS1P,KAC3D,MAAMsf,GAAkB,OAAI5P,GAAU1G,IAC3B,CAAEhJ,IAAKA,EAAKkN,KAAMlE,MAE7B,OAAOH,EAAOlE,OAAO2a,EAAgB,GACtC,IACG7S,GAAS,EAAA8S,GAAA,IAAQ,EAAA3F,GAAA,GAAQyF,GAAkBG,IAC7C,MAAMC,EAAkBzU,EAAY5L,WAAWogB,EAAexf,KAE9D,IAA0C,IAAtCyf,EAAgBjf,kBAChB,MAAO,GAEX,MAAMkf,EAAYF,EAAexf,IAC3B2f,EAAaH,EAAetS,KAC5B0S,GAAmC,EAAAC,GAAA,GAAOR,GAAkBS,IAK1D,IADJ9U,EAAY5L,WAAW0gB,EAAiB9f,KAAKQ,mBAEzCsf,EAAiB9f,IAAM0f,GAGvB/G,GAAqBmH,EAAiB5S,KAAMyS,KAE9CI,GAAuB,OAAIH,GAAmCI,IAChE,MAAMb,EAAc,CAACa,EAAkBhgB,IAAM,EAAG0f,EAAY,GACtD3U,EAAiC,IAApBC,EAAYhL,IAAY,GAAKgL,EAAYhL,IACtD6M,EAAUR,EAAe1B,qCAAqC,CAChEf,aAAca,EACdO,YAAaA,EACbC,iBAAkBkU,EAClBtU,WAAYmV,EAAkB9S,OAElC,MAAO,CACHL,QAASA,EACTtL,KAAMuL,GAA0BmT,sBAChCnY,SAAU2C,EAAKzL,KACf+L,WAAYA,EACZyE,aAAc2P,EACjB,IAEL,OAAOY,CAAoB,KAE/B,OAAOtT,CACX,CACA,SAASsN,GAAuC3N,EAAWkN,EAAYjN,GACnE,MAAMI,EAAS,GACTyT,GAAa,OAAI5G,GAAa6G,GAAcA,EAAUnhB,OAY5D,OAXA,EAAAY,EAAA,GAAQwM,GAAYN,IAChB,MAAMsU,EAAetU,EAAS9M,KAC9B,IAAI,EAAAmE,EAAA,GAAS+c,EAAYE,GAAe,CACpC,MAAM1V,EAAS2B,EAAe7B,4BAA4BsB,GAC1DW,EAAOrJ,KAAK,CACRyJ,QAASnC,EACTnJ,KAAMuL,GAA0BuT,gCAChCvY,SAAUsY,GAElB,KAEG3T,CACX,CC7aO,SAAS,GAAe3M,GAC3B,MAAMwgB,GAAgB,EAAAC,GAAA,GAASzgB,EAAS,CACpCuM,eAAgB3C,KAEd8W,EAAgB,CAAC,EAIvB,OAHA,EAAA5gB,EAAA,GAAQE,EAAQuZ,OAAQ5O,IACpB+V,EAAc/V,EAAKzL,MAAQyL,CAAI,IAE5B,GAAkB+V,EAAeF,EAAcjU,eAC1D,CACO,SAAS,GAAgBvM,GAI5B,OAHAA,GAAU,EAAAygB,GAAA,GAASzgB,EAAS,CACxBuM,eAAgBvC,KAEb,GAAmBhK,EAAQuZ,MAAOvZ,EAAQwZ,WAAYxZ,EAAQuM,eAAgBvM,EAAQoM,YACjG,C,eClBA,MAAMuU,GAA6B,2BAC7BC,GAA0B,uBAC1BC,GAAuB,qBACvBC,GAAiC,6BACjCC,GAA8B,CAChCJ,GACAC,GACAC,GACAC,IAIG,SAASE,GAAuBC,GAEnC,OAAO,EAAA5d,EAAA,GAAS0d,GAA6BE,EAAM/hB,KACvD,CALAwK,OAAOC,OAAOoX,IAMd,MAAMG,WAA6B9e,MAC/B,WAAA1C,CAAYqN,EAASyB,GACjBvO,MAAM8M,GACNxN,KAAKiP,MAAQA,EACbjP,KAAK4hB,eAAiB,GAEtBzX,OAAO0X,eAAe7hB,gBAAiB8hB,WAEnCjf,MAAMkf,mBACNlf,MAAMkf,kBAAkB/hB,KAAMA,KAAKG,YAE3C,EAEG,MAAM6hB,WAAiCL,GAC1C,WAAAxhB,CAAYqN,EAASyB,EAAOgT,GACxBvhB,MAAM8M,EAASyB,GACfjP,KAAKiiB,cAAgBA,EACrBjiB,KAAKL,KAAOyhB,EAChB,EAEG,MAAMc,WAA6BP,GACtC,WAAAxhB,CAAYqN,EAASyB,EAAOgT,GACxBvhB,MAAM8M,EAASyB,GACfjP,KAAKiiB,cAAgBA,EACrBjiB,KAAKL,KAAO0hB,EAChB,EAEG,MAAMc,WAAmCR,GAC5C,WAAAxhB,CAAYqN,EAASyB,GACjBvO,MAAM8M,EAASyB,GACfjP,KAAKL,KAAO4hB,EAChB,EAEG,MAAMa,WAA2BT,GACpC,WAAAxhB,CAAYqN,EAASyB,EAAOgT,GACxBvhB,MAAM8M,EAASyB,GACfjP,KAAKiiB,cAAgBA,EACrBjiB,KAAKL,KAAO2hB,EAChB,EClDG,MAAMe,GAAiB,CAAC,EAClBC,GAA6B,0BACnC,MAAMC,WAAgC1f,MACzC,WAAA1C,CAAYqN,GACR9M,MAAM8M,GACNxN,KAAKL,KAAO2iB,EAChB,EAKG,MAAME,GACT,eAAAC,CAAgBC,GACZ1iB,KAAK2iB,iBAAmB,CAAC,EACzB3iB,KAAK4iB,cAAgB,CAAC,EACtB5iB,KAAK6iB,iBAAkB,EAAA3N,EAAA,GAAIwN,EAAQ,mBAC7BA,EAAOG,gBACPC,GAAsBD,gBAIxB7iB,KAAK6iB,kBACL7iB,KAAK+iB,4BAA8BA,GAE3C,CACA,gBAAAC,CAAiBxjB,GACb,MAAMyjB,GAAc,QAAoBzjB,EAAS,GAAI0jB,IAAKA,IAAKA,IAAKA,IAAKA,IAAKA,KAE9E,OADAD,EAAYE,sBAAuB,EAC5BF,CACX,CACA,gCAAAG,CAAiC5jB,GAC7B,OAAO,CACX,CACA,+BAAA6jB,CAAgC7jB,GAC5B,OAAO,CACX,CACA,uBAAA8jB,CAAwBC,EAAaC,EAAiBC,EAAeC,GAEjE,MAAMC,EAAgB3jB,KAAK4jB,sBACrBC,EAAkB7jB,KAAK8jB,mBACvBlC,EAAiB,GACvB,IAAImC,GAAoB,EACxB,MAAMC,EAAyBhkB,KAAK8U,GAAG,GACvC,IAAIgM,EAAY9gB,KAAK8U,GAAG,GACxB,MAAMmP,EAAuB,KACzB,MAAMhC,EAAgBjiB,KAAK8U,GAAG,GAGxBlM,EAAM5I,KAAKkkB,qBAAqB7b,0BAA0B,CAC5DC,SAAUob,EACVnb,OAAQyb,EACRxb,SAAUyZ,EACVxZ,SAAUzI,KAAKmkB,wBAEbzC,EAAQ,IAAIM,GAAyBpZ,EAAKob,EAAwBhkB,KAAK8U,GAAG,IAEhF4M,EAAME,gBAAiB,EAAAjQ,GAAA,GAAUiQ,GACjC5hB,KAAKokB,WAAW1C,EAAM,EAE1B,OAAQqC,EAAmB,CAEvB,GAAI/jB,KAAKyT,aAAaqN,EAAW4C,GAE7B,YADAO,IAGC,GAAIR,EAAc/O,KAAK1U,MAKxB,OAHAikB,SAEAV,EAAYc,MAAMrkB,KAAMwjB,GAGnBxjB,KAAKyT,aAAaqN,EAAW6C,GAClCI,GAAoB,GAGpBjD,EAAY9gB,KAAKskB,aACjBtkB,KAAKukB,kBAAkBzD,EAAWc,GAE1C,CAIA5hB,KAAKwkB,iBAAiBX,EAC1B,CACA,iCAAAY,CAAkCC,EAAyBC,EAAYC,GAGnE,OAAiB,IAAbA,KAIA5kB,KAAKyT,aAAazT,KAAK8U,GAAG,GAAI4P,MAK9B1kB,KAAK6kB,mBAML7kB,KAAK8kB,yBAAyBJ,EAAyB1kB,KAAK+kB,4BAA4BL,EAAyBC,KAIzH,CAEA,2BAAAI,CAA4BvlB,EAASwlB,GACjC,MAAMC,EAAcjlB,KAAKklB,sBAAsB1lB,EAASwlB,GAClDzd,EAAUvH,KAAKmlB,0BAA0BF,GAC/C,OAAO1d,CACX,CACA,iBAAA6d,CAAkB1B,EAAiBnc,GAC/B,GAAIvH,KAAKqlB,mCAAmC3B,EAAiBnc,GAAU,CACnE,MAAM0b,EAAcjjB,KAAKgjB,iBAAiBU,GAC1C,OAAOT,CACX,CACA,GAAIjjB,KAAKslB,kCAAkC5B,GAAkB,CACzD,MAAM6B,EAAUvlB,KAAKskB,aAErB,OADAtkB,KAAKwlB,eACED,CACX,CACA,MAAM,IAAIhD,GAAwB,gBACtC,CACA,wBAAAuC,CAAyBW,EAAele,GACpC,OAAQvH,KAAKqlB,mCAAmCI,EAAele,IAC3DvH,KAAKslB,kCAAkCG,EAC/C,CACA,kCAAAJ,CAAmC3B,EAAiBnc,GAChD,IAAKvH,KAAKojB,iCAAiCM,GACvC,OAAO,EAGX,IAAI,EAAAjV,EAAA,GAAQlH,GACR,OAAO,EAEX,MAAMme,EAAgB1lB,KAAK8U,GAAG,GACxB6Q,OAEC7kB,KAF0B,EAAA8kB,GAAA,GAAKre,GAAUse,GACrC7lB,KAAKyT,aAAaiS,EAAeG,KAE5C,OAAOF,CACX,CACA,iCAAAL,CAAkC5B,GAC9B,IAAK1jB,KAAKqjB,gCAAgCK,GACtC,OAAO,EAEX,MAAMoC,EAA4B9lB,KAAKyT,aAAazT,KAAK8U,GAAG,GAAI4O,GAChE,OAAOoC,CACX,CACA,wBAAAC,CAAyB5Q,GACrB,MAAM6Q,EAAYhmB,KAAKimB,mBACjBC,EAAuBlmB,KAAKmmB,0BAA0BH,GAC5D,OAAO,EAAAliB,EAAA,GAASoiB,EAAsB/Q,EAC1C,CACA,mBAAAyO,GACI,MAAMwC,EAA4BpmB,KAAKqmB,mBAEvC,IAAIxR,EAAY7U,KAAK8U,GAAG,GACpBlB,EAAI,EACR,MAAO,EAAM,CACT,MAAM0S,GAAa,EAAAV,GAAA,GAAKQ,GAA4BG,IAChD,MAAMC,GAAW,OAAa3R,EAAW0R,GACzC,OAAOC,CAAQ,IAEnB,QAAmB1lB,IAAfwlB,EACA,OAAOA,EAEXzR,EAAY7U,KAAK8U,GAAGlB,GACpBA,GACJ,CACJ,CACA,gBAAAqS,GAEI,GAA+B,IAA3BjmB,KAAKymB,WAAWzf,OAChB,OAAOqb,GAEX,MAAMqE,EAAoB1mB,KAAK2mB,+BACzBC,EAAc5mB,KAAK6mB,qCACnBC,EAAoB9mB,KAAK+mB,mCAC/B,MAAO,CACHte,SAAUzI,KAAKgnB,wBAAwBN,GACvCO,iBAAkBL,EAClBM,OAAQlnB,KAAKgnB,wBAAwBF,GAE7C,CACA,uBAAAK,GACI,MAAMC,EAAoBpnB,KAAKymB,WACzBY,EAA0BrnB,KAAKsnB,sBACrC,OAAO,OAAIF,GAAmB,CAAC3e,EAAU9H,IACzB,IAARA,EACO0hB,GAEJ,CACH5Z,SAAUzI,KAAKgnB,wBAAwBve,GACvCwe,iBAAkBI,EAAwB1mB,GAC1CumB,OAAQlnB,KAAKgnB,wBAAwBI,EAAkBzmB,EAAM,MAGzE,CACA,gBAAA0lB,GACI,MAAMkB,GAAc,OAAIvnB,KAAKmnB,2BAA4BzP,GAC9C1X,KAAKmmB,0BAA0BzO,KAE1C,OAAO,OAAQ6P,EACnB,CACA,yBAAApB,CAA0BH,GACtB,GAAIA,IAAc3D,GACd,MAAO,CAAC,MAEZ,MAAM5a,EAAaue,EAAUvd,SAAWud,EAAUiB,iBAAmB,EAAKjB,EAAUkB,OACpF,OAAOlnB,KAAK4iB,cAAcnb,EAC9B,CAGA,iBAAA8c,CAAkBtV,EAAOuY,GAIrB,OAHKxnB,KAAKyT,aAAaxE,EAAO,OAC1BuY,EAAazjB,KAAKkL,GAEfuY,CACX,CACA,QAAAC,CAASjoB,GACL,MAAMoiB,EAAiB,GACvB,IAAI2D,EAAUvlB,KAAK8U,GAAG,GACtB,OAA+C,IAAxC9U,KAAKyT,aAAa8R,EAAS/lB,GAC9B+lB,EAAUvlB,KAAKskB,aACftkB,KAAKukB,kBAAkBgB,EAAS3D,GAGpC,OAAO,EAAAjQ,GAAA,GAAUiQ,EACrB,CACA,2BAAAmB,CAA4B2E,EAAUC,EAAMC,EAAeC,EAAcC,EAAgBC,EAAgBnD,GAGzG,CACA,qBAAAM,CAAsB1lB,EAASwlB,GAC3B,MAAMgD,EAAgBhoB,KAAKioB,4BACrBC,GAAsB,EAAA9Z,EAAA,GAAMpO,KAAKsnB,uBACjCrC,EAAc,CAChB9W,UAAW6Z,EACX1Z,gBAAiB4Z,EACjBrZ,QAASrP,EACTsP,kBAAmBkW,GAEvB,OAAOC,CACX,CACA,yBAAAgD,GACI,OAAO,OAAIjoB,KAAKymB,YAAa0B,GAAkBnoB,KAAKgnB,wBAAwBmB,IAChF,EAEG,SAASpF,GAA4B2E,EAAUC,EAAMC,EAAeC,EAAcC,EAAgBC,EAAgBnD,GACrH,MAAMrM,EAAMvY,KAAKooB,4BAA4BP,EAAcC,GAC3D,IAAIO,EAAoBroB,KAAK2iB,iBAAiBpK,GAC9C,QAA0BzX,IAAtBunB,EAAiC,CACjC,MAAMtH,EAAe/gB,KAAKmkB,sBACpBhR,EAAcnT,KAAKsoB,qBAAqBvH,GACxCwH,EAAS,IAAIR,EAAe5U,EAAa2U,GAC/CO,EAAoBE,EAAO/gB,eAC3BxH,KAAK2iB,iBAAiBpK,GAAO8P,CACjC,CACA,IAAI3D,EAA0B2D,EAAkBpZ,MAC5C0V,EAAa0D,EAAkB3c,WACnC,MAAMwD,EAAcmZ,EAAkBnZ,YAGP,IAA3BlP,KAAKymB,WAAWzf,QAChBkI,QAC4BpO,IAA5B4jB,IACAA,EAA0B,KAC1BC,EAAa,QAIe7jB,IAA5B4jB,QAAwD5jB,IAAf6jB,GAGzC3kB,KAAKykB,kCAAkCC,EAAyBC,EAAYC,IAI5E5kB,KAAKsjB,wBAAwBoE,EAAUC,EAAMC,EAAelD,EAEpE,CC1RO,MAAM8D,GAAuB,EACvBC,GAA0B,EAO1BC,GAAS,GAAKD,GACdE,GAAa,GAAKF,GAClBG,GAAW,GAAKH,GAChBI,GAAmB,GAAKJ,GACxBK,GAAe,GAAKL,GACpBM,GAAuB,GAAKN,GAElC,SAASL,GAA4BY,EAASnB,EAAcnc,GAC/D,OAAOA,EAAamc,EAAemB,CACvC,CClBO,MAAMC,GACT,WAAA9oB,CAAYM,GACR,IAAIyoB,EACJlpB,KAAKoT,aACiF,QAAjF8V,EAAiB,OAAZzoB,QAAgC,IAAZA,OAAqB,EAASA,EAAQ2S,oBAAiC,IAAP8V,EAAgBA,EAAKpG,GAAsB1P,YAC7I,CACA,QAAA2G,CAAStZ,GACL,MAAM0oB,EAAsBnpB,KAAK6c,wBAAwBpc,EAAQuZ,OACjE,IAAI,EAAAvL,EAAA,GAAQ0a,GAAsB,CAC9B,MAAMC,EAAiBppB,KAAKqpB,4BAA4B5oB,EAAQuZ,OAC1DsP,EAAsBtpB,KAAKqe,yCAAyC5d,EAAQuZ,MAAOha,KAAKoT,cACxFmW,EAAwBvpB,KAAKgf,kCAAkCve,EAAQuZ,MAAOha,KAAKoT,cACnFoW,EAAY,IACXL,KACAC,KACAE,KACAC,GAEP,OAAOC,CACX,CACA,OAAOL,CACX,CACA,uBAAAtM,CAAwB7C,GACpB,OAAO,EAAAO,GAAA,GAAQP,GAAQkF,GAAgBrC,GAAwBqC,EAAaA,EAAazU,KAC7F,CACA,2BAAA4e,CAA4BrP,GACxB,OAAO,EAAAO,GAAA,GAAQP,GAAQkF,GAAgBrB,GAA2BqB,EAAazU,KACnF,CACA,wCAAA4T,CAAyCrE,EAAO5G,GAC5C,OAAO,EAAAmH,GAAA,GAAQP,GAAQkF,GAAgBb,GAAyCa,EAAa9L,EAAc3I,KAC/G,CACA,iCAAAuU,CAAkChF,EAAO5G,GACrC,OAAO4L,GAAkChF,EAAO5G,EAAc3I,GAClE,CACA,4BAAAgf,CAA6BhpB,GACzB,OAAOyS,GAAwBzS,EAAQqnB,eAAgBrnB,EAAQ2K,KAAM3K,EAAQ2S,aAAc3S,EAAQiB,cAAejB,EAAQ4S,qBAAsBW,GACpJ,CACA,yBAAA0V,CAA0BjpB,GACtB,OAAOkT,GAAkClT,EAAQqnB,eAAgBrnB,EAAQ2K,KAAM3K,EAAQ2S,aAAc3S,EAAQ4S,qBAAsBV,GAAYlS,EAAQoT,UAAWyB,GACtK,ECpCG,MAAMqU,GACT,cAAAC,CAAelH,GACX1iB,KAAKqT,sBAAuB,EAAA6B,EAAA,GAAIwN,EAAQ,wBAClCA,EAAOrP,qBACPyP,GAAsBzP,qBAC5BrT,KAAKoT,cAAe,EAAA8B,EAAA,GAAIwN,EAAQ,gBAC1BA,EAAOtP,aACP0P,GAAsB1P,aAC5BpT,KAAK8Z,mBAAoB,EAAA5E,EAAA,GAAIwN,EAAQ,qBAC/BA,EAAO5I,kBACP,IAAImP,GAAqB,CAAE7V,aAAcpT,KAAKoT,eACpDpT,KAAK6pB,oBAAsB,IAAIC,GACnC,CACA,4BAAAC,CAA6B/P,IACzB,EAAAzZ,EAAA,GAAQyZ,GAAQvN,IACZzM,KAAKgqB,WAAW,GAAGvd,EAAS9M,uBAAuB,KAC/C,MAAM,YAAEgM,EAAW,WAAEM,EAAU,OAAE+P,EAAM,oBAAEiO,EAAmB,iCAAEC,EAAgC,wBAAEC,GAA6BC,GAAe3d,IAC5I,EAAAlM,EAAA,GAAQoL,GAAcwT,IAClB,MAAMkL,EAA2B,IAAjBlL,EAASxe,IAAY,GAAKwe,EAASxe,IACnDX,KAAKgqB,WAAW,GAAG9lB,EAAqBib,KAAYkL,KAAW,KAC3D,MAAMC,EAAStqB,KAAK8Z,kBAAkB2P,6BAA6B,CAC/D3B,eAAgB3I,EAASxe,IACzByK,KAAMqB,EACN2G,aAAc+L,EAAS/L,cAAgBpT,KAAKoT,aAC5C1R,cAAeyd,EAASzd,cACxB2R,qBAAsBrT,KAAKqT,uBAEzBkF,EAAM6P,GAA4BpoB,KAAKuqB,oBAAoB9d,EAAS9M,MAAO+oB,GAAQvJ,EAASxe,KAClGX,KAAKwqB,eAAejS,EAAK+R,EAAO,GAClC,KAEN,EAAA/pB,EAAA,GAAQ0L,GAAakT,IACjBnf,KAAKyqB,qBAAqBhe,EAAU0S,EAASxe,IAAKioB,GAAU,aAAczJ,EAAS/L,aAAclP,EAAqBib,GAAU,KAEpI,EAAA5e,EAAA,GAAQyb,GAASmD,IACbnf,KAAKyqB,qBAAqBhe,EAAU0S,EAASxe,IAAKgoB,GAAY,SAAUxJ,EAAS/L,aAAclP,EAAqBib,GAAU,KAElI,EAAA5e,EAAA,GAAQ0pB,GAAsB9K,IAC1Bnf,KAAKyqB,qBAAqBhe,EAAU0S,EAASxe,IAAKkoB,GAAkB,sBAAuB1J,EAAS/L,aAAclP,EAAqBib,GAAU,KAErJ,EAAA5e,EAAA,GAAQ2pB,GAAmC/K,IACvCnf,KAAKyqB,qBAAqBhe,EAAU0S,EAASxe,IAAKooB,GAAsB,mCAAoC5J,EAAS/L,aAAclP,EAAqBib,GAAU,KAEtK,EAAA5e,EAAA,GAAQ4pB,GAA0BhL,IAC9Bnf,KAAKyqB,qBAAqBhe,EAAU0S,EAASxe,IAAKmoB,GAAc,0BAA2B3J,EAAS/L,aAAclP,EAAqBib,GAAU,GACnJ,GACJ,GAEV,CACA,oBAAAsL,CAAqBrf,EAAM0c,EAAgB4C,EAAS7W,EAAU8W,EAAkBC,GAC5E5qB,KAAKgqB,WAAW,GAAGY,IAAmC,IAAnB9C,EAAuB,GAAKA,KAAkB,KAC7E,MAAMwC,EAAStqB,KAAK8Z,kBAAkB4P,0BAA0B,CAC5D5B,iBACA1c,OACAgI,aAAcuX,GAAoB3qB,KAAKoT,aACvCC,qBAAsBrT,KAAKqT,qBAC3BQ,aAEE0E,EAAM6P,GAA4BpoB,KAAKuqB,oBAAoBnf,EAAKzL,MAAO+qB,EAAS5C,GACtF9nB,KAAKwqB,eAAejS,EAAK+R,EAAO,GAExC,CAEA,2BAAAlC,CAA4BP,EAAcnc,GACtC,MAAMgb,EAAoB1mB,KAAK2mB,+BAC/B,OAAOyB,GAA4B1B,EAAmBmB,EAAcnc,EACxE,CACA,kBAAAmf,CAAmBtS,GACf,OAAOvY,KAAK6pB,oBAAoBiB,IAAIvS,EACxC,CAEA,cAAAiS,CAAejS,EAAKrY,GAChBF,KAAK6pB,oBAAoBkB,IAAIxS,EAAKrY,EACtC,EAEJ,MAAM8qB,WAAmC,EACrC,WAAA7qB,GACIO,SAASob,WACT9b,KAAKirB,WAAa,CACdjP,OAAQ,GACRrQ,YAAa,GACbM,WAAY,GACZke,wBAAyB,GACzBF,oBAAqB,GACrBC,iCAAkC,GAE1C,CACA,KAAAgB,GACIlrB,KAAKirB,WAAa,CACdjP,OAAQ,GACRrQ,YAAa,GACbM,WAAY,GACZke,wBAAyB,GACzBF,oBAAqB,GACrBC,iCAAkC,GAE1C,CACA,WAAAjnB,CAAY+Y,GACRhc,KAAKirB,WAAWjP,OAAOjY,KAAKiY,EAChC,CACA,4BAAA5Y,CAA6B6Y,GACzBjc,KAAKirB,WAAWd,wBAAwBpmB,KAAKkY,EACjD,CACA,wBAAA/Y,CAAyBgZ,GACrBlc,KAAKirB,WAAWhB,oBAAoBlmB,KAAKmY,EAC7C,CACA,qCAAA/Y,CAAsCgZ,GAClCnc,KAAKirB,WAAWf,iCAAiCnmB,KAAKoY,EAC1D,CACA,eAAA9Y,CAAgB+Y,GACZpc,KAAKirB,WAAWhf,WAAWlI,KAAKqY,EACpC,CACA,gBAAA9Y,CAAiB+Y,GACbrc,KAAKirB,WAAWtf,YAAY5H,KAAKsY,EACrC,EAEJ,MAAMrB,GAAmB,IAAIgQ,GACtB,SAASZ,GAAehf,GAC3B4P,GAAiBkQ,QACjB9f,EAAKhL,OAAO4a,IACZ,MAAMiQ,EAAajQ,GAAiBiQ,WAGpC,OADAjQ,GAAiBkQ,QACVD,CACX,CC7HO,SAASE,GAA0BC,EAAkBC,IAEZ,IAAxCC,MAAMF,EAAiBG,cAIvBH,EAAiBG,YAAcF,EAAgBE,YAC/CH,EAAiBI,UAAYH,EAAgBG,WAMxCJ,EAAiBI,UAAYH,EAAgBG,aAAc,IAChEJ,EAAiBI,UAAYH,EAAgBG,UAErD,CAQO,SAASC,GAAoBL,EAAkBC,IAEN,IAAxCC,MAAMF,EAAiBG,cAIvBH,EAAiBG,YAAcF,EAAgBE,YAC/CH,EAAiBM,YAAcL,EAAgBK,YAC/CN,EAAiBO,UAAYN,EAAgBM,UAC7CP,EAAiBI,UAAYH,EAAgBG,UAC7CJ,EAAiBQ,UAAYP,EAAgBO,UAC7CR,EAAiBS,QAAUR,EAAgBQ,SAMtCT,EAAiBI,UAAYH,EAAgBG,aAAc,IAChEJ,EAAiBI,UAAYH,EAAgBG,UAC7CJ,EAAiBQ,UAAYP,EAAgBO,UAC7CR,EAAiBS,QAAUR,EAAgBQ,QAEnD,CACO,SAASC,GAAiB/pB,EAAMkN,EAAO8c,QACLjrB,IAAjCiB,EAAKiqB,SAASD,GACdhqB,EAAKiqB,SAASD,GAAiB,CAAC9c,GAGhClN,EAAKiqB,SAASD,GAAehoB,KAAKkL,EAE1C,CACO,SAASgd,GAAqBlqB,EAAM0G,EAAUyjB,QACjBprB,IAA5BiB,EAAKiqB,SAASvjB,GACd1G,EAAKiqB,SAASvjB,GAAY,CAACyjB,GAG3BnqB,EAAKiqB,SAASvjB,GAAU1E,KAAKmoB,EAErC,C,2DCrEA,MAAMC,GAAO,OACN,SAASC,GAAexsB,EAAKysB,GAChCliB,OAAOmiB,eAAe1sB,EAAKusB,GAAM,CAC7BI,YAAY,EACZC,cAAc,EACdC,UAAU,EACVvsB,MAAOmsB,GAEf,CCNO,SAASK,GAAaC,EAAK/Q,GAC9B,MAAMgR,GAAgB,EAAApW,GAAA,GAAKmW,GACrBE,EAAsBD,EAAc5lB,OAC1C,IAAK,IAAI+I,EAAI,EAAGA,EAAI8c,EAAqB9c,IAAK,CAC1C,MAAM+c,EAAgBF,EAAc7c,GAC9Bgd,EAAiBJ,EAAIG,GACrBE,EAAuBD,EAAe/lB,OAC5C,IAAK,IAAI2N,EAAI,EAAGA,EAAIqY,EAAsBrY,IAAK,CAC3C,MAAMsY,EAAYF,EAAepY,QAEF7T,IAA3BmsB,EAAU9X,cACVnV,KAAKitB,EAAUttB,MAAMstB,EAAUjB,SAAUpQ,EAEjD,CACJ,CAEJ,CACO,SAASsR,GAAqCrgB,EAAasgB,GAC9D,MAAMC,EAAqB,WAAc,EAIzChB,GAAegB,EAAoBvgB,EAAc,iBACjD,MAAMwgB,EAAgB,CAClB/sB,MAAO,SAAUgtB,EAAS1R,GAQtB,IANI,EAAA2R,GAAA,GAAQD,KAGRA,EAAUA,EAAQ,MAGlB,EAAAE,GAAA,GAAYF,GAGhB,OAAOttB,KAAKstB,EAAQ3tB,MAAM2tB,EAAQtB,SAAUpQ,EAChD,EACA6R,gBAAiB,WACb,MAAMC,EAA2BD,GAAgBztB,KAAMmtB,GACvD,KAAK,EAAA1e,EAAA,GAAQif,GAA2B,CACpC,MAAMC,GAAgB,OAAID,GAA2BE,GAAiBA,EAAahlB,MACnF,MAAM/F,MAAM,mCAAmC7C,KAAKG,YAAYR,aACzDguB,EAAc9jB,KAAK,QAAQqB,QAAQ,MAAO,UACrD,CACJ,GAKJ,OAHAkiB,EAAmBtL,UAAYuL,EAC/BD,EAAmBtL,UAAU3hB,YAAcitB,EAC3CA,EAAmBS,YAAcV,EAC1BC,CACX,CACO,SAASU,GAAyCjhB,EAAasgB,EAAWY,GAC7E,MAAMX,EAAqB,WAAc,EAIzChB,GAAegB,EAAoBvgB,EAAc,6BACjD,MAAMmhB,EAAoB7jB,OAAO8jB,OAAOF,EAAgBjM,WAMxD,OALA,EAAAvhB,EAAA,GAAQ4sB,GAAY1kB,IAChBulB,EAAkBvlB,GAAYikB,EAAY,IAE9CU,EAAmBtL,UAAYkM,EAC/BZ,EAAmBtL,UAAU3hB,YAAcitB,EACpCA,CACX,CACO,IAAIc,GAKJ,SAAST,GAAgBU,EAAiBhB,GAC7C,MAAMiB,EAAgBC,GAA0BF,EAAiBhB,GACjE,OAAOiB,CACX,CACO,SAASC,GAA0BF,EAAiBhB,GACvD,MAAMmB,GAAmB,EAAA9N,GAAA,GAAO2M,GAAYpM,IACa,KAA9C,EAAAwN,GAAA,GAAWJ,EAAgBpN,MAEhC3T,GAAS,OAAIkhB,GAAmBvN,IAC3B,CACHnY,IAAK,4BAA4BmY,SAAqBoN,EAAgBhuB,YAAgB,oBACtF+B,KAAMgsB,GAA0BM,eAChCC,WAAY1N,MAGpB,OAAO,EAAAb,GAAA,GAAQ9S,EACnB,EApBA,SAAW8gB,GACPA,EAA0BA,EAA0B,oBAAsB,GAAK,mBAC/EA,EAA0BA,EAA0B,kBAAoB,GAAK,gBAChF,EAHD,CAGGA,KAA8BA,GAA4B,CAAC,IChEvD,MAAMQ,GACT,eAAAC,CAAgBjM,GAOZ,GANA1iB,KAAK4uB,UAAY,GAEjB5uB,KAAK6uB,UAAYnM,EAAOmM,UACxB7uB,KAAK8uB,sBAAuB,EAAA5Z,EAAA,GAAIwN,EAAQ,wBAClCA,EAAOoM,qBACPhM,GAAsBgM,qBACvB9uB,KAAK6uB,UAQN,GAAI,QAAQE,KAAK/uB,KAAK8uB,sBACd9uB,KAAK6iB,iBACL7iB,KAAKgvB,yBAA2BvD,GAChCzrB,KAAKivB,wBAA0BxD,GAC/BzrB,KAAKkvB,YAAcC,GAAA,EACnBnvB,KAAKovB,uBAAyBpvB,KAAKqvB,qCAGnCrvB,KAAKgvB,yBAA2BG,GAAA,EAChCnvB,KAAKivB,wBAA0BE,GAAA,EAC/BnvB,KAAKkvB,YAAclvB,KAAKsvB,gBACxBtvB,KAAKovB,uBAAyBpvB,KAAKuvB,wCAGtC,GAAI,cAAcR,KAAK/uB,KAAK8uB,sBACzB9uB,KAAK6iB,iBACL7iB,KAAKgvB,yBAA2B7D,GAChCnrB,KAAKivB,wBAA0B9D,GAC/BnrB,KAAKkvB,YAAcC,GAAA,EACnBnvB,KAAKovB,uBACDpvB,KAAKwvB,2CAGTxvB,KAAKgvB,yBAA2BG,GAAA,EAChCnvB,KAAKivB,wBAA0BE,GAAA,EAC/BnvB,KAAKkvB,YAAclvB,KAAKyvB,sBACxBzvB,KAAKovB,uBACDpvB,KAAK0vB,6CAGZ,KAAI,QAAQX,KAAK/uB,KAAK8uB,sBAOvB,MAAMjsB,MAAM,kDAAkD6f,EAAOoM,yBANrE9uB,KAAKgvB,yBAA2BG,GAAA,EAChCnvB,KAAKivB,wBAA0BE,GAAA,EAC/BnvB,KAAKkvB,YAAcC,GAAA,EACnBnvB,KAAKovB,uBAAyBD,GAAA,CAIlC,MA7CAnvB,KAAK2vB,yBAA2BR,GAAA,EAChCnvB,KAAK4vB,sBAAwBT,GAAA,EAC7BnvB,KAAK6vB,gBAAkBV,GAAA,EACvBnvB,KAAK8vB,mBAAqBX,GAAA,EAC1BnvB,KAAKkvB,YAAcC,GAAA,CA2C3B,CACA,wCAAAK,CAAyClC,GACrCA,EAAQyC,SAAW,CACfxE,YAAarI,IACbsI,UAAWtI,IAEnB,CACA,uCAAAwM,CAAwCpC,GACpCA,EAAQyC,SAAW,CAKfxE,YAAavrB,KAAK8U,GAAG,GAAGyW,YACxBC,UAAWtI,IAEnB,CACA,kCAAAmM,CAAmC/B,GAC/BA,EAAQyC,SAAW,CACfxE,YAAarI,IACbyI,UAAWzI,IACXwI,YAAaxI,IACbsI,UAAWtI,IACX2I,QAAS3I,IACT0I,UAAW1I,IAEnB,CAMA,iCAAAqM,CAAkCjC,GAC9B,MAAMzY,EAAY7U,KAAK8U,GAAG,GAC1BwY,EAAQyC,SAAW,CACfxE,YAAa1W,EAAU0W,YACvBI,UAAW9W,EAAU8W,UACrBD,YAAa7W,EAAU6W,YACvBF,UAAWtI,IACX2I,QAAS3I,IACT0I,UAAW1I,IAEnB,CACA,wBAAAyM,CAAyBK,GACrB,MAAM1C,EAAU,CACZ3tB,KAAMqwB,EACNhE,SAAU7hB,OAAO8jB,OAAO,OAE5BjuB,KAAKovB,uBAAuB9B,GAC5BttB,KAAK4uB,UAAU7qB,KAAKupB,EACxB,CACA,qBAAAsC,GACI5vB,KAAK4uB,UAAUrgB,KACnB,CACA,eAAA+gB,CAAgBW,GAEZ,MAAMC,EAAYlwB,KAAK8U,GAAG,GACpBqb,EAAMF,EAAYF,SAGpBI,EAAI5E,aAAe2E,EAAU3E,eAAgB,GAC7C4E,EAAI3E,UAAY0E,EAAU1E,UAC1B2E,EAAItE,QAAUqE,EAAUrE,QACxBsE,EAAIvE,UAAYsE,EAAUtE,YAI1BuE,EAAI5E,YAAcrI,IAClBiN,EAAIxE,UAAYzI,IAChBiN,EAAIzE,YAAcxI,IAE1B,CACA,qBAAAuM,CAAsBQ,GAClB,MAAMC,EAAYlwB,KAAK8U,GAAG,GAEpBqb,EAAMF,EAAYF,SAGpBI,EAAI5E,aAAe2E,EAAU3E,eAAgB,EAC7C4E,EAAI3E,UAAY0E,EAAU1E,UAI1B2E,EAAI5E,YAAcrI,GAE1B,CACA,eAAA2M,CAAgBtX,EAAK6X,GACjB,MAAMC,EAAUrwB,KAAK4uB,UAAU5uB,KAAK4uB,UAAU5nB,OAAS,GACvD8kB,GAAiBuE,EAASD,EAAe7X,GAEzCvY,KAAKgvB,yBAAyBqB,EAAQN,SAAUK,EACpD,CACA,kBAAAN,CAAmBQ,EAAe7nB,GAC9B,MAAM8nB,EAAavwB,KAAK4uB,UAAU5uB,KAAK4uB,UAAU5nB,OAAS,GAC1DilB,GAAqBsE,EAAY9nB,EAAU6nB,GAE3CtwB,KAAKivB,wBAAwBsB,EAAWR,SAAUO,EAAcP,SACpE,CACA,4BAAAS,GACI,IAAI,EAAAhD,GAAA,GAAYxtB,KAAKywB,2BAA4B,CAC7C,MAAMC,EAA+BxD,GAAqCltB,KAAKuc,WAAW,EAAA/F,GAAA,GAAKxW,KAAK2wB,uBAEpG,OADA3wB,KAAKywB,0BAA4BC,EAC1BA,CACX,CACA,OAAO1wB,KAAKywB,yBAChB,CACA,wCAAAG,GACI,IAAI,EAAApD,GAAA,GAAYxtB,KAAK6wB,uCAAwC,CACzD,MAAMC,EAAiBhD,GAAyC9tB,KAAKuc,WAAW,EAAA/F,GAAA,GAAKxW,KAAK2wB,sBAAuB3wB,KAAKwwB,gCAEtH,OADAxwB,KAAK6wB,sCAAwCC,EACtCA,CACX,CACA,OAAO9wB,KAAK6wB,qCAChB,CACA,4BAAAlK,GACI,MAAMxY,EAAYnO,KAAKymB,WACvB,OAAOtY,EAAUA,EAAUnH,OAAS,EACxC,CACA,gCAAA+f,GACI,MAAM5Y,EAAYnO,KAAKymB,WACvB,OAAOtY,EAAUA,EAAUnH,OAAS,EACxC,CACA,kCAAA6f,GACI,MAAMvY,EAAkBtO,KAAKsnB,sBAC7B,OAAOhZ,EAAgBA,EAAgBtH,OAAS,EACpD,ECpLG,MAAM+pB,GACT,gBAAAC,GACIhxB,KAAKixB,UAAY,GACjBjxB,KAAKkxB,gBAAkB,EACvBlxB,KAAKuR,SAAW,CACpB,CACA,SAAI4f,CAAMC,GAGN,IAA8B,IAA1BpxB,KAAKqxB,iBACL,MAAMxuB,MAAM,oFAIhB7C,KAAKkrB,QACLlrB,KAAKixB,UAAYG,EACjBpxB,KAAKkxB,gBAAkBE,EAASpqB,MACpC,CACA,SAAImqB,GACA,OAAOnxB,KAAKixB,SAChB,CAEA,UAAA3M,GACI,OAAItkB,KAAKuR,SAAWvR,KAAKixB,UAAUjqB,OAAS,GACxChH,KAAKwlB,eACExlB,KAAK8U,GAAG,IAGRwc,EAEf,CAGA,EAAAxc,CAAGyc,GACC,MAAMC,EAAYxxB,KAAKuR,QAAUggB,EACjC,OAAIC,EAAY,GAAKxxB,KAAKkxB,iBAAmBM,EAClCF,GAGAtxB,KAAKixB,UAAUO,EAE9B,CACA,YAAAhM,GACIxlB,KAAKuR,SACT,CACA,gBAAAuS,GACI,OAAO9jB,KAAKuR,OAChB,CACA,gBAAAiT,CAAiBiN,GACbzxB,KAAKuR,QAAUkgB,CACnB,CACA,eAAAC,GACI1xB,KAAKuR,SAAW,CACpB,CACA,qBAAAogB,GACI3xB,KAAKuR,QAAUvR,KAAKixB,UAAUjqB,OAAS,CAC3C,CACA,gBAAA4qB,GACI,OAAO5xB,KAAK8jB,kBAChB,ECrDG,MAAM+N,GACT,MAAAC,CAAOC,GACH,OAAOA,EAAKrd,KAAK1U,KACrB,CACA,OAAAgyB,CAAQrxB,EAAKnB,EAASiB,GAClB,OAAOT,KAAKiyB,gBAAgBzyB,EAASmB,EAAKF,EAC9C,CACA,OAAAsb,CAAQpb,EAAKuxB,EAAYzxB,GACrB,OAAOT,KAAKmyB,gBAAgBD,EAAYvxB,EAAKF,EACjD,CACA,MAAAub,CAAOrb,EAAKyxB,GACR,OAAOpyB,KAAKqyB,eAAeD,EAAmBzxB,EAClD,CACA,EAAA0b,CAAG1b,EAAK2xB,GACJ,OAAOtyB,KAAKuyB,WAAWD,EAAY3xB,EACvC,CACA,IAAAyb,CAAKzb,EAAKyxB,GACN,OAAOpyB,KAAKwyB,aAAa7xB,EAAKyxB,EAClC,CACA,UAAAlW,CAAWvb,EAAKyxB,GACZ,OAAOpyB,KAAKyyB,mBAAmB9xB,EAAKyxB,EACxC,CACA,OAAAM,CAAQlzB,EAASiB,GACb,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAkyB,CAASnzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAmyB,CAASpzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAoyB,CAASrzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAqyB,CAAStzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAsyB,CAASvzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAuyB,CAASxzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAwyB,CAASzzB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAAyyB,CAAS1zB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,QAAA0yB,CAAS3zB,EAASiB,GACd,OAAOT,KAAKiyB,gBAAgBzyB,EAAS,EAAGiB,EAC5C,CACA,OAAA2yB,CAAQlB,EAAYzxB,GAChB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAA4yB,CAASnB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAA6yB,CAASpB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAA8yB,CAASrB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAA+yB,CAAStB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAAgzB,CAASvB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAAizB,CAASxB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAAkzB,CAASzB,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAAmzB,CAAS1B,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,QAAAozB,CAAS3B,EAAYzxB,GACjB,OAAOT,KAAKmyB,gBAAgBD,EAAY,EAAGzxB,EAC/C,CACA,MAAAmS,CAAOwf,GACH,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAA0B,CAAQ1B,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAA2B,CAAQ3B,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAA4B,CAAQ5B,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAA6B,CAAQ7B,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAA8B,CAAQ9B,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAA+B,CAAQ/B,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAAgC,CAAQhC,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAAiC,CAAQjC,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,OAAAkC,CAAQlC,GACJ,OAAOpyB,KAAKqyB,eAAeD,EAAmB,EAClD,CACA,EAAAmC,CAAGjC,GACC,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAkC,CAAIlC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAmC,CAAInC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAoC,CAAIpC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAqC,CAAIrC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAsC,CAAItC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAuC,CAAIvC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAwC,CAAIxC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAAyC,CAAIzC,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,GAAA0C,CAAI1C,GACA,OAAOtyB,KAAKuyB,WAAWD,EAAY,EACvC,CACA,IAAA2C,CAAK7C,GACDpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAA8C,CAAM9C,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAA+C,CAAM/C,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAgD,CAAMhD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAiD,CAAMjD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAkD,CAAMlD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAmD,CAAMnD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAoD,CAAMpD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAqD,CAAMrD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,KAAAsD,CAAMtD,GACFpyB,KAAKwyB,aAAa,EAAGJ,EACzB,CACA,QAAAuD,CAASl1B,GACLT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAAo1B,CAAUp1B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAAq1B,CAAUr1B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAAs1B,CAAUt1B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAAu1B,CAAUv1B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAAw1B,CAAUx1B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAAy1B,CAAUz1B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAA01B,CAAU11B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAA21B,CAAU31B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,SAAA41B,CAAU51B,GACNT,KAAK41B,qBAAqB,EAAGn1B,EACjC,CACA,YAAA61B,CAAalE,GACTpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAAmE,CAAcnE,GACV,OAAOpyB,KAAKyyB,mBAAmB,EAAGL,EACtC,CACA,aAAAoE,CAAcpE,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAAqE,CAAcrE,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAAsE,CAActE,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAAuE,CAAcvE,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAAwE,CAAcxE,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAAyE,CAAczE,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAA0E,CAAc1E,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,aAAA2E,CAAc3E,GACVpyB,KAAKyyB,mBAAmB,EAAGL,EAC/B,CACA,gBAAA4E,CAAiBv2B,GACbT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAAy2B,CAAkBz2B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAA02B,CAAkB12B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAA22B,CAAkB32B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAA42B,CAAkB52B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAA62B,CAAkB72B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAA82B,CAAkB92B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAA+2B,CAAkB/2B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAAg3B,CAAkBh3B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,iBAAAi3B,CAAkBj3B,GACdT,KAAKi3B,2BAA2B,EAAGx2B,EACvC,CACA,IAAAk3B,CAAKh4B,EAAMi4B,EAAgBlV,EAASmV,IAChC,IAAI,EAAA/zB,EAAA,GAAS9D,KAAK2c,kBAAmBhd,GAAO,CACxC,MAAM0L,EAASZ,GAAqCmC,4BAA4B,CAC5ErC,aAAc5K,EACdkN,YAAa7M,KAAKuc,YAEhBmF,EAAQ,CACVlU,QAASnC,EACTnJ,KAAMuL,GAA0BgP,oBAChChU,SAAU9I,GAEdK,KAAK83B,iBAAiB/zB,KAAK2d,EAC/B,CACA1hB,KAAK2c,kBAAkB5Y,KAAKpE,GAC5B,MAAMo4B,EAAqB/3B,KAAKg4B,WAAWr4B,EAAMi4B,EAAgBlV,GAEjE,OADA1iB,KAAKL,GAAQo4B,EACNA,CACX,CACA,aAAAE,CAAct4B,EAAMoyB,EAAMrP,EAASmV,IAC/B,MAAMK,EAAaxb,GAAyB/c,EAAMK,KAAK2c,kBAAmB3c,KAAKuc,WAC/Evc,KAAK83B,iBAAmB93B,KAAK83B,iBAAiBxyB,OAAO4yB,GACrD,MAAMH,EAAqB/3B,KAAKg4B,WAAWr4B,EAAMoyB,EAAMrP,GAEvD,OADA1iB,KAAKL,GAAQo4B,EACNA,CACX,CACA,SAAAI,CAAU5U,EAAaoE,GACnB,OAAO,WAEH3nB,KAAKo4B,oBAAoBr0B,KAAK,GAC9B,MAAMs0B,EAAWr4B,KAAKs4B,iBACtB,IAGI,OAFA/U,EAAYc,MAAMrkB,KAAM2nB,IAEjB,CACX,CACA,MAAO4Q,GACH,GAAI9W,GAAuB8W,GACvB,OAAO,EAGP,MAAMA,CAEd,CACA,QACIv4B,KAAKw4B,iBAAiBH,GACtBr4B,KAAKo4B,oBAAoB7pB,KAC7B,CACJ,CACJ,CAEA,kBAAA+Z,GACI,OAAOtoB,KAAK2wB,oBAChB,CACA,4BAAA8H,GACI,OAAO72B,GAAiB,OAAO5B,KAAK2wB,sBACxC,E,eC9TG,MAAM+H,GACT,oBAAAC,CAAqBC,EAAiBlW,GAclC,GAbA1iB,KAAKuc,UAAYvc,KAAKG,YAAYR,KAElCK,KAAK64B,oBAAsB,CAAC,EAC5B74B,KAAKuqB,oBAAsB,CAAC,EAC5BvqB,KAAK84B,iBAAmB,IACxB94B,KAAKyT,aAAe,MACpBzT,KAAK+4B,WAAa,EAClB/4B,KAAK2c,kBAAoB,GACzB3c,KAAKg5B,UAAY,CAAC,EAClBh5B,KAAKo4B,oBAAsB,GAC3Bp4B,KAAKymB,WAAa,GAClBzmB,KAAKsnB,sBAAwB,GAC7BtnB,KAAK2wB,qBAAuB,CAAC,GACzB,EAAAzb,EAAA,GAAIwN,EAAQ,qBACZ,MAAM7f,MAAM,oLAIhB,IAAI,EAAA0qB,GAAA,GAAQqL,GAAkB,CAI1B,IAAI,EAAAnqB,EAAA,GAAQmqB,GACR,MAAM/1B,MAAM,+IAIhB,GAA8C,kBAAnC+1B,EAAgB,GAAGrN,YAC1B,MAAM1oB,MAAM,iLAIpB,CACA,IAAI,EAAA0qB,GAAA,GAAQqL,GACR54B,KAAKg5B,WAAY,EAAAzvB,EAAA,GAAOqvB,GAAiB,CAACK,EAAKz5B,KAC3Cy5B,EAAIz5B,EAAQG,MAAQH,EACby5B,IACR,CAAC,QAEH,IAAI,EAAA/jB,EAAA,GAAI0jB,EAAiB,WAC1B,EAAA50B,EAAA,IAAM,QAAQ,OAAO40B,EAAgBM,QAAS,OAAc,CAC5D,MAAMC,GAAgB,QAAQ,OAAOP,EAAgBM,QAC/CE,GAAe,EAAAlyB,EAAA,GAAKiyB,GAC1Bn5B,KAAKg5B,WAAY,EAAAzvB,EAAA,GAAO6vB,GAAc,CAACH,EAAKz5B,KACxCy5B,EAAIz5B,EAAQG,MAAQH,EACby5B,IACR,CAAC,EACR,KACK,MAAI,EAAAI,GAAA,GAAST,GAId,MAAM,IAAI/1B,MAAM,0IAHhB7C,KAAKg5B,WAAY,EAAA5qB,EAAA,GAAMwqB,EAK3B,CAGA54B,KAAKg5B,UAAU,OAAS,KACxB,MAAMG,GAAgB,EAAAjkB,EAAA,GAAI0jB,EAAiB,UACrC,QAAQ,OAAOA,EAAgBM,SAC/B,OAAON,GACPU,GAAwB,EAAAt1B,EAAA,GAAMm1B,GAAgBI,IAAqB,EAAA9qB,EAAA,GAAQ8qB,EAAiBnkB,mBAClGpV,KAAKyT,aAAe6lB,EACd,MACA,OAIN,UAAkB,OAAOt5B,KAAKg5B,WAClC,CACA,UAAAhB,CAAWvvB,EAAUspB,EAAMrP,GACvB,GAAI1iB,KAAKqxB,iBACL,MAAMxuB,MAAM,iBAAiB4F,+KAGjC,MAAM+wB,GAAgB,EAAAtkB,EAAA,GAAIwN,EAAQ,iBAC5BA,EAAO8W,cACP3B,GAAoB2B,cACpBC,GAAoB,EAAAvkB,EAAA,GAAIwN,EAAQ,qBAChCA,EAAO+W,kBACP5B,GAAoB4B,kBAGpBC,EAAY15B,KAAK84B,kBAAqBtQ,GAAuBC,GAInE,IAAIkR,EAHJ35B,KAAK84B,mBACL94B,KAAK64B,oBAAoBa,GAAajxB,EACtCzI,KAAKuqB,oBAAoB9hB,GAAYixB,EAKjCC,GADmB,IAAnB35B,KAAK6uB,UACe,YAA8BlH,GAC9C,IACI3nB,KAAK45B,0BAA0BF,EAAWjxB,EAAUzI,KAAK+4B,YACzDhH,EAAK1N,MAAMrkB,KAAM2nB,GACjB,MAAMkS,EAAM75B,KAAK4uB,UAAU5uB,KAAK4uB,UAAU5nB,OAAS,GAEnD,OADAhH,KAAKkvB,YAAY2K,GACVA,CACX,CACA,MAAOtB,GACH,OAAOv4B,KAAK85B,gBAAgBvB,EAAGiB,EAAeC,EAClD,CACA,QACIz5B,KAAK+5B,wBACT,CACJ,EAGoB,YAAiCpS,GACjD,IAEI,OADA3nB,KAAK45B,0BAA0BF,EAAWjxB,EAAUzI,KAAK+4B,YAClDhH,EAAK1N,MAAMrkB,KAAM2nB,EAC5B,CACA,MAAO4Q,GACH,OAAOv4B,KAAK85B,gBAAgBvB,EAAGiB,EAAeC,EAClD,CACA,QACIz5B,KAAK+5B,wBACT,CACJ,EAEJ,MAAMC,EAAqB7vB,OAAOgQ,OAAOwf,EAAmB,CAAElxB,WAAUwxB,sBAAuBlI,IAC/F,OAAOiI,CACX,CACA,eAAAF,CAAgBvB,EAAG2B,EAAqBT,GACpC,MAAMU,EAAgD,IAA3Bn6B,KAAKymB,WAAWzf,OAKrCozB,EAAgBF,IAAwBl6B,KAAK6kB,kBAAoB7kB,KAAK6iB,gBAC5E,GAAIpB,GAAuB8W,GAAI,CAC3B,MAAM8B,EAAa9B,EACnB,GAAI6B,EAAe,CACf,MAAMzW,EAAgB3jB,KAAK4jB,sBAC3B,GAAI5jB,KAAK+lB,yBAAyBpC,GAAgB,CAE9C,GADA0W,EAAWzY,eAAiB5hB,KAAKynB,SAAS9D,GACtC3jB,KAAK6uB,UAAW,CAChB,MAAMyL,EAAmBt6B,KAAK4uB,UAAU5uB,KAAK4uB,UAAU5nB,OAAS,GAEhE,OADAszB,EAAiBC,eAAgB,EAC1BD,CACX,CAEI,OAAOb,EAAkBlB,EAEjC,CAEI,GAAIv4B,KAAK6uB,UAAW,CAChB,MAAMyL,EAAmBt6B,KAAK4uB,UAAU5uB,KAAK4uB,UAAU5nB,OAAS,GAChEszB,EAAiBC,eAAgB,EACjCF,EAAWC,iBAAmBA,CAClC,CAEA,MAAMD,CAEd,CACK,GAAIF,EAKL,OAHAn6B,KAAK2xB,wBAGE8H,EAAkBlB,GAIzB,MAAM8B,CAEd,CAGI,MAAM9B,CAEd,CAEA,cAAAlG,CAAeD,EAAmB1mB,GAC9B,MAAM6M,EAAMvY,KAAKooB,4BAA4BO,GAAYjd,GACzD,OAAO1L,KAAKw6B,oBAAoBpI,EAAmB1mB,EAAY6M,EACnE,CACA,mBAAAiiB,CAAoBpI,EAAmB1mB,EAAY6M,GAC/C,IACIkiB,EADAhX,EAAgBzjB,KAAK6qB,mBAAmBtS,GAE5C,GAAiC,oBAAtB6Z,EAAkC,CACzCqI,EAASrI,EAAkBsI,IAC3B,MAAMC,EAAYvI,EAAkB9d,KAEpC,QAAkBxT,IAAd65B,EAAyB,CACzB,MAAMC,EAAuBnX,EAC7BA,EAAgB,IACLkX,EAAUjmB,KAAK1U,OAAS46B,EAAqBlmB,KAAK1U,KAEjE,CACJ,MAEIy6B,EAASrI,EAEb,IAAiC,IAA7B3O,EAAc/O,KAAK1U,MACnB,OAAOy6B,EAAO/lB,KAAK1U,KAG3B,CACA,kBAAAyyB,CAAmB3K,EAAgBsK,GAC/B,MAAMyI,EAAQ76B,KAAKooB,4BAA4BS,GAAkBf,GACjE,OAAO9nB,KAAK86B,wBAAwBhT,EAAgBsK,EAAmByI,EAC3E,CACA,uBAAAC,CAAwBhT,EAAgBsK,EAAmB7Z,GACvD,IACIkiB,EADAhX,EAAgBzjB,KAAK6qB,mBAAmBtS,GAE5C,GAAiC,oBAAtB6Z,EAAkC,CACzCqI,EAASrI,EAAkBsI,IAC3B,MAAMC,EAAYvI,EAAkB9d,KAEpC,QAAkBxT,IAAd65B,EAAyB,CACzB,MAAMC,EAAuBnX,EAC7BA,EAAgB,IACLkX,EAAUjmB,KAAK1U,OAAS46B,EAAqBlmB,KAAK1U,KAEjE,CACJ,MAEIy6B,EAASrI,EAEb,IAAiC,IAA7B3O,EAAc/O,KAAK1U,MAQnB,MAAMA,KAAK+6B,wBAAwBjT,EAAgBpV,GAAUI,qBAAsBsf,EAAkB4I,SARlE,CACnC,IAAIpW,EAAW5kB,KAAKi7B,mBAAmBR,GACvC,OAAoC,IAA7BhX,EAAc/O,KAAK1U,QACT,IAAb4kB,EACAA,EAAW5kB,KAAKi7B,mBAAmBR,EAE3C,CAQAz6B,KAAK+iB,4BAA4B/iB,KAAKyyB,mBAAoB,CAAC3K,EAAgBsK,GAAoB3O,EAAeoF,GAAkBf,EAAgBvY,GACpJ,CACA,0BAAA0nB,CAA2BnP,EAAgBrnB,GACvC,MAAMo6B,EAAQ76B,KAAKooB,4BAA4BW,GAAsBjB,GACrE9nB,KAAKk7B,gCAAgCpT,EAAgBrnB,EAASo6B,EAClE,CACA,+BAAAK,CAAgCpT,EAAgBrnB,EAAS8X,GACrD,MAAMkiB,EAASh6B,EAAQi6B,IACjBr4B,EAAY5B,EAAQ06B,IACpBC,EAA8Bp7B,KAAK6qB,mBAAmBtS,GAE5D,IAA+C,IAA3C6iB,EAA4B1mB,KAAK1U,MAyBjC,MAAMA,KAAK+6B,wBAAwBjT,EAAgBpV,GAAUK,oCAAqCtS,EAAQu6B,SAzBzD,CACjDP,EAAO/lB,KAAK1U,MAGZ,MAAMq7B,EAAyB,IACpBr7B,KAAKyT,aAAazT,KAAK8U,GAAG,GAAIzS,GAGzC,OAAoD,IAA7CrC,KAAKyT,aAAazT,KAAK8U,GAAG,GAAIzS,GAGjCrC,KAAK0yB,QAAQrwB,GAEbo4B,EAAO/lB,KAAK1U,MAGhBA,KAAK+iB,4BAA4B/iB,KAAKs7B,4BAA6B,CAC/DxT,EACAzlB,EACAg5B,EACAZ,EACAhrB,IACD4rB,EAAwBtS,GAAsBjB,EAAgBrY,GACrE,CAIJ,CACA,YAAA+iB,CAAa1K,EAAgBsK,GACzB,MAAMyI,EAAQ76B,KAAKooB,4BAA4BQ,GAAUd,GACzD,OAAO9nB,KAAKu7B,kBAAkBzT,EAAgBsK,EAAmByI,EACrE,CACA,iBAAAU,CAAkBzT,EAAgBsK,EAAmB7Z,GACjD,IACIkiB,EADAe,EAAoBx7B,KAAK6qB,mBAAmBtS,GAEhD,GAAiC,oBAAtB6Z,EAAkC,CACzCqI,EAASrI,EAAkBsI,IAC3B,MAAMC,EAAYvI,EAAkB9d,KAEpC,QAAkBxT,IAAd65B,EAAyB,CACzB,MAAMC,EAAuBY,EAC7BA,EAAoB,IACTb,EAAUjmB,KAAK1U,OAAS46B,EAAqBlmB,KAAK1U,KAEjE,CACJ,MAEIy6B,EAASrI,EAEb,IAAIxN,GAAW,EACf,OAAwC,IAAjC4W,EAAkB9mB,KAAK1U,QAA+B,IAAb4kB,EAC5CA,EAAW5kB,KAAKi7B,mBAAmBR,GAGvCz6B,KAAK+iB,4BAA4B/iB,KAAKwyB,aAAc,CAAC1K,EAAgBsK,GAAoBoJ,EAAmB5S,GAAUd,EAAgB3Y,GAMtIyV,EACJ,CACA,oBAAAgR,CAAqB9N,EAAgBrnB,GACjC,MAAMo6B,EAAQ76B,KAAKooB,4BAA4BU,GAAchB,GAC7D9nB,KAAKy7B,0BAA0B3T,EAAgBrnB,EAASo6B,EAC5D,CACA,yBAAAY,CAA0B3T,EAAgBrnB,EAAS8X,GAC/C,MAAMkiB,EAASh6B,EAAQi6B,IACjBr4B,EAAY5B,EAAQ06B,IACpBO,EAAuB17B,KAAK6qB,mBAAmBtS,GAErD,IAAwC,IAApCmjB,EAAqBhnB,KAAK1U,MAAgB,CAC1Cy6B,EAAO/lB,KAAK1U,MACZ,MAAMq7B,EAAyB,IACpBr7B,KAAKyT,aAAazT,KAAK8U,GAAG,GAAIzS,GAGzC,OAAoD,IAA7CrC,KAAKyT,aAAazT,KAAK8U,GAAG,GAAIzS,GAGjCrC,KAAK0yB,QAAQrwB,GAEbo4B,EAAO/lB,KAAK1U,MAGhBA,KAAK+iB,4BAA4B/iB,KAAKs7B,4BAA6B,CAC/DxT,EACAzlB,EACAg5B,EACAZ,EACAprB,IACDgsB,EAAwBvS,GAAchB,EAAgBzY,GAC7D,CACJ,CACA,2BAAAisB,CAA4BxT,EAAgBzlB,EAAWg5B,EAAwBZ,EAAQkB,GACnF,MAAON,IAGHr7B,KAAK0yB,QAAQrwB,GACbo4B,EAAO/lB,KAAK1U,MAQhBA,KAAK+iB,4BAA4B/iB,KAAKs7B,4BAA6B,CAC/DxT,EACAzlB,EACAg5B,EACAZ,EACAkB,GACDN,EAAwBtS,GAAsBjB,EAAgB6T,EACrE,CACA,kBAAAV,CAAmBR,GACf,MAAMmB,EAAkB57B,KAAK4xB,mBAC7B6I,EAAO/lB,KAAK1U,MACZ,MAAM67B,EAAiB77B,KAAK4xB,mBAG5B,OAAOiK,EAAiBD,CAC5B,CACA,UAAArJ,CAAWD,EAAY5mB,GACnB,MAAMmvB,EAAQ76B,KAAKooB,4BAA4BM,GAAQhd,GACjDuI,GAAO,EAAAsZ,GAAA,GAAQ+E,GAAcA,EAAaA,EAAWoI,IACrDpQ,EAAStqB,KAAK6qB,mBAAmBgQ,GACjCiB,EAAexR,EAAO5V,KAAK1U,KAAMiU,GACvC,QAAqBnT,IAAjBg7B,EAA4B,CAC5B,MAAMC,EAAoB9nB,EAAK6nB,GAC/B,OAAOC,EAAkBC,IAAItnB,KAAK1U,KACtC,CACAA,KAAKi8B,oBAAoBvwB,EAAY4mB,EAAW0I,QACpD,CACA,sBAAAjB,GAKI,GAJA/5B,KAAKymB,WAAWlY,MAChBvO,KAAKsnB,sBAAsB/Y,MAE3BvO,KAAK4vB,wBAC0B,IAA3B5vB,KAAKymB,WAAWzf,SAA0C,IAA1BhH,KAAKk8B,iBAA4B,CACjE,MAAMC,EAAoBn8B,KAAK8U,GAAG,GAC5BzJ,EAASrL,KAAKkkB,qBAAqBpb,8BAA8B,CACnEC,eAAgBozB,EAChB1zB,SAAUzI,KAAKmkB,wBAEnBnkB,KAAKokB,WAAW,IAAIjC,GAA2B9W,EAAQ8wB,GAC3D,CACJ,CACA,eAAAhK,CAAgBD,EAAYvxB,EAAKF,GAC7B,IAAIyrB,EACJ,IACI,MAAMvE,OAAmB7mB,IAAZL,EAAwBA,EAAQ27B,UAAOt7B,EAMpD,OALAd,KAAK+4B,WAAap4B,EAClBurB,EAAagG,EAAW7N,MAAMrkB,KAAM2nB,GACpC3nB,KAAK8vB,mBAAmB5D,OAAwBprB,IAAZL,QAA2CK,IAAlBL,EAAQf,MAC/De,EAAQf,MACRwyB,EAAWzpB,UACVyjB,CACX,CACA,MAAOqM,GACH,MAAMv4B,KAAKq8B,qBAAqB9D,EAAG93B,EAASyxB,EAAWzpB,SAC3D,CACJ,CACA,oBAAA4zB,CAAqB9D,EAAG93B,EAASgI,GAO7B,MANIgZ,GAAuB8W,SAA6Bz3B,IAAvBy3B,EAAE+B,mBAC/Bt6B,KAAK8vB,mBAAmByI,EAAE+B,sBAA8Bx5B,IAAZL,QAA2CK,IAAlBL,EAAQf,MACvEe,EAAQf,MACR+I,UACC8vB,EAAE+B,kBAEP/B,CACV,CACA,eAAAtG,CAAgBzyB,EAASmB,EAAKF,GAC1B,IAAI2vB,EACJ,IACI,MAAMvb,EAAY7U,KAAK8U,GAAG,IACoB,IAA1C9U,KAAKyT,aAAaoB,EAAWrV,IAC7BQ,KAAKwlB,eACL4K,EAAgBvb,GAGhB7U,KAAKs8B,qBAAqB98B,EAASqV,EAAWpU,EAEtD,CACA,MAAO87B,GACHnM,EAAgBpwB,KAAKw8B,wBAAwBh9B,EAASmB,EAAK47B,EAC/D,CAIA,OAHAv8B,KAAK6vB,qBAA4B/uB,IAAZL,QAA2CK,IAAlBL,EAAQf,MAChDe,EAAQf,MACRF,EAAQG,KAAMywB,GACbA,CACX,CACA,oBAAAkM,CAAqB98B,EAASqV,EAAWpU,GACrC,IAAImI,EACJ,MAAMqZ,EAAgBjiB,KAAK8U,GAAG,GAY9B,MAVIlM,OADY9H,IAAZL,GAAyBA,EAAQu6B,QAC3Bv6B,EAAQu6B,QAGRh7B,KAAKkkB,qBAAqB7b,0BAA0B,CACtDC,SAAU9I,EACV+I,OAAQsM,EACRrM,SAAUyZ,EACVxZ,SAAUzI,KAAKmkB,wBAGjBnkB,KAAKokB,WAAW,IAAIpC,GAAyBpZ,EAAKiM,EAAWoN,GACvE,CACA,uBAAAua,CAAwBh9B,EAASmB,EAAK47B,GAGlC,IAAIv8B,KAAK6iB,iBAEqB,6BAA1B0Z,EAAiB58B,MAChBK,KAAK6kB,iBAiBN,MAAM0X,EAjBkB,CACxB,MAAMh1B,EAAUvH,KAAK+kB,4BAA4BvlB,EAASmB,GAC1D,IACI,OAAOX,KAAKolB,kBAAkB5lB,EAAS+H,EAC3C,CACA,MAAOk1B,GACH,MAAIA,EAAoB98B,OAAS2iB,GAGvBia,EAGAE,CAEd,CACJ,CAIJ,CACA,cAAAnE,GAEI,MAAMoE,EAAc18B,KAAKoN,OACnBuvB,GAAiB,EAAAvuB,EAAA,GAAMpO,KAAKymB,YAClC,MAAO,CACHrZ,OAAQsvB,EACRE,WAAY58B,KAAK8jB,mBACjB2C,WAAYkW,EACZ/N,UAAW5uB,KAAK4uB,UAExB,CACA,gBAAA4J,CAAiB/G,GACbzxB,KAAKoN,OAASqkB,EAASrkB,OACvBpN,KAAKwkB,iBAAiBiN,EAASmL,YAC/B58B,KAAKymB,WAAagL,EAAShL,UAC/B,CACA,yBAAAmT,CAA0BF,EAAWmD,EAAU5V,GAC3CjnB,KAAKsnB,sBAAsBvjB,KAAKkjB,GAChCjnB,KAAKymB,WAAW1iB,KAAK21B,GAErB15B,KAAK2vB,yBAAyBkN,EAClC,CACA,cAAAhY,GACI,OAA2C,IAApC7kB,KAAKo4B,oBAAoBpxB,MACpC,CACA,mBAAAmd,GACI,MAAMuV,EAAY15B,KAAK2mB,+BACvB,OAAO3mB,KAAK64B,oBAAoBa,EACpC,CACA,uBAAA1S,CAAwB0S,GACpB,OAAO15B,KAAK64B,oBAAoBa,EACpC,CACA,cAAAwC,GACI,OAAOl8B,KAAKyT,aAAazT,KAAK8U,GAAG,GAAI,KACzC,CACA,KAAAoW,GACIlrB,KAAK0xB,kBACL1xB,KAAK+4B,WAAa,EAClB/4B,KAAKo4B,oBAAsB,GAC3Bp4B,KAAKoN,OAAS,GACdpN,KAAKymB,WAAa,GAElBzmB,KAAK4uB,UAAY,GACjB5uB,KAAKsnB,sBAAwB,EACjC,ECphBG,MAAMwV,GACT,gBAAAC,CAAiBra,GACb1iB,KAAKg9B,QAAU,GACfh9B,KAAKkkB,sBAAuB,EAAAhP,EAAA,GAAIwN,EAAQ,wBAClCA,EAAOwB,qBACPpB,GAAsBoB,oBAChC,CACA,UAAAE,CAAW1C,GACP,GAAID,GAAuBC,GAMvB,OALAA,EAAMub,QAAU,CACZ9uB,UAAWnO,KAAKioB,4BAChBiV,qBAAqB,EAAA9uB,EAAA,GAAMpO,KAAKsnB,wBAEpCtnB,KAAKg9B,QAAQj5B,KAAK2d,GACXA,EAGP,MAAM7e,MAAM,8DAEpB,CACA,UAAIuK,GACA,OAAO,EAAAgB,EAAA,GAAMpO,KAAKg9B,QACtB,CACA,UAAI5vB,CAAO+vB,GACPn9B,KAAKg9B,QAAUG,CACnB,CAEA,uBAAApC,CAAwBrvB,EAAYmI,EAAUupB,GAC1C,MAAM30B,EAAWzI,KAAKmkB,sBAChBhR,EAAcnT,KAAKsoB,qBAAqB7f,GACxC40B,EAA+BtpB,GAAiCrI,EAAYyH,EAAaU,EAAU7T,KAAKoT,cACxGkqB,EAAkBD,EAA6B,GAC/CE,EAAe,GACrB,IAAK,IAAIxtB,EAAI,EAAGA,GAAK/P,KAAKoT,aAAcrD,IACpCwtB,EAAax5B,KAAK/D,KAAK8U,GAAG/E,IAE9B,MAAMnH,EAAM5I,KAAKkkB,qBAAqBja,sBAAsB,CACxDC,uBAAwBozB,EACxB/0B,OAAQg1B,EACR/0B,SAAUxI,KAAK8U,GAAG,GAClB5L,sBAAuBk0B,EACvB30B,SAAUA,IAEd,MAAMzI,KAAKokB,WAAW,IAAIhC,GAAmBxZ,EAAK5I,KAAK8U,GAAG,GAAI9U,KAAK8U,GAAG,IAC1E,CAEA,mBAAAmnB,CAAoBvwB,EAAY8xB,GAC5B,MAAM/0B,EAAWzI,KAAKmkB,sBAChBhR,EAAcnT,KAAKsoB,qBAAqB7f,GAExC40B,EAA+B7pB,GAAuB9H,EAAYyH,EAAanT,KAAKoT,cACpFmqB,EAAe,GACrB,IAAK,IAAIxtB,EAAI,EAAGA,GAAK/P,KAAKoT,aAAcrD,IACpCwtB,EAAax5B,KAAK/D,KAAK8U,GAAG/E,IAE9B,MAAMkS,EAAgBjiB,KAAK8U,GAAG,GACxBzJ,EAASrL,KAAKkkB,qBAAqBlb,wBAAwB,CAC7DC,oBAAqBo0B,EACrB90B,OAAQg1B,EACR/0B,SAAUyZ,EACV/Y,sBAAuBs0B,EACvB/0B,SAAUzI,KAAKmkB,wBAEnB,MAAMnkB,KAAKokB,WAAW,IAAIlC,GAAqB7W,EAAQrL,KAAK8U,GAAG,GAAImN,GACvE,ECrEG,MAAMwb,GACT,iBAAAC,GAAsB,CACtB,oBAAAC,CAAqBC,EAAeC,GAChC,MAAMC,EAAgB99B,KAAK2wB,qBAAqBiN,GAChD,IAAI,EAAApQ,GAAA,GAAYsQ,GACZ,MAAMj7B,MAAM,UAAU+6B,uCAE1B,OAAOptB,GAAwB,CAACstB,GAAgBD,EAAgB79B,KAAKyT,aAAczT,KAAKoT,aAC5F,CAGA,yBAAA+R,CAA0BF,GACtB,MAAM8Y,GAAc,OAAM9Y,EAAY9W,WAChC6vB,EAAkBh+B,KAAKsoB,qBACvB2V,EAAgBD,EAAgBD,GAChCG,EAAyB,IAAIxvB,GAAqBuvB,EAAehZ,GAAazd,eACpF,OAAO02B,CACX,E,eCZJ,MAAMC,GAAwB,CAC1BC,YAAa,8DAEjBj0B,OAAOC,OAAO+zB,IACd,MAAME,IAAmB,EACnBC,GAAiBC,KAAKC,IAAI,EAAG/V,IAA2B,EACxDgW,IAAM,QAAY,CAAE9+B,KAAM,wBAAyB8C,QAAS,KAAMi8B,MACxE,SAAkB,CAACD,KACnB,MAAME,IAAwB,QAAoBF,GAAK,gJAKtD,GAAI,GAAI,GAAI,GAAI,GAAI,GACrBt0B,OAAOC,OAAOu0B,IACd,MAAMC,GAA0B,CAC5Bj/B,KAAM,gJAENqsB,SAAU,CAAC,GAKR,MAAM6S,GACT,gBAAAC,CAAiBpc,GACb1iB,KAAK++B,mBAAqB,GAC1B/+B,KAAKg/B,iBAAkB,CAC3B,CACA,eAAAC,GACIj/B,KAAKg/B,iBAAkB,EACvBh/B,KAAKgqB,WAAW,oBAAoB,KAUhC,IAAK,IAAIja,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMpP,EAAMoP,EAAI,EAAIA,EAAI,GACxB/P,KAAK,UAAUW,KAAS,SAAUu+B,EAAMC,GACpC,OAAOn/B,KAAKo/B,sBAAsBF,EAAMnvB,EAAGovB,EAC/C,EACAn/B,KAAK,UAAUW,KAAS,SAAUu+B,EAAMC,GACpC,OAAOn/B,KAAKq/B,sBAAsBH,EAAMnvB,EAAGovB,EAC/C,EACAn/B,KAAK,SAASW,KAAS,SAAUu+B,GAC7B,OAAOl/B,KAAKs/B,qBAAqBJ,EAAMnvB,EAC3C,EACA/P,KAAK,KAAKW,KAAS,SAAUu+B,GACzB,OAAOl/B,KAAKu/B,iBAAiBL,EAAMnvB,EACvC,EACA/P,KAAK,OAAOW,KAAS,SAAUu+B,GAC3Bl/B,KAAKw/B,mBAAmBzvB,EAAGmvB,EAC/B,EACAl/B,KAAK,WAAWW,KAAS,SAAUu+B,GAC/Bl/B,KAAKy/B,2BAA2B1vB,EAAGmvB,EACvC,EACAl/B,KAAK,eAAeW,KAAS,SAAUu+B,GACnCl/B,KAAK0/B,yBAAyB3vB,EAAGmvB,EACrC,EACAl/B,KAAK,mBAAmBW,KAAS,SAAUu+B,GACvCl/B,KAAK2/B,iCAAiC5vB,EAAGmvB,EAC7C,CACJ,CAEAl/B,KAAK,WAAa,SAAUW,EAAKu+B,EAAMC,GACnC,OAAOn/B,KAAKo/B,sBAAsBF,EAAMv+B,EAAKw+B,EACjD,EACAn/B,KAAK,WAAa,SAAUW,EAAKu+B,EAAMC,GACnC,OAAOn/B,KAAKq/B,sBAAsBH,EAAMv+B,EAAKw+B,EACjD,EACAn/B,KAAK,UAAY,SAAUW,EAAKu+B,GAC5B,OAAOl/B,KAAKs/B,qBAAqBJ,EAAMv+B,EAC3C,EACAX,KAAK,MAAQ,SAAUW,EAAKu+B,GACxB,OAAOl/B,KAAKu/B,iBAAiBL,EAAMv+B,EACvC,EACAX,KAAK,QAAU,SAAUW,EAAKu+B,GAC1Bl/B,KAAKw/B,mBAAmB7+B,EAAKu+B,EACjC,EACAl/B,KAAK,cAAgB,SAAUW,EAAKu+B,GAChCl/B,KAAK0/B,yBAAyB/+B,EAAKu+B,EACvC,EACAl/B,KAAK8xB,OAAS9xB,KAAK4/B,cACnB5/B,KAAKm4B,UAAYn4B,KAAK6/B,iBACtB7/B,KAAK8U,GAAK9U,KAAK8/B,SAAS,GAEhC,CACA,gBAAAC,GACI//B,KAAKg/B,iBAAkB,EAKvBh/B,KAAKgqB,WAAW,8BAA8B,KAC1C,MAAMgW,EAAOhgC,KACb,IAAK,IAAI+P,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMpP,EAAMoP,EAAI,EAAIA,EAAI,UACjBiwB,EAAK,UAAUr/B,YACfq/B,EAAK,UAAUr/B,YACfq/B,EAAK,SAASr/B,YACdq/B,EAAK,KAAKr/B,YACVq/B,EAAK,OAAOr/B,YACZq/B,EAAK,WAAWr/B,YAChBq/B,EAAK,eAAer/B,YACpBq/B,EAAK,mBAAmBr/B,IACnC,QACOq/B,EAAK,kBACLA,EAAK,kBACLA,EAAK,iBACLA,EAAK,aACLA,EAAK,eACLA,EAAK,qBACLA,EAAKlO,cACLkO,EAAK7H,iBACL6H,EAAKlrB,EAAE,GAEtB,CAIA,aAAA8qB,CAAc7N,GAEd,CAEA,gBAAA8N,CAAiBtc,EAAaoE,GAC1B,MAAO,KAAM,CACjB,CAGA,SAAAmY,CAAUvO,GAGN,OAAOD,EACX,CACA,kBAAA2O,CAAmBtgC,EAAMyR,GACrB,IACI,MAAM8uB,EAAkB,IAAIl/B,EAAK,CAAEjB,WAAY,GAAIJ,KAAMA,IAKzD,OAJAugC,EAAgBvgC,KAAOA,EACvBK,KAAK++B,mBAAmBh7B,KAAKm8B,GAC7B9uB,EAAIsD,KAAK1U,MACTA,KAAK++B,mBAAmBxwB,MACjB2xB,CACX,CACA,MAAOC,GACH,IAA2C,IAAvCA,EAAcC,qBACd,IACID,EAAc3yB,QACV2yB,EAAc3yB,QAAd2yB,yJAGR,CACA,MAAOE,GAEH,MAAMF,CACV,CAEJ,MAAMA,CACV,CACJ,CAEA,oBAAAb,CAAqBlN,EAAmB1mB,GACpC,OAAO40B,GAAW5rB,KAAK1U,KAAMoB,EAAQgxB,EAAmB1mB,EAC5D,CACA,wBAAAg0B,CAAyBh0B,EAAY0mB,GACjCkO,GAAW5rB,KAAK1U,KAAMqB,EAAqB+wB,EAAmB1mB,EAClE,CACA,gCAAAi0B,CAAiCj0B,EAAYjL,GACzC6/B,GAAW5rB,KAAK1U,KAAMsB,EAAkCb,EAASiL,EAAY2yB,GACjF,CACA,kBAAAmB,CAAmB9zB,EAAY0mB,GAC3BkO,GAAW5rB,KAAK1U,KAAMuB,EAAY6wB,EAAmB1mB,EACzD,CACA,0BAAA+zB,CAA2B/zB,EAAYjL,GACnC6/B,GAAW5rB,KAAK1U,KAAMwB,EAAyBf,EAASiL,EAAY2yB,GACxE,CACA,gBAAAkB,CAAiBjN,EAAY5mB,GACzB,OAAO60B,GAAa7rB,KAAK1U,KAAMsyB,EAAY5mB,EAC/C,CACA,qBAAA2zB,CAAsBnN,EAAYxmB,EAAYjL,GAE1C,GADA+/B,GAAuB90B,IAClBwmB,IAA8C,KAAhC,EAAAhd,EAAA,GAAIgd,EAAY,YAAuB,CACtD,MAAMxQ,EAAQ,IAAI7e,MAAM,WAAW49B,GAAa/0B,yEACMg1B,KAAKC,UAAUzO,iCACnClyB,KAAK++B,mBAAmB,GAAGp/B,SAE7D,MADA+hB,EAAM0e,sBAAuB,EACvB1e,CACV,CACA,MAAMkf,GAAW,QAAK5gC,KAAK++B,oBACrBt2B,EAAWypB,EAAWzpB,SACtBo4B,EAAkB,IAAI,EAAY,CACpClgC,IAAK+K,EACLvJ,gBAAiBsG,EACjBrG,MAAmB,OAAZ3B,QAAgC,IAAZA,OAAqB,EAASA,EAAQf,MAEjEqB,oBAAgBD,IAGpB,OADA8/B,EAAS7gC,WAAWgE,KAAK88B,GAClB7gC,KAAK6uB,UACN+P,GACAT,EACV,CACA,qBAAAiB,CAAsB5/B,EAASkM,EAAYjL,GAEvC,GADA+/B,GAAuB90B,KAClB,SAAoBlM,GAAU,CAC/B,MAAMkiB,EAAQ,IAAI7e,MAAM,WAAW49B,GAAa/0B,qEACEg1B,KAAKC,UAAUnhC,iCAC/BQ,KAAK++B,mBAAmB,GAAGp/B,SAE7D,MADA+hB,EAAM0e,sBAAuB,EACvB1e,CACV,CACA,MAAMkf,GAAW,QAAK5gC,KAAK++B,oBACrB8B,EAAkB,IAAIl/B,EAAS,CACjChB,IAAK+K,EACLpJ,aAAc9C,EACd4C,MAAmB,OAAZ3B,QAAgC,IAAZA,OAAqB,EAASA,EAAQf,QAGrE,OADAkhC,EAAS7gC,WAAWgE,KAAK88B,GAClBlC,EACX,EAEJ,SAAS2B,GAAWQ,EAAiBC,EAAar1B,EAAYs1B,GAAY,GACtER,GAAuB90B,GACvB,MAAMk1B,GAAW,QAAK5gC,KAAK++B,oBACrBkC,GAAgB,EAAA1S,GAAA,GAAWwS,GAAeA,EAAcA,EAAYrG,IACpEwG,EAAU,IAAIJ,EAAgB,CAAE/gC,WAAY,GAAIY,IAAK+K,IAW3D,OAVIs1B,IACAE,EAAQ7+B,UAAY0+B,EAAY5F,MAEhC,EAAAjmB,EAAA,GAAI6rB,EAAa,mBACjBG,EAAQ9tB,aAAe2tB,EAAYI,eAEvCnhC,KAAK++B,mBAAmBh7B,KAAKm9B,GAC7BD,EAAcvsB,KAAK1U,MACnB4gC,EAAS7gC,WAAWgE,KAAKm9B,GACzBlhC,KAAK++B,mBAAmBxwB,MACjB4vB,EACX,CACA,SAASoC,GAAaQ,EAAar1B,GAC/B80B,GAAuB90B,GACvB,MAAMk1B,GAAW,QAAK5gC,KAAK++B,oBAErBqC,GAAsC,KAAzB,EAAA7T,GAAA,GAAQwT,GACrB9sB,GAAsB,IAAfmtB,EAAuBL,EAAcA,EAAYrG,IACxD2G,EAAY,IAAI5/B,EAAY,CAC9B1B,WAAY,GACZY,IAAK+K,EACLvK,kBAAmBigC,IAAiD,IAAnCL,EAAYO,sBAE7C,EAAApsB,EAAA,GAAI6rB,EAAa,mBACjBM,EAAUjuB,aAAe2tB,EAAYI,eAEzC,MAAMz/B,GAAgB,OAAKuS,GAAO5D,IAAY,EAAAke,GAAA,GAAWle,EAAQiE,QAiBjE,OAhBA+sB,EAAU3/B,cAAgBA,EAC1Bk/B,EAAS7gC,WAAWgE,KAAKs9B,IACzB,EAAA9gC,EAAA,GAAQ0T,GAAO5D,IACX,MAAMkxB,EAAc,IAAIrgC,EAAY,CAAEnB,WAAY,KAClDshC,EAAUthC,WAAWgE,KAAKw9B,IACtB,EAAArsB,EAAA,GAAI7E,EAAS,sBACbkxB,EAAYpgC,kBAAoBkP,EAAQixB,oBAGnC,EAAApsB,EAAA,GAAI7E,EAAS,UAClBkxB,EAAYpgC,mBAAoB,GAEpCnB,KAAK++B,mBAAmBh7B,KAAKw9B,GAC7BlxB,EAAQ2rB,IAAItnB,KAAK1U,MACjBA,KAAK++B,mBAAmBxwB,KAAK,IAE1B4vB,EACX,CACA,SAASsC,GAAa9/B,GAClB,OAAe,IAARA,EAAY,GAAK,GAAGA,GAC/B,CACA,SAAS6/B,GAAuB7/B,GAC5B,GAAIA,EAAM,GAAKA,EAAM29B,GAAgB,CACjC,MAAM5c,EAAQ,IAAI7e,MAElB,kCAAkClC,8DAC0B29B,GAAiB,KAE7E,MADA5c,EAAM0e,sBAAuB,EACvB1e,CACV,CACJ,C,YC/RO,MAAM8f,GACT,qBAAAC,CAAsB/e,GAClB,IAAI,EAAAxN,EAAA,GAAIwN,EAAQ,iBAAkB,CAC9B,MAAMgf,EAAoBhf,EAAOif,cAC3BC,EAA6C,kBAAtBF,EAC7B1hC,KAAK6hC,kBAAoBD,EACnBF,EACAI,IACN9hC,KAAK2hC,cAAgBC,EACfF,EAAoB,EACpBA,CACV,MAEI1hC,KAAK6hC,kBAAoB,EACzB7hC,KAAK2hC,cAAgB7e,GAAsB6e,cAE/C3hC,KAAK+hC,iBAAmB,CAC5B,CACA,UAAA/X,CAAWgY,EAAWC,GAGlB,IAA2B,IAAvBjiC,KAAK2hC,cAAwB,CAC7B3hC,KAAK+hC,kBACL,MAAMG,EAAS,IAAI5rB,MAAMtW,KAAK+hC,gBAAkB,GAAGl4B,KAAK,MACpD7J,KAAK+hC,gBAAkB/hC,KAAK6hC,mBAC5BM,QAAQC,IAAI,GAAGF,YAAcF,MAEjC,MAAM,KAAEK,EAAI,MAAEniC,IAAU,EAAAoiC,GAAA,GAAML,GAExBM,EAAcF,EAAO,GAAKF,QAAQK,KAAOL,QAAQC,IAKvD,OAJIpiC,KAAK+hC,gBAAkB/hC,KAAK6hC,mBAC5BU,EAAY,GAAGL,SAAcF,YAAoBK,OAErDriC,KAAK+hC,kBACE7hC,CACX,CAEI,OAAO+hC,GAEf,EC7CG,SAASQ,GAAYC,EAAaC,GACrCA,EAAUpiC,SAASqiC,IACf,MAAMC,EAAYD,EAAS9gB,UAC3B3X,OAAO24B,oBAAoBD,GAAWtiC,SAASwiC,IAC3C,GAAiB,gBAAbA,EACA,OAEJ,MAAMC,EAAqB74B,OAAO84B,yBAAyBJ,EAAWE,GAElEC,IACCA,EAAmBlY,KAAOkY,EAAmBjY,KAC9C5gB,OAAOmiB,eAAeoW,EAAY5gB,UAAWihB,EAAUC,GAGvDN,EAAY5gB,UAAUihB,GAAYH,EAAS9gB,UAAUihB,EACzD,GACF,GAEV,CCAO,MAAMzR,IAAc,QAAoB,KAAK,GAAIpO,IAAKA,IAAKA,IAAKA,IAAKA,IAAKA,KACjF/Y,OAAOC,OAAOknB,IACP,MAAMxO,GAAwB3Y,OAAOC,OAAO,CAC/CyY,iBAAiB,EACjBzP,aAAc,EACdC,sBAAsB,EACtBwb,WAAW,EACX3K,qBAAsB9b,EACtB0mB,qBAAsB,OACtB6S,eAAe,EACfuB,iBAAiB,IAERrL,GAAsB1tB,OAAOC,OAAO,CAC7CqvB,kBAAmB,KAAe,EAClCD,eAAe,IAEZ,IAAI/rB,IACX,SAAWA,GACPA,EAA0BA,EAA0B,qBAAuB,GAAK,oBAChFA,EAA0BA,EAA0B,uBAAyB,GAAK,sBAClFA,EAA0BA,EAA0B,yBAA2B,GAAK,wBACpFA,EAA0BA,EAA0B,yBAA2B,GAAK,wBACpFA,EAA0BA,EAA0B,0BAA4B,GAAK,yBACrFA,EAA0BA,EAA0B,kBAAoB,GAAK,iBAC7EA,EAA0BA,EAA0B,uBAAyB,GAAK,sBAClFA,EAA0BA,EAA0B,kBAAoB,GAAK,iBAC7EA,EAA0BA,EAA0B,mCAAqC,GAAK,kCAC9FA,EAA0BA,EAA0B,sBAAwB,GAAK,qBACjFA,EAA0BA,EAA0B,0BAA4B,IAAM,yBACtFA,EAA0BA,EAA0B,yBAA2B,IAAM,wBACrFA,EAA0BA,EAA0B,iBAAmB,IAAM,gBAC7EA,EAA0BA,EAA0B,+BAAiC,IAAM,6BAC9F,EAfD,CAeGA,KAA8BA,GAA4B,CAAC,IAMvD,MAAM01B,GAIT,0BAAOC,CAAoBC,GACvB,MAAMxgC,MAAM,8HAEhB,CACA,mBAAAugC,GACIpjC,KAAKgqB,WAAW,uBAAuB,KACnC,IAAIsZ,EACJtjC,KAAKqxB,kBAAmB,EACxB,MAAM9U,EAAYvc,KAAKuc,UACvBvc,KAAKgqB,WAAW,eAAe,MAI3B,OAAiBhqB,KAAK,IAE1BA,KAAKgqB,WAAW,qBAAqB,KACjC,IACIhqB,KAAKi/B,mBAEL,EAAA1+B,EAAA,GAAQP,KAAK2c,mBAAoBoE,IAC7B,MAAMwiB,EAAcvjC,KAAK+gB,GACnBkZ,EAAwBsJ,EAAY,yBAC1C,IAAIC,EACJxjC,KAAKgqB,WAAW,GAAGjJ,UAAqB,KACpCyiB,EAAmBxjC,KAAKigC,mBAAmBlf,EAAckZ,EAAsB,IAEnFj6B,KAAK2wB,qBAAqB5P,GAAgByiB,CAAgB,GAElE,CACA,QACIxjC,KAAK+/B,kBACT,KAEJ,IAAI0D,EAAiB,GA2CrB,GA1CAzjC,KAAKgqB,WAAW,qBAAqB,KACjCyZ,EAAiB,GAAe,CAC5BzpB,OAAO,OAAOha,KAAK2wB,wBAEvB3wB,KAAK83B,iBAAmB93B,KAAK83B,iBAAiBxyB,OAAOm+B,EAAe,IAExEzjC,KAAKgqB,WAAW,uBAAuB,KAGnC,IAAI,EAAAvb,EAAA,GAAQg1B,KAA4C,IAAzBzjC,KAAKkjC,gBAA2B,CAC3D,MAAMQ,EAAmB,GAAgB,CACrC1pB,OAAO,OAAOha,KAAK2wB,sBACnB1W,YAAY,OAAOja,KAAKg5B,WACxBhsB,eAAgBvC,GAChBoC,YAAa0P,IAEXonB,EAA4B/pB,GAAkB,CAChDE,kBAAmB9Z,KAAK8Z,kBACxBE,OAAO,OAAOha,KAAK2wB,sBACnB1W,YAAY,OAAOja,KAAKg5B,WACxBnsB,YAAa0P,IAEjBvc,KAAK83B,iBAAmB93B,KAAK83B,iBAAiBxyB,OAAOo+B,EAAkBC,EAC3E,MAGA,EAAAl1B,EAAA,GAAQzO,KAAK83B,oBAET93B,KAAK6iB,iBACL7iB,KAAKgqB,WAAW,0BAA0B,KACtC,MAAM4Z,EAAa97B,GAAuB,OAAO9H,KAAK2wB,uBACtD3wB,KAAK4iB,cAAgBghB,CAAU,IAGvC5jC,KAAKgqB,WAAW,6BAA6B,KACzC,IAAId,EAAI2a,EAC4C,QAAnDA,GAAM3a,EAAKlpB,KAAK8Z,mBAAmBgqB,kBAA+B,IAAPD,GAAyBA,EAAGnvB,KAAKwU,EAAI,CAC7FlP,OAAO,OAAOha,KAAK2wB,wBAEvB3wB,KAAK+pB,8BAA6B,OAAO/pB,KAAK2wB,sBAAsB,MAGvEwS,GAAOY,oCACP,EAAAt1B,EAAA,GAAQzO,KAAK83B,kBAEd,MADAwL,GAAgB,OAAItjC,KAAK83B,kBAAmBpc,GAAaA,EAASlO,UAC5D,IAAI3K,MAAM,wCAAwCygC,EAAcz5B,KAAK,yCAC/E,GAER,CACA,WAAA1J,CAAYy4B,EAAiBlW,GACzB1iB,KAAK83B,iBAAmB,GACxB93B,KAAKqxB,kBAAmB,EACxB,MAAM2O,EAAOhgC,KAUb,GATAggC,EAAKjD,iBAAiBra,GACtBsd,EAAKhP,mBACLgP,EAAKpW,eAAelH,GACpBsd,EAAKrH,qBAAqBC,EAAiBlW,GAC3Csd,EAAKvd,gBAAgBC,GACrBsd,EAAKrR,gBAAgBjM,GACrBsd,EAAKtC,oBACLsC,EAAKlB,iBAAiBpc,GACtBsd,EAAKyB,sBAAsB/e,IACvB,EAAAxN,EAAA,GAAIwN,EAAQ,iBACZ,MAAM,IAAI7f,MAAM,uQAKpB7C,KAAKkjC,iBAAkB,EAAAhuB,EAAA,GAAIwN,EAAQ,mBAC7BA,EAAOwgB,gBACPpgB,GAAsBogB,eAChC,EAQJC,GAAOY,kCAAmC,EAC1CtB,GAAYU,GAAQ,CAChB3gB,GACAmH,GACA+E,GACAqC,GACA2H,GACA7G,GACAiL,GACAW,GACAoB,GACA2C,KAEG,MAAMwC,WAAkBb,GAC3B,WAAAhjC,CAAYy4B,EAAiBlW,EAASI,IAClC,MAAMmhB,GAAc,EAAA71B,EAAA,GAAMsU,GAC1BuhB,EAAYpV,WAAY,EACxBnuB,MAAMk4B,EAAiBqL,EAC3B,E","sources":["webpack://my-project/./node_modules/@chevrotain/gast/lib/src/model.js","webpack://my-project/./node_modules/@chevrotain/gast/lib/src/visitor.js","webpack://my-project/./node_modules/@chevrotain/gast/lib/src/helpers.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/rest.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/first.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/constants.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/follow.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/errors_public.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/resolver.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/checks.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/exceptions_public.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/keys.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/cst/cst.js","webpack://my-project/./node_modules/chevrotain/lib/src/lang/lang_extensions.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js","webpack://my-project/./node_modules/chevrotain/lib/src/parse/parser/parser.js"],"sourcesContent":["import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nexport class AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(_definition) {\n        this._definition = _definition;\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        forEach(this.definition, (prod) => {\n            prod.accept(visitor);\n        });\n    }\n}\nexport class NonTerminal extends AbstractProduction {\n    constructor(options) {\n        super([]);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    set definition(definition) {\n        // immutable\n    }\n    get definition() {\n        if (this.referencedRule !== undefined) {\n            return this.referencedRule.definition;\n        }\n        return [];\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n}\nexport class Rule extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.orgText = \"\";\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternative extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Option extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Repetition extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternation extends AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Terminal {\n    constructor(options) {\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    accept(visitor) {\n        visitor.visit(this);\n    }\n}\nexport function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction);\n}\nexport function serializeProduction(node) {\n    function convertDefinition(definition) {\n        return map(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        const serializedNonTerminal = {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: \"Alternative\",\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Terminal) {\n        const serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: tokenLabel(node.terminalType),\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedTerminal.terminalLabel = node.label;\n        }\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = isRegExp(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition),\n        };\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=model.js.map","import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport class GAstVisitor {\n    visit(node) {\n        const nodeAny = node;\n        switch (nodeAny.constructor) {\n            case NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case Alternative:\n                return this.visitAlternative(nodeAny);\n            case Option:\n                return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n                return this.visitRepetition(nodeAny);\n            case Alternation:\n                return this.visitAlternation(nodeAny);\n            case Terminal:\n                return this.visitTerminal(nodeAny);\n            case Rule:\n                return this.visitRule(nodeAny);\n            /* c8 ignore next 2 */\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) { }\n    /* c8 ignore next */\n    visitAlternative(node) { }\n    /* c8 ignore next */\n    visitOption(node) { }\n    /* c8 ignore next */\n    visitRepetition(node) { }\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) { }\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) { }\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) { }\n    /* c8 ignore next */\n    visitAlternation(node) { }\n    /* c8 ignore next */\n    visitTerminal(node) { }\n    /* c8 ignore next */\n    visitRule(node) { }\n}\n//# sourceMappingURL=visitor.js.map","import { every, includes, some } from \"lodash-es\";\nimport { AbstractProduction, Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport function isSequenceProd(prod) {\n    return (prod instanceof Alternative ||\n        prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionMandatory ||\n        prod instanceof RepetitionMandatoryWithSeparator ||\n        prod instanceof RepetitionWithSeparator ||\n        prod instanceof Terminal ||\n        prod instanceof Rule);\n}\nexport function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional = prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionWithSeparator;\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n        // for OR its enough for just one of the alternatives to be optional\n        return some(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof AbstractProduction) {\n        if (prod instanceof NonTerminal) {\n            alreadyVisited.push(prod);\n        }\n        return every(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nexport function isBranchingProd(prod) {\n    return prod instanceof Alternation;\n}\nexport function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=helpers.js.map","import { drop, forEach } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport class RestWalker {\n    walk(prod, prevRest = []) {\n        forEach(prod.definition, (subProd, index) => {\n            const currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) { }\n    walkProdRef(refProd, currRest, prevRest) { }\n    walkFlat(flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        const fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        const fullManyRest = [\n            new Option({ definition: manyProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        const fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, (alt) => {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            const prodWrapper = new Alternative({ definition: [alt] });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n}\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator }),\n            ].concat(repSepProd.definition),\n        }),\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map","import { flatten, map, uniq } from \"lodash-es\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd, NonTerminal, Terminal, } from \"@chevrotain/gast\";\nexport function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function firstForSequence(prod) {\n    let firstSet = [];\n    const seq = prod.definition;\n    let nextSubProdIdx = 0;\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    let currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n        return first(innerProd);\n    });\n    return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map","// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map","import { RestWalker } from \"./rest.js\";\nimport { first } from \"./first.js\";\nimport { assign, forEach } from \"lodash-es\";\nimport { IN } from \"../constants.js\";\nimport { Alternative } from \"@chevrotain/gast\";\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n        super();\n        this.topProd = topProd;\n        this.follows = {};\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.follows;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        const fullRest = currRest.concat(prevRest);\n        const restProd = new Alternative({ definition: fullRest });\n        const t_in_topProd_follows = first(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    }\n}\nexport function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {};\n    forEach(topProductions, (topProd) => {\n        const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        assign(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nexport function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN;\n}\nexport function buildInProdFollowPrefix(terminal) {\n    const terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + IN;\n}\n//# sourceMappingURL=follow.js.map","import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport { getProductionDslName, NonTerminal, Rule, Terminal, } from \"@chevrotain/gast\";\nexport const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n        const hasLabel = hasTokenLabel(expected);\n        const expectedMsg = hasLabel\n            ? `--> ${tokenLabel(expected)} <--`\n            : `token of type --> ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n            const nextValidTokenSequences = map(allLookAheadPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\", \")}]`);\n            const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\"\\n\")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const nextValidTokenSequences = map(expectedIterationPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\",\")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n                `<${nextValidTokenSequences.join(\" ,\")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n};\nObject.freeze(defaultParserErrorProvider);\nexport const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    },\n};\nexport const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = first(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = getProductionDslName(duplicateProd);\n        const extraArgument = getExtraProductionArgument(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError(rule) {\n        const errMsg = `Namespace conflict found in grammar.\\n` +\n            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n            `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n            `and Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\\n` +\n            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n            `For Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}>` +\n            ` inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n        currMessage =\n            currMessage +\n                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n                `For Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError(options) {\n        let dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n            `This could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError(options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n            `Only the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError(options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` +\n            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError(options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name);\n        const leftRecursivePath = `${ruleName} --> ${pathNames\n            .concat([ruleName])\n            .join(\" --> \")}`;\n        const errMsg = `Left Recursion found in grammar.\\n` +\n            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n            `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n            ` To fix this refactor your grammar to remove the left recursion.\\n` +\n            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError(options) {\n        let ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    },\n};\n//# sourceMappingURL=errors_public.js.map","import { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { forEach, values } from \"lodash-es\";\nimport { GAstVisitor } from \"@chevrotain/gast\";\nexport function resolveGrammar(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nexport class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n        super();\n        this.nameToTopRule = nameToTopRule;\n        this.errMsgProvider = errMsgProvider;\n        this.errors = [];\n    }\n    resolveRefs() {\n        forEach(values(this.nameToTopRule), (prod) => {\n            this.currTopLevel = prod;\n            prod.accept(this);\n        });\n    }\n    visitNonTerminal(node) {\n        const ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName,\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    }\n}\n//# sourceMappingURL=resolver.js.map","import { clone, drop, dropRight, first as _first, forEach, isEmpty, last, } from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nexport class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n        super();\n        this.topProd = topProd;\n        this.path = path;\n        this.possibleTokTypes = [];\n        this.nextProductionName = \"\";\n        this.nextProductionOccurrence = 0;\n        this.found = false;\n        this.isAtEndOfPath = false;\n    }\n    startWalking() {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    }\n    walk(prod, prevRest = []) {\n        // stop scanning once we found the path\n        if (!this.found) {\n            super.walk(prod, prevRest);\n        }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            const fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    }\n    updateExpectedNext() {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    }\n}\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n        super(topProd, path);\n        this.path = path;\n        this.nextTerminalName = \"\";\n        this.nextTerminalOccurrence = 0;\n        this.nextTerminalName = this.path.lastTok.name;\n        this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            const fullRest = currRest.concat(prevRest);\n            const restProd = new Alternative({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    }\n}\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n        super();\n        this.topRule = topRule;\n        this.occurrence = occurrence;\n        this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined,\n        };\n    }\n    startWalking() {\n        this.walk(this.topRule);\n        return this.result;\n    }\n}\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            const firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            super.walkMany(manyProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            const firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            super.walkManySep(manySepProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n        }\n    }\n}\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            const firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n        }\n    }\n}\nexport function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath);\n    let result = [];\n    let i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        const prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            const newDef = [\n                new Alternative({ definition: prod.definition }),\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, (currAlt) => {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if (isEmpty(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i),\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    let foundCompletePath = false;\n    const tokenVectorLength = tokenVector.length;\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    const result = [];\n    const possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: [],\n    });\n    while (!isEmpty(possiblePaths)) {\n        const currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        const currDef = currPath.def;\n        const currIdx = currPath.idx;\n        const currRuleStack = currPath.ruleStack;\n        const currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        const prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            const nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack),\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                const nextIdx = currIdx + 1;\n                const actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    const nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack,\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            const newRuleStack = clone(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            const newOccurrenceStack = clone(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            const nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            const nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (let i = prod.definition.length - 1; i >= 0; i--) {\n                const currAlt = prod.definition[i];\n                const currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack);\n    newRuleStack.push(topRule.name);\n    const newCurrOccurrenceStack = clone(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack,\n    };\n}\n//# sourceMappingURL=interpreter.js.map","import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\nimport { possiblePathsFrom } from \"./interpreter.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../scan/tokens.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, } from \"@chevrotain/gast\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory ||\n        prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator ||\n        prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator ||\n        prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function getLookaheadPaths(options) {\n    const { occurrence, rule, prodType, maxLookahead } = options;\n    const type = getProdType(prodType);\n    if (type === PROD_TYPE.ALTERNATION) {\n        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    }\n    else {\n        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length;\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n        return every(currAlt, (currPath) => {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            const predicates = map(orAlts, (currAlt) => currAlt.GATE);\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                const currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        const singleTokenAlts = map(alts, (currAlt) => {\n            return flatten(currAlt);\n        });\n        const choiceToAlt = reduce(singleTokenAlts, (result, currAlt, idx) => {\n            forEach(currAlt, (currTokType) => {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, {});\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            const nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n        return currPath.length === 1;\n    });\n    const numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            const expectedTokenType = singleTokensTypes[0];\n            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n            };\n        }\n        else {\n            const choiceToAlt = reduce(singleTokensTypes, (result, currTokType, idx) => {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (let j = 0; j < numOfPaths; j++) {\n                const currPath = alt[j];\n                const currPathLength = currPath.length;\n                for (let i = 0; i < currPathLength; i++) {\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nclass RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n        super();\n        this.topProd = topProd;\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.restDef;\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            super.walkOption(optionProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            super.walkOption(atLeastOneProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(atLeastOneSepProd, currRest, prevRest);\n        }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            super.walkOption(manyProd, currRest, prevRest);\n        }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(manySepProd, currRest, prevRest);\n        }\n    }\n}\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n        super();\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n        this.targetRef = targetRef;\n        this.result = [];\n    }\n    checkIsTarget(node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    }\n    visitOption(node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    }\n    visitRepetition(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    }\n    visitRepetitionMandatory(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    }\n    visitRepetitionWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    }\n    visitAlternation(node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    }\n}\nfunction initializeArrayOfArrays(size) {\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    let keys = [\"\"];\n    for (let i = 0; i < path.length; i++) {\n        const tokType = path[i];\n        const longerKeys = [];\n        for (let j = 0; j < keys.length; j++) {\n            const currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (let t = 0; t < tokType.categoryMatches.length; t++) {\n                const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            const searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n    const finalResult = initializeArrayOfArrays(partialAlts.length);\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n        const dict = {};\n        forEach(currAltPaths, (item) => {\n            const keys = pathToHashKeys(item.partialPath);\n            forEach(keys, (currKey) => {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    let newData = partialAlts;\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n        const currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        // alternatives loop\n        for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            const currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                const prefixKeys = pathToHashKeys(currPathPrefix);\n                const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n                    const currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (let j = 0; j < prefixKeys.length; j++) {\n                            const currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, (item) => {\n                        const prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, (key) => {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    const insideDef = insideDefVisitor.result;\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    const afterDef = afterDefWalker.startWalking();\n    const insideFlat = new AlternativeGAST({ definition: insideDef });\n    const afterFlat = new AlternativeGAST({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n        const otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (let j = 0; j < otherPath.length; j++) {\n            const searchTok = searchPath[j];\n            const otherTok = otherPath[j];\n            const matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, (tokType, idx) => {\n            const otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) => every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))));\n}\n//# sourceMappingURL=lookahead.js.map","import { clone, compact, difference, drop, dropRight, filter, first, flatMap, flatten, forEach, groupBy, includes, isEmpty, map, pickBy, reduce, reject, values, } from \"lodash-es\";\nimport { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, getProductionDslName, isOptionalProd, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath, } from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\nexport function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName,\n    });\n    return map(lookaheadValidationErrorMessages, (errorMessage) => (Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));\n}\nexport function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = flatMap(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n        return currGroup.length > 1;\n    });\n    const errors = map(values(duplicates), (currDuplicates) => {\n        const firstProd = first(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = getProductionDslName(firstProd);\n        const defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx,\n        };\n        const param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nexport class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option) {\n        this.allProductions.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = reduce(allRules, (result, curRule) => {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className,\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name,\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!includes(definedRulesNames, ruleName)) {\n        errMsg =\n            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n                `as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName,\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path,\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName,\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n        const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n            const newPath = clone(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    let result = [];\n    if (isEmpty(definition)) {\n        return result;\n    }\n    const firstProd = first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof AlternativeGAST ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    const isFirstOptional = isOptionalProd(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nclass OrCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n}\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        const exceptLast = dropRight(currOr.definition);\n        return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n            const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n            if (isEmpty(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx,\n                        }),\n                        type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1,\n                    },\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n    const errors = flatMap(ors, (currOr) => {\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nexport class RepetitionCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n}\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                    }),\n                    type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                },\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    forEach(topLevelRules, (currTopRule) => {\n        const collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        const allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, (currProd) => {\n            const prodType = getProdType(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd,\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name,\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, (currPath) => {\n            const altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath,\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n        const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path,\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts,\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = compact(flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path,\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices,\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n    forEach(topLevels, (currRule) => {\n        const currRuleName = currRule.name;\n        if (includes(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName,\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map","import { defaults, forEach } from \"lodash-es\";\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\nimport { defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider, } from \"../../errors_public.js\";\nexport function resolveGrammar(options) {\n    const actualOptions = defaults(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider,\n    });\n    const topRulesTable = {};\n    forEach(options.rules, (rule) => {\n        topRulesTable[rule.name] = rule;\n    });\n    return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\nexport function validateGrammar(options) {\n    options = defaults(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider,\n    });\n    return orgValidateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n//# sourceMappingURL=gast_resolver_public.js.map","import { includes } from \"lodash-es\";\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nconst RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nclass RecognitionException extends Error {\n    constructor(message, token) {\n        super(message);\n        this.token = token;\n        this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(this, new.target.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nexport class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = MISMATCHED_TOKEN_EXCEPTION;\n    }\n}\nexport class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = NO_VIABLE_ALT_EXCEPTION;\n    }\n}\nexport class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n        super(message, token);\n        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n    }\n}\nexport class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = EARLY_EXIT_EXCEPTION;\n    }\n}\n//# sourceMappingURL=exceptions_public.js.map","import { createTokenInstance, EOF, tokenMatcher, } from \"../../../scan/tokens_public.js\";\nimport { clone, dropRight, find, flatten, has, includes, isEmpty, map, } from \"lodash-es\";\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\nimport { IN } from \"../../constants.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nexport const EOF_FOLLOW_KEY = {};\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport class InRuleRecoveryException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = IN_RULE_RECOVERY_EXCEPTION;\n    }\n}\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        // TODO: can the resyncTokenType be cached?\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = () => {\n            const previousToken = this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = find(follows, (possibleFollowsTokType) => {\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return includes(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        let nextToken = this.LA(1);\n        let k = 2;\n        while (true) {\n            const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n                const canMatch = tokenMatcher(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName),\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return map(explicitRuleStack, (ruleName, idx) => {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule,\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n    }\n}\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map","// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nexport const BITS_FOR_METHOD_TYPE = 4;\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\nexport const BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map","import { flatMap, isEmpty } from \"lodash-es\";\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\nimport { validateAmbiguousAlternationAlternatives, validateEmptyOrAlternative, validateNoLeftRecursion, validateSomeNonEmptyLookaheadPath, } from \"./checks.js\";\nimport { buildAlternativesLookAheadFunc, buildLookaheadFuncForOptionalProd, buildLookaheadFuncForOr, buildSingleAlternativeLookaheadFunction, getProdType, } from \"./lookahead.js\";\nexport class LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    validate(options) {\n        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if (isEmpty(leftRecursionErrors)) {\n            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            const allErrors = [\n                ...leftRecursionErrors,\n                ...emptyAltErrors,\n                ...ambiguousAltsErrors,\n                ...emptyRepetitionErrors,\n            ];\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    }\n    validateNoLeftRecursion(rules) {\n        return flatMap(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateEmptyOrAlternatives(rules) {\n        return flatMap(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n        return flatMap(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n        return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n    }\n    buildLookaheadForAlternation(options) {\n        return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n    }\n    buildLookaheadForOptional(options) {\n        return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n    }\n}\n//# sourceMappingURL=llk_lookahead.js.map","import { forEach, has } from \"lodash-es\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { GAstVisitor, getProductionDslName, } from \"@chevrotain/gast\";\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = has(config, \"maxLookahead\")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n            ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n            : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n        this.lookAheadFuncsCache = new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        forEach(rules, (currRule) => {\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);\n                forEach(alternation, (currProd) => {\n                    const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: this.dynamicTokensEnabled,\n                        });\n                        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                forEach(repetition, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(option, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatory, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatoryWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence,\n                rule,\n                maxLookahead: prodMaxLookahead || this.maxLookahead,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n                prodType,\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n}\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    visitOption(option) {\n        this.dslMethods.option.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nexport function collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    const dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=looksahead.js.map","/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\n//# sourceMappingURL=cst.js.map","const NAME = \"name\";\nexport function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue,\n    });\n}\n//# sourceMappingURL=lang_extensions.js.map","import { compact, filter, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map, } from \"lodash-es\";\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\nexport function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for (let i = 0; i < childrenNamesLength; i++) {\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for (let j = 0; j < currChildArrayLength; j++) {\n            const currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    const semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (isArray(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (isUndefined(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!isEmpty(semanticDefinitionErrors)) {\n                const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n                    `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`);\n            }\n        },\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    forEach(ruleNames, (ruleName) => {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n        return isFunction(visitorInstance[currRuleName]) === false;\n    });\n    const errors = map(missingRuleNames, (currRuleName) => {\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName,\n        };\n    });\n    return compact(errors);\n}\n//# sourceMappingURL=cst_visitor.js.map","import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset, } from \"../../cst/cst.js\";\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults, } from \"../../cst/cst_visitor.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop;\n            this.cstFinallyStateUpdate = noop;\n            this.cstPostTerminal = noop;\n            this.cstPostNonTerminal = noop;\n            this.cstPostRule = noop;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = noop;\n            }\n            else {\n                throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n            }\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: Object.create(null),\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n}\n//# sourceMappingURL=tree_builder.js.map","import { END_OF_FILE } from \"../parser.js\";\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        if (this.selfAnalysisDone !== true) {\n            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n        }\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return END_OF_FILE;\n        }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState) {\n        this.currIdx = newState;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n}\n//# sourceMappingURL=lexer_adapter.js.map","import { includes, values } from \"lodash-es\";\nimport { isRecognitionException } from \"../../exceptions_public.js\";\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\nimport { serializeGrammar } from \"@chevrotain/gast\";\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n    ACTION(impl) {\n        return impl.call(this);\n    }\n    consume(idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    }\n    subrule(idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    }\n    option(idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    }\n    or(idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    }\n    many(idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    }\n    atLeastOne(idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    }\n    CONSUME(tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    }\n    CONSUME1(tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    }\n    CONSUME2(tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    }\n    CONSUME3(tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    }\n    CONSUME4(tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    }\n    CONSUME5(tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    }\n    CONSUME6(tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    }\n    CONSUME7(tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    }\n    CONSUME8(tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    }\n    CONSUME9(tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    }\n    SUBRULE(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    }\n    SUBRULE1(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    }\n    SUBRULE2(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    }\n    SUBRULE3(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    }\n    SUBRULE4(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    }\n    SUBRULE5(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    }\n    SUBRULE6(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    }\n    SUBRULE7(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    }\n    SUBRULE8(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    }\n    SUBRULE9(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    }\n    OPTION(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    }\n    OPTION1(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    }\n    OPTION2(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    }\n    OPTION3(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    }\n    OPTION4(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    }\n    OPTION5(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    }\n    OPTION6(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    }\n    OPTION7(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    }\n    OPTION8(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    }\n    OPTION9(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    }\n    OR(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    }\n    OR1(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    }\n    OR2(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    }\n    OR3(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    }\n    OR4(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    }\n    OR5(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    }\n    OR6(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    }\n    OR7(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    }\n    OR8(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    }\n    OR9(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    }\n    MANY(actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    }\n    MANY1(actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    }\n    MANY2(actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    }\n    MANY3(actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    }\n    MANY4(actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    }\n    MANY5(actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    }\n    MANY6(actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    }\n    MANY7(actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    }\n    MANY8(actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    }\n    MANY9(actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    }\n    MANY_SEP(options) {\n        this.manySepFirstInternal(0, options);\n    }\n    MANY_SEP1(options) {\n        this.manySepFirstInternal(1, options);\n    }\n    MANY_SEP2(options) {\n        this.manySepFirstInternal(2, options);\n    }\n    MANY_SEP3(options) {\n        this.manySepFirstInternal(3, options);\n    }\n    MANY_SEP4(options) {\n        this.manySepFirstInternal(4, options);\n    }\n    MANY_SEP5(options) {\n        this.manySepFirstInternal(5, options);\n    }\n    MANY_SEP6(options) {\n        this.manySepFirstInternal(6, options);\n    }\n    MANY_SEP7(options) {\n        this.manySepFirstInternal(7, options);\n    }\n    MANY_SEP8(options) {\n        this.manySepFirstInternal(8, options);\n    }\n    MANY_SEP9(options) {\n        this.manySepFirstInternal(9, options);\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    }\n    AT_LEAST_ONE_SEP(options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    }\n    AT_LEAST_ONE_SEP1(options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    }\n    AT_LEAST_ONE_SEP2(options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    }\n    AT_LEAST_ONE_SEP3(options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    }\n    AT_LEAST_ONE_SEP4(options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    }\n    AT_LEAST_ONE_SEP5(options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    }\n    AT_LEAST_ONE_SEP6(options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    }\n    AT_LEAST_ONE_SEP7(options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    }\n    AT_LEAST_ONE_SEP8(options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    }\n    AT_LEAST_ONE_SEP9(options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n        if (includes(this.definedRulesNames, name)) {\n            const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className,\n            });\n            const error = {\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name,\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        const ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n        const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        const ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    BACKTRACK(grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            const orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if (isRecognitionException(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    }\n    // GAST export APIs\n    getGAstProductions() {\n        return this.gastProductionsCache;\n    }\n    getSerializedGastProductions() {\n        return serializeGrammar(values(this.gastProductionsCache));\n    }\n}\n//# sourceMappingURL=recognizer_api.js.map","import { clone, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values, } from \"lodash-es\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException, } from \"../../exceptions_public.js\";\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker, } from \"../../grammar/interpreter.js\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser.js\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\nimport { EOF } from \"../../../scan/tokens_public.js\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../../scan/tokens.js\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (isArray(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (has(tokenVocabulary, \"modes\") &&\n            every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            const allTokenTypes = flatten(values(tokenVocabulary.modes));\n            const uniqueTokens = uniq(allTokenTypes);\n            this.tokensMap = reduce(uniqueTokens, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (isObject(tokenVocabulary)) {\n            this.tokensMap = clone(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = EOF;\n        const allTokenTypes = has(tokenVocabulary, \"modes\")\n            ? flatten(values(tokenVocabulary.modes))\n            : values(tokenVocabulary);\n        const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes(values(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n                `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n        }\n        const resyncEnabled = has(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc(e);\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc(e);\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker,\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        let notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker,\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker,\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    }\n    saveRecogState() {\n        // errors is a getter which will clone the errors array\n        const savedErrors = this.errors;\n        const savedRuleStack = clone(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n        };\n    }\n    reloadRecogState(newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n}\n//# sourceMappingURL=recognizer_engine.js.map","import { EarlyExitException, isRecognitionException, NoViableAltException, } from \"../../exceptions_public.js\";\nimport { clone, has } from \"lodash-es\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, } from \"../../grammar/lookahead.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = has(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    }\n    get errors() {\n        return clone(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName,\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName(),\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n}\n//# sourceMappingURL=error_handler.js.map","import { NextAfterTokenWalker, nextPossibleTokensAfter, } from \"../../grammar/interpreter.js\";\nimport { first, isUndefined } from \"lodash-es\";\nexport class ContentAssist {\n    initContentAssist() { }\n    computeContentAssist(startRuleName, precedingInput) {\n        const startRuleGast = this.gastProductionsCache[startRuleName];\n        if (isUndefined(startRuleGast)) {\n            throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n        }\n        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n        const topRuleName = first(grammarPath.ruleStack);\n        const gastProductions = this.getGAstProductions();\n        const topProduction = gastProductions[topRuleName];\n        const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    }\n}\n//# sourceMappingURL=context_assist.js.map","import { forEach, has, isArray, isFunction, last as peek, some, } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nimport { Lexer } from \"../../../scan/lexer_public.js\";\nimport { augmentTokenTypes, hasShortKeyProperty, } from \"../../../scan/tokens.js\";\nimport { createToken, createTokenInstance, } from \"../../../scan/tokens_public.js\";\nimport { END_OF_FILE } from \"../parser.js\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\nconst RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nconst RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {},\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n    initGastRecorder(config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    }\n    enableRecording() {\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", () => {\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                this[`CONSUME${idx}`] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                this[`SUBRULE${idx}`] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                this[`OPTION${idx}`] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                this[`OR${idx}`] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                this[`MANY${idx}`] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                this[`MANY_SEP${idx}`] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            }\n            // DSL methods with the idx(suffix) as an argument\n            this[`consume`] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            this[`subrule`] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            this[`option`] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            this[`or`] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            this[`many`] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            this[`atLeastOne`] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            this.ACTION = this.ACTION_RECORD;\n            this.BACKTRACK = this.BACKTRACK_RECORD;\n            this.LA = this.LA_RECORD;\n        });\n    }\n    disableRecording() {\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", () => {\n            const that = this;\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                delete that[`CONSUME${idx}`];\n                delete that[`SUBRULE${idx}`];\n                delete that[`OPTION${idx}`];\n                delete that[`OR${idx}`];\n                delete that[`MANY${idx}`];\n                delete that[`MANY_SEP${idx}`];\n                delete that[`AT_LEAST_ONE${idx}`];\n                delete that[`AT_LEAST_ONE_SEP${idx}`];\n            }\n            delete that[`consume`];\n            delete that[`subrule`];\n            delete that[`option`];\n            delete that[`or`];\n            delete that[`many`];\n            delete that[`atLeastOne`];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n        // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n        return () => true;\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    }\n    topLevelRuleRecord(name, def) {\n        try {\n            const newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const ruleName = ruleToCall.ruleName;\n        const newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    }\n}\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    const newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    // Only an array of alternatives\n    const hasOptions = isArray(mainProdArg) === false;\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    const newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    });\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE));\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    forEach(alts, (currAlt) => {\n        const currAltFlat = new Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(this);\n        this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n            `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map","import { has } from \"lodash-es\";\nimport { timer } from \"@chevrotain/utils\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n    initPerformanceTracer(config) {\n        if (has(config, \"traceInitPerf\")) {\n            const userTraceInitPerf = config.traceInitPerf;\n            const traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf; // assumes end user provides the correct config value/type\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(`${indent}--> <${phaseDesc}>`);\n            }\n            const { time, value } = timer(phaseImpl);\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            const traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    }\n}\n//# sourceMappingURL=perf_tracer.js.map","export function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n        const baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n            if (propName === \"constructor\") {\n                return;\n            }\n            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n//# sourceMappingURL=apply_mixins.js.map","import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\nimport { toFastProperties } from \"@chevrotain/utils\";\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\nimport { defaultGrammarValidatorErrorProvider, defaultParserErrorProvider, } from \"../errors_public.js\";\nimport { resolveGrammar, validateGrammar, } from \"../grammar/gast/gast_resolver_public.js\";\nimport { Recoverable } from \"./traits/recoverable.js\";\nimport { LooksAhead } from \"./traits/looksahead.js\";\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\nimport { ErrorHandler } from \"./traits/error_handler.js\";\nimport { ContentAssist } from \"./traits/context_assist.js\";\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\nimport { applyMixins } from \"./utils/apply_mixins.js\";\nimport { validateLookahead } from \"../grammar/checks.js\";\nexport const END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nexport const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false,\n});\nexport const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n});\nexport var ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nexport function EMPTY_ALT(value = undefined) {\n    return function () {\n        return value;\n    };\n}\nexport class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT(\"performSelfAnalysis\", () => {\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT(\"toFastProps\", () => {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                toFastProperties(this);\n            });\n            this.TRACE_INIT(\"Grammar Recording\", () => {\n                try {\n                    this.enableRecording();\n                    // Building the GAST\n                    forEach(this.definedRulesNames, (currRuleName) => {\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT(\"Grammar Resolving\", () => {\n                resolverErrors = resolveGrammar({\n                    rules: values(this.gastProductionsCache),\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT(\"Grammar Validations\", () => {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if (isEmpty(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = validateGrammar({\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        errMsgProvider: defaultGrammarValidatorErrorProvider,\n                        grammarName: className,\n                    });\n                    const lookaheadValidationErrors = validateLookahead({\n                        lookaheadStrategy: this.lookaheadStrategy,\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        grammarName: className,\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if (isEmpty(this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (this.recoveryEnabled) {\n                    this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n                        const allFollows = computeAllProdsFollows(values(this.gastProductionsCache));\n                        this.resyncFollows = allFollows;\n                    });\n                }\n                this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n                    var _a, _b;\n                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                        rules: values(this.gastProductionsCache),\n                    });\n                    this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !isEmpty(this.definitionErrors)) {\n                defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message);\n                throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n            }\n        });\n    }\n    constructor(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if (has(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = has(config, \"skipValidations\")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n}\n// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n// (normally during the parser's constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n]);\nexport class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = true;\n        super(tokenVocabulary, configClone);\n    }\n}\nexport class EmbeddedActionsParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n}\n//# sourceMappingURL=parser.js.map"],"names":["tokenLabel","tokType","hasTokenLabel","LABEL","name","obj","isString","AbstractProduction","definition","this","_definition","value","constructor","accept","visitor","visit","forEach","prod","options","super","idx","pickBy","v","undefined","referencedRule","Rule","orgText","Alternative","ignoreAmbiguities","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","Alternation","hasPredicates","Terminal","serializeGrammar","topRules","serializeProduction","node","convertDefinition","serializedNonTerminal","type","nonTerminalName","label","separator","terminalType","serializedTerminal","terminalLabel","pattern","PATTERN","isRegExp","source","Error","nodeAny","visitNonTerminal","visitAlternative","visitOption","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitRepetition","visitAlternation","visitTerminal","visitRule","isSequenceProd","isOptionalProd","alreadyVisited","isDirectlyOptional","subProd","includes","push","every","isBranchingProd","getProductionDslName","RestWalker","walk","prevRest","index","currRest","drop","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","terminal","refProd","flatProd","fullOrRest","concat","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","repSepRest","fullRepSepRest","first","firstForTerminal","firstForSequence","firstForBranching","firstSet","seq","currSubProd","nextSubProdIdx","hasInnerProdsRemaining","length","isLastInnerProdOptional","uniq","allAlternativesFirsts","innerProd","ResyncFollowsWalker","topProd","follows","startWalking","followName","buildBetweenProdsFollowPrefix","fullRest","restProd","t_in_topProd_follows","computeAllProdsFollows","topProductions","reSyncFollows","currRefsFollow","inner","occurenceInParent","defaultParserErrorProvider","buildMismatchTokenMessage","expected","actual","previous","ruleName","hasLabel","expectedMsg","msg","image","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","reduce","result","currAltPaths","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","calculatedDescription","buildEarlyExitMessage","expectedIterationPaths","Object","freeze","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","topLevelName","duplicateProd","dslName","extraArgument","hasExplicitIndex","replace","buildNamespaceConflictError","rule","errMsg","buildAlternationPrefixAmbiguityError","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName","resolveGrammar","topLevels","errMsgProvider","refResolver","GastRefResolverVisitor","resolveRefs","errors","nameToTopRule","currTopLevel","ref","message","ParserDefinitionErrorType","UNRESOLVED_SUBRULE_REF","unresolvedRefName","AbstractNextPossibleTokensWalker","path","possibleTokTypes","nextProductionName","nextProductionOccurrence","found","isAtEndOfPath","ruleStack","clone","reverse","occurrenceStack","pop","updateExpectedNext","isEmpty","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","AbstractNextTerminalAfterProductionWalker","topRule","token","isEndOfRule","NextTerminalAfterManyWalker","firstAfterMany","NextTerminalAfterManySepWalker","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","newDef","currAlt","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","last","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","dropRight","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack","PROD_TYPE","getProdType","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","buildLookaheadFuncForOr","ruleGrammar","maxLookahead","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","tokenMatcher","areTokenCategoriesNotUsed","buildLookaheadFuncForOptionalProd","k","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","call","j","currPathLength","nextToken","LA","singleTokenAlts","choiceToAlt","currTokType","has","tokenTypeIdx","categoryMatches","currExtendingType","buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey","RestDefinitionFinderWalker","targetOccurrence","targetProdType","restDef","checkIsTarget","expectedProdType","InsideDefinitionFinderVisitor","targetRef","expectedProdName","initializeArrayOfArrays","size","Array","pathToHashKeys","keys","longerKeys","currShorterKey","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","item","currKey","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","key","insideDefVisitor","insideDef","afterDefWalker","afterDef","insideFlat","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","categoryMatchesMap","isStrictPrefixOfPath","prefix","other","otherTokType","singleAltPaths","singlePath","validateLookahead","lookaheadValidationErrorMessages","lookaheadStrategy","validate","rules","tokenTypes","errorMessage","assign","CUSTOM_LOOKAHEAD_VALIDATION","validateGrammar","duplicateErrors","flatMap","validateDuplicateProductions","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","collectorVisitor","OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","currDuplicates","firstProd","defError","DUPLICATE_PRODUCTIONS","param","parameter","arguments","subrule","option","manySep","atLeastOne","atLeastOneSep","many","or","allRules","className","occurrences","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","nextNonTerminals","getFirstNoneTerminal","foundLeftRecursion","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","currSubDef","isFirstOptional","hasMore","rest","OrCollector","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","possibleFirstInAlt","NONE_LAST_EMPTY_ALT","validateAmbiguousAlternationAlternatives","globalMaxLookahead","reject","currOccurrence","actualMaxLookahead","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","TOO_MANY_ALTS","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","paths","pathsInsideProduction","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currErrors","currAmbDescriptor","ambgIndices","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","compact","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","filter","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","CONFLICT_TOKENS_RULES_NAMESPACE","actualOptions","defaults","topRulesTable","MISMATCHED_TOKEN_EXCEPTION","NO_VIABLE_ALT_EXCEPTION","EARLY_EXIT_EXCEPTION","NOT_ALL_INPUT_PARSED_EXCEPTION","RECOGNITION_EXCEPTION_NAMES","isRecognitionException","error","RecognitionException","resyncedTokens","setPrototypeOf","prototype","captureStackTrace","MismatchedTokenException","previousToken","NoViableAltException","NotAllInputParsedException","EarlyExitException","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","Recoverable","initRecoverable","config","firstAfterRepMap","resyncFollows","recoveryEnabled","DEFAULT_PARSER_CONFIG","attemptInRepetitionRecovery","getTokenToInsert","tokToInsert","NaN","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","canTokenTypeBeDeletedInRecovery","tryInRepetitionRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","errorMessageProvider","getCurrRuleFullName","SAVE_ERROR","apply","SKIP_TOKEN","addToResyncTokens","importLexerState","shouldInRepetitionRecoveryBeTried","expectTokAfterLastMatch","nextTokIdx","notStuck","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","isMisMatchedTokInFollows","find","possibleFollowsTokType","isNextTokenWhatIsExpected","isInCurrentRuleReSyncSet","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","foundMatch","resyncTokType","canMatch","RULE_STACK","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","followStack","resyncTokens","reSyncTo","prodFunc","args","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","pathRuleStack","getHumanReadableRuleStack","pathOccurrenceStack","currShortName","getKeyForAutomaticLookahead","firstAfterRepInfo","getGAstProductions","walker","BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","OR_IDX","OPTION_IDX","MANY_IDX","AT_LEAST_ONE_IDX","MANY_SEP_IDX","AT_LEAST_ONE_SEP_IDX","ruleIdx","LLkLookaheadStrategy","_a","leftRecursionErrors","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","emptyRepetitionErrors","allErrors","buildLookaheadForAlternation","buildLookaheadForOptional","LooksAhead","initLooksAhead","lookAheadFuncsCache","Map","preComputeLookaheadFunctions","TRACE_INIT","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","collectMethods","prodIdx","laFunc","fullRuleNameToShort","setLaFuncCache","computeLookaheadFunc","prodKey","prodMaxLookahead","dslMethodName","getLaFuncFromCache","get","set","DslMethodsCollectorVisitor","dslMethods","reset","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","startOffset","endOffset","setNodeLocationFull","startColumn","startLine","endColumn","endLine","addTerminalToCst","tokenTypeName","children","addNoneTerminalToCst","ruleResult","NAME","defineNameProp","nameValue","defineProperty","enumerable","configurable","writable","defaultVisit","ctx","childrenNames","childrenNamesLength","currChildName","currChildArray","currChildArrayLength","currChild","createBaseSemanticVisitorConstructor","ruleNames","derivedConstructor","semanticProto","cstNode","isArray","isUndefined","validateVisitor","semanticDefinitionErrors","errorMessages","currDefError","_RULE_NAMES","createBaseVisitorConstructorWithDefaults","baseConstructor","withDefaultsProto","create","CstVisitorDefinitionError","visitorInstance","missingErrors","validateMissingCstMethods","missingRuleNames","isFunction","MISSING_METHOD","methodName","TreeBuilder","initTreeBuilder","CST_STACK","outputCst","nodeLocationTracking","test","setNodeLocationFromToken","setNodeLocationFromNode","cstPostRule","noop","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","location","fullRuleName","ruleCstNode","prevToken","loc","consumedToken","rootCst","ruleCstResult","preCstNode","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","gastProductionsCache","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","LexerAdapter","initLexerAdapter","tokVector","tokVectorLength","input","newInput","selfAnalysisDone","END_OF_FILE","howMuch","soughtIdx","newState","resetLexerState","moveToTerminatedState","getLexerPosition","RecognizerApi","ACTION","impl","consume","consumeInternal","ruleToCall","subruleInternal","actionORMethodDef","optionInternal","altsOrOpts","orInternal","manyInternal","atLeastOneInternal","CONSUME","CONSUME1","CONSUME2","CONSUME3","CONSUME4","CONSUME5","CONSUME6","CONSUME7","CONSUME8","CONSUME9","SUBRULE","SUBRULE1","SUBRULE2","SUBRULE3","SUBRULE4","SUBRULE5","SUBRULE6","SUBRULE7","SUBRULE8","SUBRULE9","OPTION1","OPTION2","OPTION3","OPTION4","OPTION5","OPTION6","OPTION7","OPTION8","OPTION9","OR","OR1","OR2","OR3","OR4","OR5","OR6","OR7","OR8","OR9","MANY","MANY1","MANY2","MANY3","MANY4","MANY5","MANY6","MANY7","MANY8","MANY9","MANY_SEP","manySepFirstInternal","MANY_SEP1","MANY_SEP2","MANY_SEP3","MANY_SEP4","MANY_SEP5","MANY_SEP6","MANY_SEP7","MANY_SEP8","MANY_SEP9","AT_LEAST_ONE","AT_LEAST_ONE1","AT_LEAST_ONE2","AT_LEAST_ONE3","AT_LEAST_ONE4","AT_LEAST_ONE5","AT_LEAST_ONE6","AT_LEAST_ONE7","AT_LEAST_ONE8","AT_LEAST_ONE9","AT_LEAST_ONE_SEP","atLeastOneSepFirstInternal","AT_LEAST_ONE_SEP1","AT_LEAST_ONE_SEP2","AT_LEAST_ONE_SEP3","AT_LEAST_ONE_SEP4","AT_LEAST_ONE_SEP5","AT_LEAST_ONE_SEP6","AT_LEAST_ONE_SEP7","AT_LEAST_ONE_SEP8","AT_LEAST_ONE_SEP9","RULE","implementation","DEFAULT_RULE_CONFIG","definitionErrors","ruleImplementation","defineRule","OVERRIDE_RULE","ruleErrors","BACKTRACK","isBackTrackingStack","orgState","saveRecogState","e","reloadRecogState","getSerializedGastProductions","RecognizerEngine","initRecognizerEngine","tokenVocabulary","shortRuleNameToFull","ruleShortNameIdx","subruleIdx","tokensMap","acc","modes","allTokenTypes","uniqueTokens","isObject","noTokenCategoriesUsed","tokenConstructor","resyncEnabled","recoveryValueFunc","shortName","invokeRuleWithTry","ruleInvocationStateUpdate","cst","invokeRuleCatch","ruleFinallyStateUpdate","wrappedGrammarRule","originalGrammarAction","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","recoveredNode","optionInternalLogic","action","DEF","predicate","orgLookaheadFunction","laKey","atLeastOneInternalLogic","raiseEarlyExitException","ERR_MSG","doSingleRepetition","atLeastOneSepFirstInternalLogic","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","repetitionSepSecondInternal","manyInternalLogic","lookaheadFunction","manySepFirstInternalLogic","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","afterIteration","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","isAtEndOfInput","firstRedundantTok","ARGS","subruleInternalError","consumeInternalError","eFromConsumption","consumeInternalRecovery","eFromInRuleRecovery","savedErrors","savedRuleStack","lexerState","fullName","ErrorHandler","initErrorHandler","_errors","context","ruleOccurrenceStack","newErrors","userDefinedErrMsg","lookAheadPathsPerAlternative","insideProdPaths","actualTokens","errMsgTypes","ContentAssist","initContentAssist","computeContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","gastProductions","topProduction","nextPossibleTokenTypes","RECORDING_NULL_OBJECT","description","HANDLE_SEPARATOR","MAX_METHOD_IDX","Math","pow","RFT","NA","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","GastRecorder","initGastRecorder","recordingProdStack","RECORDING_PHASE","enableRecording","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION_RECORD","BACKTRACK_RECORD","LA_RECORD","disableRecording","that","topLevelRuleRecord","newTopLevelRule","originalError","KNOWN_RECORDER_ERROR","mutabilityError","recordProd","recordOrProd","assertMethodIdxIsValid","getIdxSuffix","JSON","stringify","prevProd","newNoneTerminal","prodConstructor","mainProdArg","handleSep","grammarAction","newProd","MAX_LOOKAHEAD","hasOptions","newOrProd","IGNORE_AMBIGUITIES","currAltFlat","PerformanceTracer","initPerformanceTracer","userTraceInitPerf","traceInitPerf","traceIsNumber","traceInitMaxIdent","Infinity","traceInitIndent","phaseDesc","phaseImpl","indent","console","log","time","timer","traceMethod","warn","applyMixins","derivedCtor","baseCtors","baseCtor","baseProto","getOwnPropertyNames","propName","basePropDescriptor","getOwnPropertyDescriptor","skipValidations","Parser","performSelfAnalysis","parserInstance","defErrorsMsgs","wrappedRule","recordedRuleGast","resolverErrors","validationErrors","lookaheadValidationErrors","allFollows","_b","initialize","DEFER_DEFINITION_ERRORS_HANDLING","CstParser","configClone"],"sourceRoot":""}