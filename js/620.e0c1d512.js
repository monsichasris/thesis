"use strict";(self["webpackChunkmy_project"]=self["webpackChunkmy_project"]||[]).push([[620],{2566:function(e,t,n){n.d(t,{P:function(){return o}});const o={buildUnableToPopLexerModeMessage(e){return`Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`},buildUnexpectedCharactersMessage(e,t,n,o,i){return`unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${n} characters.`}}},6495:function(e,t,n){n.d(t,{J:function(){return be},_:function(){return ye}});var o=n(5186),i=n(3068),r=n(1254),s=n(2636),a=n(7572),c=n(2531),h=n(9610),u=n(9703),l=n(9592),T=n(2049),d=n(3249),A=n(8585),f=n(9463),p=n(6036),E=n(6401),_=n(4092),m=n(6661),g=n(9241),I=n(7360),N=n(6145),O=n(4098),R=n(8207),y=n(7422),C=n(6907),x=n(8817);let L={};const M=new o.H;function P(e){const t=e.toString();if(L.hasOwnProperty(t))return L[t];{const e=M.pattern(t);return L[t]=e,e}}function k(){L={}}const S="Complement Sets are not supported for first char optimization",D='Unable to use "first char" lexer optimizations:\n';function v(e,t=!1){try{const t=P(e),n=U(t.value,{},t.flags.ignoreCase);return n}catch(n){if(n.message===S)t&&(0,C.x)(`${D}\tUnable to optimize: < ${e.toString()} >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);else{let n="";t&&(n="\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."),(0,C.Z)(`${D}\n\tFailed parsing: < ${e.toString()} >\n\tUsing the @chevrotain/regexp-to-ast library\n\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues`+n)}}return[]}function U(e,t,n){switch(e.type){case"Disjunction":for(let i=0;i<e.value.length;i++)U(e.value[i],t,n);break;case"Alternative":const o=e.value;for(let e=0;e<o.length;e++){const i=o[e];switch(i.type){case"EndAnchor":case"GroupBackReference":case"Lookahead":case"NegativeLookahead":case"StartAnchor":case"WordBoundary":case"NonWordBoundary":continue}const r=i;switch(r.type){case"Character":b(r.value,t,n);break;case"Set":if(!0===r.complement)throw Error(S);(0,p.A)(r.value,(e=>{if("number"===typeof e)b(e,t,n);else{const o=e;if(!0===n)for(let e=o.from;e<=o.to;e++)b(e,t,n);else{for(let e=o.from;e<=o.to&&e<Ie;e++)b(e,t,n);if(o.to>=Ie){const e=o.from>=Ie?o.from:Ie,n=o.to,i=Oe(e),r=Oe(n);for(let o=i;o<=r;o++)t[o]=o}}}}));break;case"Group":U(r.value,t,n);break;default:throw Error("Non Exhaustive Match")}const s=void 0!==r.quantifier&&0===r.quantifier.atLeast;if("Group"===r.type&&!1===G(r)||"Group"!==r.type&&!1===s)break}break;default:throw Error("non exhaustive match!")}return(0,R.A)(t)}function b(e,t,n){const o=Oe(e);t[o]=o,!0===n&&w(e,t)}function w(e,t){const n=String.fromCharCode(e),o=n.toUpperCase();if(o!==n){const e=Oe(o.charCodeAt(0));t[e]=e}else{const e=n.toLowerCase();if(e!==n){const n=Oe(e.charCodeAt(0));t[n]=n}}}function F(e,t){return(0,N.A)(e.value,(e=>{if("number"===typeof e)return(0,c.A)(t,e);{const n=e;return void 0!==(0,N.A)(t,(e=>n.from<=e&&e<=n.to))}}))}function G(e){const t=e.quantifier;return!(!t||0!==t.atLeast)||!!e.value&&((0,T.A)(e.value)?(0,x.A)(e.value,G):G(e.value))}class z extends o.z{constructor(e){super(),this.targetCharCodes=e,this.found=!1}visitChildren(e){if(!0!==this.found){switch(e.type){case"Lookahead":return void this.visitLookahead(e);case"NegativeLookahead":return void this.visitNegativeLookahead(e)}super.visitChildren(e)}}visitCharacter(e){(0,c.A)(this.targetCharCodes,e.value)&&(this.found=!0)}visitSet(e){e.complement?void 0===F(e,this.targetCharCodes)&&(this.found=!0):void 0!==F(e,this.targetCharCodes)&&(this.found=!0)}}function $(e,t){if(t instanceof RegExp){const n=P(t),o=new z(e);return o.visit(n),o.found}return void 0!==(0,N.A)(t,(t=>(0,c.A)(e,t.charCodeAt(0))))}const H="PATTERN",B="defaultMode",W="modes";let X="boolean"===typeof new RegExp("(?:)").sticky;function K(e,t){t=(0,i.A)(t,{useSticky:X,debug:!1,safeMode:!1,positionTracking:"full",lineTerminatorCharacters:["\r","\n"],tracer:(e,t)=>t()});const n=t.tracer;let o;n("initCharCodeToOptimizedIndexMap",(()=>{Re()})),n("Reject Lexer.NA",(()=>{o=(0,r.A)(e,(e=>e[H]===be.NA))}));let _,m,g,I,N,O,R,y,x,L,M,P=!1;n("Transform Patterns",(()=>{P=!1,_=(0,s.A)(o,(e=>{const n=e[H];if((0,a.A)(n)){const e=n.source;return 1!==e.length||"^"===e||"$"===e||"."===e||n.ignoreCase?2!==e.length||"\\"!==e[0]||(0,c.A)(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],e[1])?t.useSticky?ue(n):he(n):e[1]:e}if((0,h.A)(n))return P=!0,{exec:n};if("object"===typeof n)return P=!0,n;if("string"===typeof n){if(1===n.length)return n;{const e=n.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&"),o=new RegExp(e);return t.useSticky?ue(o):he(o)}}throw Error("non exhaustive match")}))})),n("misc mapping",(()=>{m=(0,s.A)(o,(e=>e.tokenTypeIdx)),g=(0,s.A)(o,(e=>{const t=e.GROUP;if(t!==be.SKIPPED){if((0,u.A)(t))return t;if((0,l.A)(t))return!1;throw Error("non exhaustive match")}})),I=(0,s.A)(o,(e=>{const t=e.LONGER_ALT;if(t){const e=(0,T.A)(t)?(0,s.A)(t,(e=>(0,d.A)(o,e))):[(0,d.A)(o,t)];return e}})),N=(0,s.A)(o,(e=>e.PUSH_MODE)),O=(0,s.A)(o,(e=>(0,A.A)(e,"POP_MODE")))})),n("Line Terminator Handling",(()=>{const e=me(t.lineTerminatorCharacters);R=(0,s.A)(o,(e=>!1)),"onlyOffset"!==t.positionTracking&&(R=(0,s.A)(o,(t=>(0,A.A)(t,"LINE_BREAKS")?!!t.LINE_BREAKS:!1===Ee(t,e)&&$(e,t.PATTERN))))})),n("Misc Mapping #2",(()=>{y=(0,s.A)(o,Ae),x=(0,s.A)(_,fe),L=(0,f.A)(o,((e,t)=>{const n=t.GROUP;return(0,u.A)(n)&&n!==be.SKIPPED&&(e[n]=[]),e}),{}),M=(0,s.A)(_,((e,t)=>({pattern:_[t],longerAlt:I[t],canLineTerminator:R[t],isCustom:y[t],short:x[t],group:g[t],push:N[t],pop:O[t],tokenTypeIdx:m[t],tokenType:o[t]})))}));let k=!0,S=[];return t.safeMode||n("First Char Optimization",(()=>{S=(0,f.A)(o,((e,n,o)=>{if("string"===typeof n.PATTERN){const t=n.PATTERN.charCodeAt(0),i=Oe(t);ge(e,i,M[o])}else if((0,T.A)(n.START_CHARS_HINT)){let t;(0,p.A)(n.START_CHARS_HINT,(n=>{const i="string"===typeof n?n.charCodeAt(0):n,r=Oe(i);t!==r&&(t=r,ge(e,r,M[o]))}))}else if((0,a.A)(n.PATTERN))if(n.PATTERN.unicode)k=!1,t.ensureOptimizations&&(0,C.Z)(`${D}\tUnable to analyze < ${n.PATTERN.toString()} > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);else{const i=v(n.PATTERN,t.ensureOptimizations);(0,E.A)(i)&&(k=!1),(0,p.A)(i,(t=>{ge(e,t,M[o])}))}else t.ensureOptimizations&&(0,C.Z)(`${D}\tTokenType: <${n.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),k=!1;return e}),[])})),{emptyGroups:L,patternIdxToConfig:M,charCodeToPatternIdxToConfig:S,hasCustom:P,canBeOptimized:k}}function j(e,t){let n=[];const o=V(e);n=n.concat(o.errors);const i=Z(o.valid),r=i.valid;return n=n.concat(i.errors),n=n.concat(Y(r)),n=n.concat(ie(r)),n=n.concat(re(r,t)),n=n.concat(se(r)),n}function Y(e){let t=[];const n=(0,_.A)(e,(e=>(0,a.A)(e[H])));return t=t.concat(q(n)),t=t.concat(te(n)),t=t.concat(ne(n)),t=t.concat(oe(n)),t=t.concat(Q(n)),t}function V(e){const t=(0,_.A)(e,(e=>!(0,A.A)(e,H))),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- missing static 'PATTERN' property",type:ye.MISSING_PATTERN,tokenTypes:[e]}))),o=(0,m.A)(e,t);return{errors:n,valid:o}}function Z(e){const t=(0,_.A)(e,(e=>{const t=e[H];return!(0,a.A)(t)&&!(0,h.A)(t)&&!(0,A.A)(t,"exec")&&!(0,u.A)(t)})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:ye.INVALID_PATTERN,tokenTypes:[e]}))),o=(0,m.A)(e,t);return{errors:n,valid:o}}const J=/[^\\][$]/;function q(e){class t extends o.z{constructor(){super(...arguments),this.found=!1}visitEndAnchor(e){this.found=!0}}const n=(0,_.A)(e,(e=>{const n=e.PATTERN;try{const e=P(n),o=new t;return o.visit(e),o.found}catch(o){return J.test(n.source)}})),i=(0,s.A)(n,(e=>({message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+e.name+"<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:ye.EOI_ANCHOR_FOUND,tokenTypes:[e]})));return i}function Q(e){const t=(0,_.A)(e,(e=>{const t=e.PATTERN;return t.test("")})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' must not match an empty string",type:ye.EMPTY_MATCH_PATTERN,tokenTypes:[e]})));return n}const ee=/[^\\[][\^]|^\^/;function te(e){class t extends o.z{constructor(){super(...arguments),this.found=!1}visitStartAnchor(e){this.found=!0}}const n=(0,_.A)(e,(e=>{const n=e.PATTERN;try{const e=P(n),o=new t;return o.visit(e),o.found}catch(o){return ee.test(n.source)}})),i=(0,s.A)(n,(e=>({message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+e.name+"<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:ye.SOI_ANCHOR_FOUND,tokenTypes:[e]})));return i}function ne(e){const t=(0,_.A)(e,(e=>{const t=e[H];return t instanceof RegExp&&(t.multiline||t.global)})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:ye.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[e]})));return n}function oe(e){const t=[];let n=(0,s.A)(e,(n=>(0,f.A)(e,((e,o)=>(n.PATTERN.source!==o.PATTERN.source||(0,c.A)(t,o)||o.PATTERN===be.NA||(t.push(o),e.push(o)),e)),[])));n=(0,g.A)(n);const o=(0,_.A)(n,(e=>e.length>1)),i=(0,s.A)(o,(e=>{const t=(0,s.A)(e,(e=>e.name)),n=(0,I.A)(e).PATTERN;return{message:`The same RegExp pattern ->${n}<-has been used in all of the following Token Types: ${t.join(", ")} <-`,type:ye.DUPLICATE_PATTERNS_FOUND,tokenTypes:e}}));return i}function ie(e){const t=(0,_.A)(e,(e=>{if(!(0,A.A)(e,"GROUP"))return!1;const t=e.GROUP;return t!==be.SKIPPED&&t!==be.NA&&!(0,u.A)(t)})),n=(0,s.A)(t,(e=>({message:"Token Type: ->"+e.name+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:ye.INVALID_GROUP_TYPE_FOUND,tokenTypes:[e]})));return n}function re(e,t){const n=(0,_.A)(e,(e=>void 0!==e.PUSH_MODE&&!(0,c.A)(t,e.PUSH_MODE))),o=(0,s.A)(n,(e=>{const t=`Token Type: ->${e.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${e.PUSH_MODE}<-which does not exist`;return{message:t,type:ye.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[e]}}));return o}function se(e){const t=[],n=(0,f.A)(e,((e,t,n)=>{const o=t.PATTERN;return o===be.NA||((0,u.A)(o)?e.push({str:o,idx:n,tokenType:t}):(0,a.A)(o)&&ce(o)&&e.push({str:o.source,idx:n,tokenType:t})),e}),[]);return(0,p.A)(e,((e,o)=>{(0,p.A)(n,(({str:n,idx:i,tokenType:r})=>{if(o<i&&ae(n,e.PATTERN)){const n=`Token: ->${r.name}<- can never be matched.\nBecause it appears AFTER the Token Type ->${e.name}<-in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;t.push({message:n,type:ye.UNREACHABLE_PATTERN,tokenTypes:[e,r]})}}))})),t}function ae(e,t){if((0,a.A)(t)){const n=t.exec(e);return null!==n&&0===n.index}if((0,h.A)(t))return t(e,0,[],{});if((0,A.A)(t,"exec"))return t.exec(e,0,[],{});if("string"===typeof t)return t===e;throw Error("non exhaustive match")}function ce(e){const t=[".","\\","[","]","|","^","$","(",")","?","*","+","{"];return void 0===(0,N.A)(t,(t=>-1!==e.source.indexOf(t)))}function he(e){const t=e.ignoreCase?"i":"";return new RegExp(`^(?:${e.source})`,t)}function ue(e){const t=e.ignoreCase?"iy":"y";return new RegExp(`${e.source}`,t)}function le(e,t,n){const o=[];return(0,A.A)(e,B)||o.push({message:"A MultiMode Lexer cannot be initialized without a <"+B+"> property in its definition\n",type:ye.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),(0,A.A)(e,W)||o.push({message:"A MultiMode Lexer cannot be initialized without a <"+W+"> property in its definition\n",type:ye.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),(0,A.A)(e,W)&&(0,A.A)(e,B)&&!(0,A.A)(e.modes,e.defaultMode)&&o.push({message:`A MultiMode Lexer cannot be initialized with a ${B}: <${e.defaultMode}>which does not exist\n`,type:ye.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),(0,A.A)(e,W)&&(0,p.A)(e.modes,((e,t)=>{(0,p.A)(e,((n,i)=>{if((0,l.A)(n))o.push({message:`A Lexer cannot be initialized using an undefined Token Type. Mode:<${t}> at index: <${i}>\n`,type:ye.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});else if((0,A.A)(n,"LONGER_ALT")){const i=(0,T.A)(n.LONGER_ALT)?n.LONGER_ALT:[n.LONGER_ALT];(0,p.A)(i,(i=>{(0,l.A)(i)||(0,c.A)(e,i)||o.push({message:`A MultiMode Lexer cannot be initialized with a longer_alt <${i.name}> on token <${n.name}> outside of mode <${t}>\n`,type:ye.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE})}))}}))})),o}function Te(e,t,n){const o=[];let i=!1;const s=(0,g.A)((0,O.A)((0,R.A)(e.modes))),a=(0,r.A)(s,(e=>e[H]===be.NA)),c=me(n);return t&&(0,p.A)(a,(e=>{const t=Ee(e,c);if(!1!==t){const n=_e(e,t),i={message:n,type:t.issue,tokenType:e};o.push(i)}else(0,A.A)(e,"LINE_BREAKS")?!0===e.LINE_BREAKS&&(i=!0):$(c,e.PATTERN)&&(i=!0)})),t&&!i&&o.push({message:"Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n\tfor details.",type:ye.NO_LINE_BREAKS_FLAGS}),o}function de(e){const t={},n=(0,y.A)(e);return(0,p.A)(n,(n=>{const o=e[n];if(!(0,T.A)(o))throw Error("non exhaustive match");t[n]=[]})),t}function Ae(e){const t=e.PATTERN;if((0,a.A)(t))return!1;if((0,h.A)(t))return!0;if((0,A.A)(t,"exec"))return!0;if((0,u.A)(t))return!1;throw Error("non exhaustive match")}function fe(e){return!(!(0,u.A)(e)||1!==e.length)&&e.charCodeAt(0)}const pe={test:function(e){const t=e.length;for(let n=this.lastIndex;n<t;n++){const t=e.charCodeAt(n);if(10===t)return this.lastIndex=n+1,!0;if(13===t)return 10===e.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return!1},lastIndex:0};function Ee(e,t){if((0,A.A)(e,"LINE_BREAKS"))return!1;if((0,a.A)(e.PATTERN)){try{$(t,e.PATTERN)}catch(n){return{issue:ye.IDENTIFY_TERMINATOR,errMsg:n.message}}return!1}if((0,u.A)(e.PATTERN))return!1;if(Ae(e))return{issue:ye.CUSTOM_LINE_BREAK};throw Error("non exhaustive match")}function _e(e,t){if(t.issue===ye.IDENTIFY_TERMINATOR)return`Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <${e.name}> Token Type\n\t Root cause: ${t.errMsg}.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;if(t.issue===ye.CUSTOM_LINE_BREAK)return`Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <${e.name}> Token Type\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;throw Error("non exhaustive match")}function me(e){const t=(0,s.A)(e,(e=>(0,u.A)(e)?e.charCodeAt(0):e));return t}function ge(e,t,n){void 0===e[t]?e[t]=[n]:e[t].push(n)}const Ie=256;let Ne=[];function Oe(e){return e<Ie?e:Ne[e]}function Re(){if((0,E.A)(Ne)){Ne=new Array(65536);for(let e=0;e<65536;e++)Ne[e]=e>255?255+~~(e/255):e}}var ye,Ce=n(7447),xe=n(2935),Le=n(9008),Me=n(2302),Pe=n(6666),ke=n(9),Se=n(6786),De=n(3590),ve=n(2566);(function(e){e[e["MISSING_PATTERN"]=0]="MISSING_PATTERN",e[e["INVALID_PATTERN"]=1]="INVALID_PATTERN",e[e["EOI_ANCHOR_FOUND"]=2]="EOI_ANCHOR_FOUND",e[e["UNSUPPORTED_FLAGS_FOUND"]=3]="UNSUPPORTED_FLAGS_FOUND",e[e["DUPLICATE_PATTERNS_FOUND"]=4]="DUPLICATE_PATTERNS_FOUND",e[e["INVALID_GROUP_TYPE_FOUND"]=5]="INVALID_GROUP_TYPE_FOUND",e[e["PUSH_MODE_DOES_NOT_EXIST"]=6]="PUSH_MODE_DOES_NOT_EXIST",e[e["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"]=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",e[e["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"]=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",e[e["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"]=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",e[e["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"]=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",e[e["SOI_ANCHOR_FOUND"]=11]="SOI_ANCHOR_FOUND",e[e["EMPTY_MATCH_PATTERN"]=12]="EMPTY_MATCH_PATTERN",e[e["NO_LINE_BREAKS_FLAGS"]=13]="NO_LINE_BREAKS_FLAGS",e[e["UNREACHABLE_PATTERN"]=14]="UNREACHABLE_PATTERN",e[e["IDENTIFY_TERMINATOR"]=15]="IDENTIFY_TERMINATOR",e[e["CUSTOM_LINE_BREAK"]=16]="CUSTOM_LINE_BREAK",e[e["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"]=17]="MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"})(ye||(ye={}));const Ue={deferDefinitionErrorsHandling:!1,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:["\n","\r"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:ve.P,traceInitPerf:!1,skipValidations:!1,recoveryEnabled:!0};Object.freeze(Ue);class be{constructor(e,t=Ue){if(this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},this.TRACE_INIT=(e,t)=>{if(!0===this.traceInitPerf){this.traceInitIndent++;const n=new Array(this.traceInitIndent+1).join("\t");this.traceInitIndent<this.traceInitMaxIdent&&console.log(`${n}--\x3e <${e}>`);const{time:o,value:i}=(0,ke.O)(t),r=o>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&r(`${n}<-- <${e}> time: ${o}ms`),this.traceInitIndent--,i}return t()},"boolean"===typeof t)throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");this.config=(0,Ce.A)({},Ue,t);const n=this.config.traceInitPerf;!0===n?(this.traceInitMaxIdent=1/0,this.traceInitPerf=!0):"number"===typeof n&&(this.traceInitMaxIdent=n,this.traceInitPerf=!0),this.traceInitIndent=-1,this.TRACE_INIT("Lexer Constructor",(()=>{let n,o=!0;this.TRACE_INIT("Lexer Config handling",(()=>{if(this.config.lineTerminatorsPattern===Ue.lineTerminatorsPattern)this.config.lineTerminatorsPattern=pe;else if(this.config.lineTerminatorCharacters===Ue.lineTerminatorCharacters)throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");if(t.safeMode&&t.ensureOptimizations)throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking),(0,T.A)(e)?n={modes:{defaultMode:(0,xe.A)(e)},defaultMode:B}:(o=!1,n=(0,xe.A)(e))})),!1===this.config.skipValidations&&(this.TRACE_INIT("performRuntimeChecks",(()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(le(n,this.trackStartLines,this.config.lineTerminatorCharacters))})),this.TRACE_INIT("performWarningRuntimeChecks",(()=>{this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(Te(n,this.trackStartLines,this.config.lineTerminatorCharacters))}))),n.modes=n.modes?n.modes:{},(0,p.A)(n.modes,((e,t)=>{n.modes[t]=(0,r.A)(e,(e=>(0,l.A)(e)))}));const i=(0,y.A)(n.modes);if((0,p.A)(n.modes,((e,n)=>{this.TRACE_INIT(`Mode: <${n}> processing`,(()=>{if(this.modes.push(n),!1===this.config.skipValidations&&this.TRACE_INIT("validatePatterns",(()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(j(e,i))})),(0,E.A)(this.lexerDefinitionErrors)){let o;(0,De.SF)(e),this.TRACE_INIT("analyzeTokenTypes",(()=>{o=K(e,{lineTerminatorCharacters:this.config.lineTerminatorCharacters,positionTracking:t.positionTracking,ensureOptimizations:t.ensureOptimizations,safeMode:t.safeMode,tracer:this.TRACE_INIT})})),this.patternIdxToConfig[n]=o.patternIdxToConfig,this.charCodeToPatternIdxToConfig[n]=o.charCodeToPatternIdxToConfig,this.emptyGroups=(0,Ce.A)({},this.emptyGroups,o.emptyGroups),this.hasCustom=o.hasCustom||this.hasCustom,this.canModeBeOptimized[n]=o.canBeOptimized}}))})),this.defaultMode=n.defaultMode,!(0,E.A)(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){const e=(0,s.A)(this.lexerDefinitionErrors,(e=>e.message)),t=e.join("-----------------------\n");throw new Error("Errors detected in definition of Lexer:\n"+t)}(0,p.A)(this.lexerDefinitionWarning,(e=>{(0,C.x)(e.message)})),this.TRACE_INIT("Choosing sub-methods implementations",(()=>{if(X?(this.chopInput=Le.A,this.match=this.matchWithTest):(this.updateLastIndex=Me.A,this.match=this.matchWithExec),o&&(this.handleModes=Me.A),!1===this.trackStartLines&&(this.computeNewColumn=Le.A),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=Me.A),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else{if(!/onlyOffset/i.test(this.config.positionTracking))throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);this.createTokenInstance=this.createOffsetOnlyToken}this.hasCustom?(this.addToken=this.addTokenUsingPush,this.handlePayload=this.handlePayloadWithCustom):(this.addToken=this.addTokenUsingMemberAccess,this.handlePayload=this.handlePayloadNoCustom)})),this.TRACE_INIT("Failed Optimization Warnings",(()=>{const e=(0,f.A)(this.canModeBeOptimized,((e,t,n)=>(!1===t&&e.push(n),e)),[]);if(t.ensureOptimizations&&!(0,E.A)(e))throw Error(`Lexer Modes: < ${e.join(", ")} > cannot be optimized.\n\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`)})),this.TRACE_INIT("clearRegExpParserCache",(()=>{k()})),this.TRACE_INIT("toFastProperties",(()=>{(0,Se.B)(this)}))}))}tokenize(e,t=this.defaultMode){if(!(0,E.A)(this.lexerDefinitionErrors)){const e=(0,s.A)(this.lexerDefinitionErrors,(e=>e.message)),t=e.join("-----------------------\n");throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n"+t)}return this.tokenizeInternal(e,t)}tokenizeInternal(e,t){let n,o,i,r,s,a,c,h,u,l,T,d,A,f,p;const E=e,_=E.length;let m=0,g=0;const I=this.hasCustom?0:Math.floor(e.length/10),N=new Array(I),O=[];let R=this.trackStartLines?1:void 0,y=this.trackStartLines?1:void 0;const C=de(this.emptyGroups),x=this.trackStartLines,L=this.config.lineTerminatorsPattern;let M=0,P=[],k=[];const S=[],D=[];let v;function U(){return P}function b(e){const t=Oe(e),n=k[t];return void 0===n?D:n}Object.freeze(D);const w=e=>{if(1===S.length&&void 0===e.tokenType.PUSH_MODE){const t=this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(e);O.push({offset:e.startOffset,line:e.startLine,column:e.startColumn,length:e.image.length,message:t})}else{S.pop();const e=(0,Pe.A)(S);P=this.patternIdxToConfig[e],k=this.charCodeToPatternIdxToConfig[e],M=P.length;const t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;v=k&&t?b:U}};function F(e){S.push(e),k=this.charCodeToPatternIdxToConfig[e],P=this.patternIdxToConfig[e],M=P.length,M=P.length;const t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;v=k&&t?b:U}let G;F.call(this,t);const z=this.config.recoveryEnabled;while(m<_){a=null;const t=E.charCodeAt(m),I=v(t),k=I.length;for(n=0;n<k;n++){G=I[n];const o=G.pattern;c=null;const u=G.short;if(!1!==u?t===u&&(a=o):!0===G.isCustom?(p=o.exec(E,m,N,C),null!==p?(a=p[0],void 0!==p.payload&&(c=p.payload)):a=null):(this.updateLastIndex(o,m),a=this.match(o,e,m)),null!==a){if(s=G.longerAlt,void 0!==s){const t=s.length;for(i=0;i<t;i++){const t=P[s[i]],n=t.pattern;if(h=null,!0===t.isCustom?(p=n.exec(E,m,N,C),null!==p?(r=p[0],void 0!==p.payload&&(h=p.payload)):r=null):(this.updateLastIndex(n,m),r=this.match(n,e,m)),r&&r.length>a.length){a=r,c=h,G=t;break}}}break}}if(null!==a){if(u=a.length,l=G.group,void 0!==l&&(T=G.tokenTypeIdx,d=this.createTokenInstance(a,m,T,G.tokenType,R,y,u),this.handlePayload(d,c),!1===l?g=this.addToken(N,g,d):C[l].push(d)),e=this.chopInput(e,u),m+=u,y=this.computeNewColumn(y,u),!0===x&&!0===G.canLineTerminator){let e,t,n=0;L.lastIndex=0;do{e=L.test(a),!0===e&&(t=L.lastIndex-1,n++)}while(!0===e);0!==n&&(R+=n,y=u-t,this.updateTokenEndLineColumnLocation(d,l,t,n,R,y,u))}this.handleModes(G,w,F,d)}else{const t=m,n=R,i=y;let r=!1===z;while(!1===r&&m<_)for(e=this.chopInput(e,1),m++,o=0;o<M;o++){const t=P[o],n=t.pattern,i=t.short;if(!1!==i?E.charCodeAt(m)===i&&(r=!0):!0===t.isCustom?r=null!==n.exec(E,m,N,C):(this.updateLastIndex(n,m),r=null!==n.exec(e)),!0===r)break}if(A=m-t,y=this.computeNewColumn(y,A),f=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(E,t,A,n,i),O.push({offset:t,line:n,column:i,length:A,message:f}),!1===z)break}}return this.hasCustom||(N.length=g),{tokens:N,groups:C,errors:O}}handleModes(e,t,n,o){if(!0===e.pop){const i=e.push;t(o),void 0!==i&&n.call(this,i)}else void 0!==e.push&&n.call(this,e.push)}chopInput(e,t){return e.substring(t)}updateLastIndex(e,t){e.lastIndex=t}updateTokenEndLineColumnLocation(e,t,n,o,i,r,s){let a,c;void 0!==t&&(a=n===s-1,c=a?-1:0,1===o&&!0===a||(e.endLine=i+c,e.endColumn=r-1-c))}computeNewColumn(e,t){return e+t}createOffsetOnlyToken(e,t,n,o){return{image:e,startOffset:t,tokenTypeIdx:n,tokenType:o}}createStartOnlyToken(e,t,n,o,i,r){return{image:e,startOffset:t,startLine:i,startColumn:r,tokenTypeIdx:n,tokenType:o}}createFullToken(e,t,n,o,i,r,s){return{image:e,startOffset:t,endOffset:t+s-1,startLine:i,endLine:i,startColumn:r,endColumn:r+s-1,tokenTypeIdx:n,tokenType:o}}addTokenUsingPush(e,t,n){return e.push(n),t}addTokenUsingMemberAccess(e,t,n){return e[t]=n,t++,t}handlePayloadNoCustom(e,t){}handlePayloadWithCustom(e,t){null!==t&&(e.payload=t)}matchWithTest(e,t,n){const o=e.test(t);return!0===o?t.substring(n,e.lastIndex):null}matchWithExec(e,t){const n=e.exec(t);return null!==n?n[0]:null}}be.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.",be.NA=/NOT_APPLICABLE/},3590:function(e,t,n){n.d(t,{E8:function(){return x},Jx:function(){return O},SF:function(){return E},xU:function(){return d},yJ:function(){return A}});var o=n(6036),i=n(2935),r=n(9241),s=n(4098),a=n(2636),c=n(6661),h=n(6401),u=n(2049),l=n(2531),T=n(8585);function d(e,t){const n=e.tokenTypeIdx;return n===t.tokenTypeIdx||!0===t.isParent&&!0===t.categoryMatchesMap[n]}function A(e,t){return e.tokenTypeIdx===t.tokenTypeIdx}let f=1;const p={};function E(e){const t=_(e);m(t),I(t),g(t),(0,o.A)(t,(e=>{e.isParent=e.categoryMatches.length>0}))}function _(e){let t=(0,i.A)(e),n=e,o=!0;while(o){n=(0,r.A)((0,s.A)((0,a.A)(n,(e=>e.CATEGORIES))));const e=(0,c.A)(n,t);t=t.concat(e),(0,h.A)(e)?o=!1:n=e}return t}function m(e){(0,o.A)(e,(e=>{O(e)||(p[f]=e,e.tokenTypeIdx=f++),R(e)&&!(0,u.A)(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),R(e)||(e.CATEGORIES=[]),y(e)||(e.categoryMatches=[]),C(e)||(e.categoryMatchesMap={})}))}function g(e){(0,o.A)(e,(e=>{e.categoryMatches=[],(0,o.A)(e.categoryMatchesMap,((t,n)=>{e.categoryMatches.push(p[n].tokenTypeIdx)}))}))}function I(e){(0,o.A)(e,(e=>{N([],e)}))}function N(e,t){(0,o.A)(e,(e=>{t.categoryMatchesMap[e.tokenTypeIdx]=!0})),(0,o.A)(t.CATEGORIES,(n=>{const o=e.concat(t);(0,l.A)(o,n)||N(o,n)}))}function O(e){return(0,T.A)(e,"tokenTypeIdx")}function R(e){return(0,T.A)(e,"CATEGORIES")}function y(e){return(0,T.A)(e,"categoryMatches")}function C(e){return(0,T.A)(e,"categoryMatchesMap")}function x(e){return(0,T.A)(e,"tokenTypeIdx")}},1620:function(e,t,n){n.d(t,{Ey:function(){return m},G:function(){return O},LT:function(){return I},Q:function(){return h},Sk:function(){return c},fx:function(){return N}});var o=n(9703),i=n(9592),r=n(8585),s=n(6495),a=n(3590);function c(e){return h(e)?e.LABEL:e.name}function h(e){return(0,o.A)(e.LABEL)&&""!==e.LABEL}const u="parent",l="categories",T="label",d="group",A="push_mode",f="pop_mode",p="longer_alt",E="line_breaks",_="start_chars_hint";function m(e){return g(e)}function g(e){const t=e.pattern,n={};if(n.name=e.name,(0,i.A)(t)||(n.PATTERN=t),(0,r.A)(e,u))throw"The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";return(0,r.A)(e,l)&&(n.CATEGORIES=e[l]),(0,a.SF)([n]),(0,r.A)(e,T)&&(n.LABEL=e[T]),(0,r.A)(e,d)&&(n.GROUP=e[d]),(0,r.A)(e,f)&&(n.POP_MODE=e[f]),(0,r.A)(e,A)&&(n.PUSH_MODE=e[A]),(0,r.A)(e,p)&&(n.LONGER_ALT=e[p]),(0,r.A)(e,E)&&(n.LINE_BREAKS=e[E]),(0,r.A)(e,_)&&(n.START_CHARS_HINT=e[_]),n}const I=m({name:"EOF",pattern:s.J.NA});function N(e,t,n,o,i,r,s,a){return{image:t,startOffset:n,endOffset:o,startLine:i,endLine:r,startColumn:s,endColumn:a,tokenTypeIdx:e.tokenTypeIdx,tokenType:e}}function O(e,t){return(0,a.xU)(e,t)}(0,a.SF)([I])}}]);
//# sourceMappingURL=620.e0c1d512.js.map